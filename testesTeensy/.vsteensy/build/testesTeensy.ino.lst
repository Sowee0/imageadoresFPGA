
C:\Users\sowee\Documents\git\imageadoresFPGA\testesTeensy\.vsTeensy\build/testesTeensy.ino.elf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <_VectorsFlash>:
       0:	00 18 00 20 c1 00 00 00 11 0d 00 00 c1 0c 00 00     ... ............
      10:	c1 0c 00 00 c1 0c 00 00 c1 0c 00 00 c1 0c 00 00     ................
      20:	c1 0c 00 00 c1 0c 00 00 c1 0c 00 00 11 0d 00 00     ................
      30:	11 0d 00 00 c1 0c 00 00 69 1f 00 00 d1 21 00 00     ........i....!..
      40:	11 0d 00 00 11 0d 00 00 11 0d 00 00 11 0d 00 00     ................
      50:	11 0d 00 00 11 0d 00 00 11 0d 00 00 11 0d 00 00     ................
      60:	3d 0b 00 00 11 0d 00 00 11 0d 00 00 11 0d 00 00     =...............
      70:	d5 22 00 00 c1 23 00 00 ad 24 00 00 11 0d 00 00     ."...#...$......
      80:	11 0d 00 00 11 0d 00 00 11 0d 00 00 11 0d 00 00     ................
      90:	11 0d 00 00 11 0d 00 00 11 0d 00 00 11 0d 00 00     ................
      a0:	c5 12 00 00 11 0d 00 00 11 0d 00 00 11 0d 00 00     ................
      b0:	11 0d 00 00 11 0d 00 00 11 0d 00 00 11 0d 00 00     ................

000000c0 <ResetHandler>:
#else
// hopefully all others fit into startup section (below 0x400)
__attribute__ ((section(".startup"),optimize("-Os")))
#endif
void ResetHandler(void)
{
      c0:	b5f0      	push	{r4, r5, r6, r7, lr}
      c2:	4647      	mov	r7, r8
      c4:	b480      	push	{r7}
	__asm__ volatile ("nop");
	__asm__ volatile ("nop");
#endif
	// programs using the watchdog timer or needing to initialize hardware as
	// early as possible can implement startup_early_hook()
	startup_early_hook();
      c6:	f000 fe27 	bl	d18 <startup_early_hook>
		RTC_SR = 0;
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif
	// release I/O pins hold, if we woke up from VLLS mode
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
      ca:	2108      	movs	r1, #8
	//PORTC_PCR5 = PORT_PCR_MUX(1) | PORT_PCR_DSE | PORT_PCR_SRE;
	//GPIOC_PDDR |= (1<<5);
	//GPIOC_PSOR = (1<<5);
	//while (1);
#elif defined(__MKL26Z64__)
	SIM_SCGC4 = SIM_SCGC4_USBOTG | 0xF0000030;
      cc:	4a47      	ldr	r2, [pc, #284]	; (1ec <ResetHandler+0x12c>)
      ce:	4b48      	ldr	r3, [pc, #288]	; (1f0 <ResetHandler+0x130>)
      d0:	601a      	str	r2, [r3, #0]
	SIM_SCGC5 = 0x00003F82;		// clocks active to all GPIO
      d2:	4a48      	ldr	r2, [pc, #288]	; (1f4 <ResetHandler+0x134>)
      d4:	4b48      	ldr	r3, [pc, #288]	; (1f8 <ResetHandler+0x138>)
      d6:	601a      	str	r2, [r3, #0]
	SIM_SCGC6 = SIM_SCGC6_ADC0 | SIM_SCGC6_TPM0 | SIM_SCGC6_TPM1 | SIM_SCGC6_TPM2 | SIM_SCGC6_FTFL;
      d8:	4a48      	ldr	r2, [pc, #288]	; (1fc <ResetHandler+0x13c>)
      da:	4b49      	ldr	r3, [pc, #292]	; (200 <ResetHandler+0x140>)
      dc:	601a      	str	r2, [r3, #0]
		RTC_SR = 0;
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif
	// release I/O pins hold, if we woke up from VLLS mode
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
      de:	4b49      	ldr	r3, [pc, #292]	; (204 <ResetHandler+0x144>)
      e0:	781a      	ldrb	r2, [r3, #0]
      e2:	420a      	tst	r2, r1
      e4:	d002      	beq.n	ec <ResetHandler+0x2c>
      e6:	781a      	ldrb	r2, [r3, #0]
      e8:	430a      	orrs	r2, r1
      ea:	701a      	strb	r2, [r3, #0]
    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
      ec:	222a      	movs	r2, #42	; 0x2a
      ee:	4b46      	ldr	r3, [pc, #280]	; (208 <ResetHandler+0x148>)
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
      f0:	4c46      	ldr	r4, [pc, #280]	; (20c <ResetHandler+0x14c>)
    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
      f2:	701a      	strb	r2, [r3, #0]
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
      f4:	2300      	movs	r3, #0
      f6:	4846      	ldr	r0, [pc, #280]	; (210 <ResetHandler+0x150>)
      f8:	4946      	ldr	r1, [pc, #280]	; (214 <ResetHandler+0x154>)
      fa:	191a      	adds	r2, r3, r4
      fc:	4282      	cmp	r2, r0
      fe:	d203      	bcs.n	108 <ResetHandler+0x48>
     100:	58cd      	ldr	r5, [r1, r3]
     102:	3304      	adds	r3, #4
     104:	6015      	str	r5, [r2, #0]
     106:	e7f8      	b.n	fa <ResetHandler+0x3a>
     108:	2200      	movs	r2, #0
     10a:	4b43      	ldr	r3, [pc, #268]	; (218 <ResetHandler+0x158>)
	dest = &_sbss;
	while (dest < &_ebss) *dest++ = 0;
     10c:	4943      	ldr	r1, [pc, #268]	; (21c <ResetHandler+0x15c>)
     10e:	428b      	cmp	r3, r1
     110:	d201      	bcs.n	116 <ResetHandler+0x56>
     112:	c304      	stmia	r3!, {r2}
     114:	e7fb      	b.n	10e <ResetHandler+0x4e>
     116:	2300      	movs	r3, #0

	// default all interrupts to medium priority level
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = _VectorsFlash[i];
     118:	4a41      	ldr	r2, [pc, #260]	; (220 <ResetHandler+0x160>)
     11a:	4942      	ldr	r1, [pc, #264]	; (224 <ResetHandler+0x164>)
     11c:	5858      	ldr	r0, [r3, r1]
     11e:	4690      	mov	r8, r2
     120:	5098      	str	r0, [r3, r2]
     122:	3304      	adds	r3, #4
     124:	2bc0      	cmp	r3, #192	; 0xc0
     126:	d1f9      	bne.n	11c <ResetHandler+0x5c>
     128:	2200      	movs	r2, #0
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
     12a:	2703      	movs	r7, #3
     12c:	26ff      	movs	r6, #255	; 0xff
     12e:	2580      	movs	r5, #128	; 0x80
     130:	493d      	ldr	r1, [pc, #244]	; (228 <ResetHandler+0x168>)
     132:	0030      	movs	r0, r6
     134:	468c      	mov	ip, r1
     136:	0011      	movs	r1, r2
     138:	4039      	ands	r1, r7
     13a:	00c9      	lsls	r1, r1, #3
     13c:	4088      	lsls	r0, r1
     13e:	0893      	lsrs	r3, r2, #2
     140:	009b      	lsls	r3, r3, #2
     142:	4463      	add	r3, ip
     144:	681c      	ldr	r4, [r3, #0]
     146:	3201      	adds	r2, #1
     148:	4384      	bics	r4, r0
     14a:	0020      	movs	r0, r4
     14c:	002c      	movs	r4, r5
     14e:	408c      	lsls	r4, r1
     150:	0021      	movs	r1, r4
     152:	4301      	orrs	r1, r0
     154:	6019      	str	r1, [r3, #0]
     156:	2a20      	cmp	r2, #32
     158:	d1ea      	bne.n	130 <ResetHandler+0x70>
	SCB_VTOR = (uint32_t)_VectorsRam;	// use vector table in RAM
     15a:	4642      	mov	r2, r8
     15c:	4b33      	ldr	r3, [pc, #204]	; (22c <ResetHandler+0x16c>)
     15e:	601a      	str	r2, [r3, #0]
    #if defined(KINETISK)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
    #elif defined(KINETISL)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
     160:	228a      	movs	r2, #138	; 0x8a
     162:	4b33      	ldr	r3, [pc, #204]	; (230 <ResetHandler+0x170>)
     164:	701a      	strb	r2, [r3, #0]
    #endif
	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;
     166:	4b33      	ldr	r3, [pc, #204]	; (234 <ResetHandler+0x174>)
     168:	3a66      	subs	r2, #102	; 0x66
     16a:	705a      	strb	r2, [r3, #1]
	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);
     16c:	327c      	adds	r2, #124	; 0x7c
     16e:	701a      	strb	r2, [r3, #0]
	// wait for crystal oscillator to begin
	while ((MCG_S & MCG_S_OSCINIT0) == 0) ;
     170:	3a9e      	subs	r2, #158	; 0x9e
     172:	7999      	ldrb	r1, [r3, #6]
     174:	4211      	tst	r1, r2
     176:	d0fc      	beq.n	172 <ResetHandler+0xb2>
	// wait for FLL to use oscillator
	while ((MCG_S & MCG_S_IREFST) != 0) ;
     178:	2210      	movs	r2, #16
     17a:	7999      	ldrb	r1, [r3, #6]
     17c:	4211      	tst	r1, r2
     17e:	d1fc      	bne.n	17a <ResetHandler+0xba>
	// wait for MCGOUT to use oscillator
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;
     180:	200c      	movs	r0, #12
     182:	799a      	ldrb	r2, [r3, #6]
     184:	492b      	ldr	r1, [pc, #172]	; (234 <ResetHandler+0x174>)
     186:	4002      	ands	r2, r0
     188:	2a08      	cmp	r2, #8
     18a:	d1fa      	bne.n	182 <ResetHandler+0xc2>
    #endif
   #else
    #if F_CPU == 72000000
	MCG_C5 = MCG_C5_PRDIV0(5);		 // config PLL input for 16 MHz Crystal / 6 = 2.667 Hz
    #else
	MCG_C5 = MCG_C5_PRDIV0(3);		 // config PLL input for 16 MHz Crystal / 4 = 4 MHz
     18c:	3a05      	subs	r2, #5
     18e:	710a      	strb	r2, [r1, #4]
    #elif F_CPU == 120000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(6); // config PLL for 120 MHz output
    #elif F_CPU == 72000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(3); // config PLL for 72 MHz output
    #elif F_CPU == 96000000 || F_CPU == 48000000 || F_CPU == 24000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(0); // config PLL for 96 MHz output
     190:	323d      	adds	r2, #61	; 0x3d
     192:	714a      	strb	r2, [r1, #5]
    #error "This clock speed isn't supported..."
    #endif
   #endif

	// wait for PLL to start using xtal as its input
	while (!(MCG_S & MCG_S_PLLST)) ;
     194:	3a20      	subs	r2, #32
     196:	7999      	ldrb	r1, [r3, #6]
     198:	4211      	tst	r1, r2
     19a:	d0fc      	beq.n	196 <ResetHandler+0xd6>
	// wait for PLL to lock
	while (!(MCG_S & MCG_S_LOCK0)) ;
     19c:	2240      	movs	r2, #64	; 0x40
     19e:	7999      	ldrb	r1, [r3, #6]
     1a0:	4211      	tst	r1, r2
     1a2:	d0fc      	beq.n	19e <ResetHandler+0xde>
	// config divisors: 48 MHz core, 48 MHz bus, 24 MHz flash, USB = 96 / 2
  #if defined(KINETISK)
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(1) | SIM_CLKDIV1_OUTDIV2(1) | SIM_CLKDIV1_OUTDIV3(1) |  SIM_CLKDIV1_OUTDIV4(3);
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(1);
  #elif defined(KINETISL)
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(1) | SIM_CLKDIV1_OUTDIV4(1);
     1a4:	4924      	ldr	r1, [pc, #144]	; (238 <ResetHandler+0x178>)
     1a6:	4a25      	ldr	r2, [pc, #148]	; (23c <ResetHandler+0x17c>)
     1a8:	6011      	str	r1, [r2, #0]
#error "Error, F_CPU must be 256, 240, 216, 192, 180, 168, 144, 120, 96, 72, 48, 24, 16, 8, 4, or 2 MHz"
#endif

#if F_CPU > 16000000
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
     1aa:	2120      	movs	r1, #32
     1ac:	4a21      	ldr	r2, [pc, #132]	; (234 <ResetHandler+0x174>)
     1ae:	7011      	strb	r1, [r2, #0]
	// wait for PLL clock to be used
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
     1b0:	3914      	subs	r1, #20
     1b2:	799a      	ldrb	r2, [r3, #6]
     1b4:	400a      	ands	r2, r1
     1b6:	2a0c      	cmp	r2, #12
     1b8:	d1fb      	bne.n	1b2 <ResetHandler+0xf2>
	#else
	// USB uses PLL clock
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
	#endif
	#elif defined(KINETISL)
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_CLKOUTSEL(6)
     1ba:	4a21      	ldr	r2, [pc, #132]	; (240 <ResetHandler+0x180>)
     1bc:	4b21      	ldr	r3, [pc, #132]	; (244 <ResetHandler+0x184>)
     1be:	601a      	str	r2, [r3, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif

	// initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
     1c0:	4a21      	ldr	r2, [pc, #132]	; (248 <ResetHandler+0x188>)
     1c2:	4b22      	ldr	r3, [pc, #136]	; (24c <ResetHandler+0x18c>)
     1c4:	601a      	str	r2, [r3, #0]
	SYST_CVR = 0;
     1c6:	2200      	movs	r2, #0
     1c8:	4b21      	ldr	r3, [pc, #132]	; (250 <ResetHandler+0x190>)
     1ca:	601a      	str	r2, [r3, #0]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
     1cc:	4b21      	ldr	r3, [pc, #132]	; (254 <ResetHandler+0x194>)
     1ce:	3207      	adds	r2, #7
     1d0:	601a      	str	r2, [r3, #0]
	SCB_SHPR3 = 0x20200000;  // Systick = priority 32
     1d2:	4a21      	ldr	r2, [pc, #132]	; (258 <ResetHandler+0x198>)
     1d4:	4b21      	ldr	r3, [pc, #132]	; (25c <ResetHandler+0x19c>)
     1d6:	601a      	str	r2, [r3, #0]

	//init_pins();
	__enable_irq();
     1d8:	b662      	cpsie	i

	_init_Teensyduino_internal_();
     1da:	f000 fded 	bl	db8 <_init_Teensyduino_internal_>
		#endif
		*(uint32_t *)0x4003E01C = 0;
	}
#endif

	__libc_init_array();
     1de:	f002 fb15 	bl	280c <__libc_init_array>

	startup_late_hook();
     1e2:	f000 fd9f 	bl	d24 <startup_late_hook>
	main();
     1e6:	f000 fd63 	bl	cb0 <main>
     1ea:	e7fe      	b.n	1ea <ResetHandler+0x12a>
     1ec:	f0040030 	.word	0xf0040030
     1f0:	40048034 	.word	0x40048034
     1f4:	00003f82 	.word	0x00003f82
     1f8:	40048038 	.word	0x40048038
     1fc:	0f000001 	.word	0x0f000001
     200:	4004803c 	.word	0x4004803c
     204:	4007d002 	.word	0x4007d002
     208:	4007e000 	.word	0x4007e000
     20c:	1ffffd20 	.word	0x1ffffd20
     210:	2000068c 	.word	0x2000068c
     214:	0000346c 	.word	0x0000346c
     218:	2000068c 	.word	0x2000068c
     21c:	20000998 	.word	0x20000998
     220:	1ffff900 	.word	0x1ffff900
     224:	00000000 	.word	0x00000000
     228:	e000e400 	.word	0xe000e400
     22c:	e000ed08 	.word	0xe000ed08
     230:	40065000 	.word	0x40065000
     234:	40064000 	.word	0x40064000
     238:	10010000 	.word	0x10010000
     23c:	40048044 	.word	0x40048044
     240:	050500c0 	.word	0x050500c0
     244:	40048004 	.word	0x40048004
     248:	0000bb7f 	.word	0x0000bb7f
     24c:	e000e014 	.word	0xe000e014
     250:	e000e018 	.word	0xe000e018
     254:	e000e010 	.word	0xe000e010
     258:	20200000 	.word	0x20200000
     25c:	e000ed20 	.word	0xe000ed20
     260:	ffffffff 	.word	0xffffffff
     264:	ffffffff 	.word	0xffffffff
     268:	ffffffff 	.word	0xffffffff
     26c:	ffffffff 	.word	0xffffffff
     270:	ffffffff 	.word	0xffffffff
     274:	ffffffff 	.word	0xffffffff
     278:	ffffffff 	.word	0xffffffff
     27c:	ffffffff 	.word	0xffffffff
     280:	ffffffff 	.word	0xffffffff
     284:	ffffffff 	.word	0xffffffff
     288:	ffffffff 	.word	0xffffffff
     28c:	ffffffff 	.word	0xffffffff
     290:	ffffffff 	.word	0xffffffff
     294:	ffffffff 	.word	0xffffffff
     298:	ffffffff 	.word	0xffffffff
     29c:	ffffffff 	.word	0xffffffff
     2a0:	ffffffff 	.word	0xffffffff
     2a4:	ffffffff 	.word	0xffffffff
     2a8:	ffffffff 	.word	0xffffffff
     2ac:	ffffffff 	.word	0xffffffff
     2b0:	ffffffff 	.word	0xffffffff
     2b4:	ffffffff 	.word	0xffffffff
     2b8:	ffffffff 	.word	0xffffffff
     2bc:	ffffffff 	.word	0xffffffff
     2c0:	ffffffff 	.word	0xffffffff
     2c4:	ffffffff 	.word	0xffffffff
     2c8:	ffffffff 	.word	0xffffffff
     2cc:	ffffffff 	.word	0xffffffff
     2d0:	ffffffff 	.word	0xffffffff
     2d4:	ffffffff 	.word	0xffffffff
     2d8:	ffffffff 	.word	0xffffffff
     2dc:	ffffffff 	.word	0xffffffff
     2e0:	ffffffff 	.word	0xffffffff
     2e4:	ffffffff 	.word	0xffffffff
     2e8:	ffffffff 	.word	0xffffffff
     2ec:	ffffffff 	.word	0xffffffff
     2f0:	ffffffff 	.word	0xffffffff
     2f4:	ffffffff 	.word	0xffffffff
     2f8:	ffffffff 	.word	0xffffffff
     2fc:	ffffffff 	.word	0xffffffff
     300:	ffffffff 	.word	0xffffffff
     304:	ffffffff 	.word	0xffffffff
     308:	ffffffff 	.word	0xffffffff
     30c:	ffffffff 	.word	0xffffffff
     310:	ffffffff 	.word	0xffffffff
     314:	ffffffff 	.word	0xffffffff
     318:	ffffffff 	.word	0xffffffff
     31c:	ffffffff 	.word	0xffffffff
     320:	ffffffff 	.word	0xffffffff
     324:	ffffffff 	.word	0xffffffff
     328:	ffffffff 	.word	0xffffffff
     32c:	ffffffff 	.word	0xffffffff
     330:	ffffffff 	.word	0xffffffff
     334:	ffffffff 	.word	0xffffffff
     338:	ffffffff 	.word	0xffffffff
     33c:	ffffffff 	.word	0xffffffff
     340:	ffffffff 	.word	0xffffffff
     344:	ffffffff 	.word	0xffffffff
     348:	ffffffff 	.word	0xffffffff
     34c:	ffffffff 	.word	0xffffffff
     350:	ffffffff 	.word	0xffffffff
     354:	ffffffff 	.word	0xffffffff
     358:	ffffffff 	.word	0xffffffff
     35c:	ffffffff 	.word	0xffffffff
     360:	ffffffff 	.word	0xffffffff
     364:	ffffffff 	.word	0xffffffff
     368:	ffffffff 	.word	0xffffffff
     36c:	ffffffff 	.word	0xffffffff
     370:	ffffffff 	.word	0xffffffff
     374:	ffffffff 	.word	0xffffffff
     378:	ffffffff 	.word	0xffffffff
     37c:	ffffffff 	.word	0xffffffff
     380:	ffffffff 	.word	0xffffffff
     384:	ffffffff 	.word	0xffffffff
     388:	ffffffff 	.word	0xffffffff
     38c:	ffffffff 	.word	0xffffffff
     390:	ffffffff 	.word	0xffffffff
     394:	ffffffff 	.word	0xffffffff
     398:	ffffffff 	.word	0xffffffff
     39c:	ffffffff 	.word	0xffffffff
     3a0:	ffffffff 	.word	0xffffffff
     3a4:	ffffffff 	.word	0xffffffff
     3a8:	ffffffff 	.word	0xffffffff
     3ac:	ffffffff 	.word	0xffffffff
     3b0:	ffffffff 	.word	0xffffffff
     3b4:	ffffffff 	.word	0xffffffff
     3b8:	ffffffff 	.word	0xffffffff
     3bc:	ffffffff 	.word	0xffffffff
     3c0:	ffffffff 	.word	0xffffffff
     3c4:	ffffffff 	.word	0xffffffff
     3c8:	ffffffff 	.word	0xffffffff
     3cc:	ffffffff 	.word	0xffffffff
     3d0:	ffffffff 	.word	0xffffffff
     3d4:	ffffffff 	.word	0xffffffff
     3d8:	ffffffff 	.word	0xffffffff
     3dc:	ffffffff 	.word	0xffffffff
     3e0:	ffffffff 	.word	0xffffffff
     3e4:	ffffffff 	.word	0xffffffff
     3e8:	ffffffff 	.word	0xffffffff
     3ec:	ffffffff 	.word	0xffffffff
     3f0:	ffffffff 	.word	0xffffffff
     3f4:	ffffffff 	.word	0xffffffff
     3f8:	ffffffff 	.word	0xffffffff
     3fc:	ffffffff 	.word	0xffffffff

00000400 <flashconfigbytes>:
     400:	ffffffff ffffffff ffffffff fffff9de     ................

00000410 <__do_global_dtors_aux>:
     410:	b510      	push	{r4, lr}
     412:	4c06      	ldr	r4, [pc, #24]	; (42c <__do_global_dtors_aux+0x1c>)
     414:	7823      	ldrb	r3, [r4, #0]
     416:	2b00      	cmp	r3, #0
     418:	d107      	bne.n	42a <__do_global_dtors_aux+0x1a>
     41a:	4b05      	ldr	r3, [pc, #20]	; (430 <__do_global_dtors_aux+0x20>)
     41c:	2b00      	cmp	r3, #0
     41e:	d002      	beq.n	426 <__do_global_dtors_aux+0x16>
     420:	4804      	ldr	r0, [pc, #16]	; (434 <__do_global_dtors_aux+0x24>)
     422:	e000      	b.n	426 <__do_global_dtors_aux+0x16>
     424:	bf00      	nop
     426:	2301      	movs	r3, #1
     428:	7023      	strb	r3, [r4, #0]
     42a:	bd10      	pop	{r4, pc}
     42c:	2000068c 	.word	0x2000068c
     430:	00000000 	.word	0x00000000
     434:	0000346c 	.word	0x0000346c

00000438 <frame_dummy>:
     438:	4b08      	ldr	r3, [pc, #32]	; (45c <frame_dummy+0x24>)
     43a:	b510      	push	{r4, lr}
     43c:	2b00      	cmp	r3, #0
     43e:	d003      	beq.n	448 <frame_dummy+0x10>
     440:	4907      	ldr	r1, [pc, #28]	; (460 <frame_dummy+0x28>)
     442:	4808      	ldr	r0, [pc, #32]	; (464 <frame_dummy+0x2c>)
     444:	e000      	b.n	448 <frame_dummy+0x10>
     446:	bf00      	nop
     448:	4807      	ldr	r0, [pc, #28]	; (468 <frame_dummy+0x30>)
     44a:	6803      	ldr	r3, [r0, #0]
     44c:	2b00      	cmp	r3, #0
     44e:	d100      	bne.n	452 <frame_dummy+0x1a>
     450:	bd10      	pop	{r4, pc}
     452:	4b06      	ldr	r3, [pc, #24]	; (46c <frame_dummy+0x34>)
     454:	2b00      	cmp	r3, #0
     456:	d0fb      	beq.n	450 <frame_dummy+0x18>
     458:	4798      	blx	r3
     45a:	e7f9      	b.n	450 <frame_dummy+0x18>
     45c:	00000000 	.word	0x00000000
     460:	20000690 	.word	0x20000690
     464:	0000346c 	.word	0x0000346c
     468:	2000068c 	.word	0x2000068c
     46c:	00000000 	.word	0x00000000

00000470 <setup>:

int reading;
char i;

void setup()
{
     470:	b570      	push	{r4, r5, r6, lr}
  pinMode(LED_BUILTIN,OUTPUT);
     472:	2101      	movs	r1, #1
     474:	200d      	movs	r0, #13
     476:	f000 fdbf 	bl	ff8 <pinMode>
  Serial.begin(9600);
  Wire.begin();
     47a:	480a      	ldr	r0, [pc, #40]	; (4a4 <setup+0x34>)
     47c:	f000 f8f4 	bl	668 <TwoWire::begin()>
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     480:	2101      	movs	r1, #1
     482:	4a09      	ldr	r2, [pc, #36]	; (4a8 <setup+0x38>)
     484:	4809      	ldr	r0, [pc, #36]	; (4ac <setup+0x3c>)
     486:	4e0a      	ldr	r6, [pc, #40]	; (4b0 <setup+0x40>)
     488:	4d0a      	ldr	r5, [pc, #40]	; (4b4 <setup+0x44>)
     48a:	7813      	ldrb	r3, [r2, #0]
     48c:	2b00      	cmp	r3, #0
     48e:	d0fc      	beq.n	48a <setup+0x1a>
     490:	7803      	ldrb	r3, [r0, #0]
     492:	4219      	tst	r1, r3
     494:	d0f9      	beq.n	48a <setup+0x1a>
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     496:	6833      	ldr	r3, [r6, #0]
     498:	682c      	ldr	r4, [r5, #0]
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     49a:	1b1b      	subs	r3, r3, r4
     49c:	2b0e      	cmp	r3, #14
     49e:	d9f4      	bls.n	48a <setup+0x1a>
  while (!Serial);  

}
     4a0:	bd70      	pop	{r4, r5, r6, pc}
     4a2:	46c0      	nop			; (mov r8, r8)
     4a4:	1ffffd20 	.word	0x1ffffd20
     4a8:	20000798 	.word	0x20000798
     4ac:	200007a8 	.word	0x200007a8
     4b0:	200006b4 	.word	0x200006b4
     4b4:	20000990 	.word	0x20000990

000004b8 <loop>:

void loop()
{
     4b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     4ba:	465f      	mov	r7, fp
     4bc:	4656      	mov	r6, sl
     4be:	464d      	mov	r5, r9
     4c0:	4644      	mov	r4, r8
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
     4c2:	212e      	movs	r1, #46	; 0x2e
     4c4:	b4f0      	push	{r4, r5, r6, r7}
     4c6:	4835      	ldr	r0, [pc, #212]	; (59c <loop+0xe4>)
     4c8:	f001 fb3e 	bl	1b48 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     4cc:	4e34      	ldr	r6, [pc, #208]	; (5a0 <loop+0xe8>)
     4ce:	0030      	movs	r0, r6
     4d0:	f000 fbc4 	bl	c5c <Print::println()>
  Serial.println("Lendo os primeiros 15 registradores da câmera");
  
  for(i = 0 ; i < 15; i++){
     4d4:	2300      	movs	r3, #0
     4d6:	4d33      	ldr	r5, [pc, #204]	; (5a4 <loop+0xec>)
     4d8:	2100      	movs	r1, #0
     4da:	702b      	strb	r3, [r5, #0]
     4dc:	4b32      	ldr	r3, [pc, #200]	; (5a8 <loop+0xf0>)
     4de:	4c33      	ldr	r4, [pc, #204]	; (5ac <loop+0xf4>)
     4e0:	469b      	mov	fp, r3
     4e2:	4b33      	ldr	r3, [pc, #204]	; (5b0 <loop+0xf8>)
     4e4:	4f33      	ldr	r7, [pc, #204]	; (5b4 <loop+0xfc>)
     4e6:	469a      	mov	sl, r3
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
     4e8:	233b      	movs	r3, #59	; 0x3b
     4ea:	4699      	mov	r9, r3
		transmitting = 1;
     4ec:	2301      	movs	r3, #1
     4ee:	4698      	mov	r8, r3
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
     4f0:	464b      	mov	r3, r9
     4f2:	22ba      	movs	r2, #186	; 0xba
     4f4:	54e2      	strb	r2, [r4, r3]
		transmitting = 1;
     4f6:	4642      	mov	r2, r8
     4f8:	235e      	movs	r3, #94	; 0x5e

  Wire.beginTransmission(enderecoCamera);
  Wire.write(byte(i));
     4fa:	0020      	movs	r0, r4
     4fc:	54e2      	strb	r2, [r4, r3]
		txBufferLength = 1;
     4fe:	3b01      	subs	r3, #1
     500:	54e2      	strb	r2, [r4, r3]
     502:	f000 f89b 	bl	63c <TwoWire::write(unsigned char)>
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
     506:	2101      	movs	r1, #1
     508:	0020      	movs	r0, r4
     50a:	f000 f983 	bl	814 <TwoWire::endTransmission(unsigned char)>
	uint8_t requestFrom(int address, int quantity, int sendStop) {
		return requestFrom((uint8_t)address, (uint8_t)quantity,
			(uint8_t)(sendStop ? 1 : 0));
	}
	uint8_t requestFrom(int address, int quantity) {
		return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)1);
     50e:	2301      	movs	r3, #1
     510:	2202      	movs	r2, #2
     512:	215d      	movs	r1, #93	; 0x5d
     514:	0020      	movs	r0, r4
     516:	f000 fa11 	bl	93c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>
	}
	uint8_t requestFrom(uint8_t addr, uint8_t qty, uint32_t iaddr, uint8_t n, uint8_t stop);
	virtual size_t write(uint8_t data);
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
     51a:	2339      	movs	r3, #57	; 0x39
     51c:	5ce3      	ldrb	r3, [r4, r3]
     51e:	2038      	movs	r0, #56	; 0x38
     520:	469c      	mov	ip, r3
  Wire.endTransmission();

  Wire.requestFrom(enderecoCamera, 2);

  if (Wire.available() >= 2) { // if two bytes were received
     522:	4662      	mov	r2, ip
     524:	5c23      	ldrb	r3, [r4, r0]
     526:	1ad2      	subs	r2, r2, r3
     528:	2a01      	cmp	r2, #1
     52a:	dd10      	ble.n	54e <loop+0x96>
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
     52c:	459c      	cmp	ip, r3
     52e:	d931      	bls.n	594 <loop+0xdc>
		return rxBuffer[rxBufferIndex++];
     530:	1c59      	adds	r1, r3, #1
     532:	b2c9      	uxtb	r1, r1
     534:	5421      	strb	r1, [r4, r0]
     536:	18e2      	adds	r2, r4, r3
     538:	7e12      	ldrb	r2, [r2, #24]
     53a:	0212      	lsls	r2, r2, #8
    reading = Wire.read();     // receive high byte (overwrites previous reading)
    reading = reading << 8;    // shift high byte to be high 8 bits
     53c:	603a      	str	r2, [r7, #0]
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
     53e:	458c      	cmp	ip, r1
     540:	d928      	bls.n	594 <loop+0xdc>
		return rxBuffer[rxBufferIndex++];
     542:	3302      	adds	r3, #2
     544:	5423      	strb	r3, [r4, r0]
     546:	1861      	adds	r1, r4, r1
     548:	7e0b      	ldrb	r3, [r1, #24]
     54a:	431a      	orrs	r2, r3
    reading |= Wire.read();    // receive low byte as lower 8 bits
     54c:	603a      	str	r2, [r7, #0]
     54e:	210d      	movs	r1, #13
     550:	4658      	mov	r0, fp
     552:	f001 faf9 	bl	1b48 <usb_serial_write>
	inline size_t printNumber(unsigned long n, uint8_t base, uint8_t sign) __attribute__((always_inline)) {
		// when "base" is a constant (pretty much always), the
		// compiler optimizes this to a single function call.
		if (base == 0) return write((uint8_t)n);
		if (base == 10 || base < 2) return printNumberDec(n, sign);
		if (base == 16) return printNumberHex(n);
     556:	7829      	ldrb	r1, [r5, #0]
     558:	0030      	movs	r0, r6
     55a:	f000 fb91 	bl	c80 <Print::printNumberHex(unsigned long)>
     55e:	2109      	movs	r1, #9
     560:	4650      	mov	r0, sl
     562:	f001 faf1 	bl	1b48 <usb_serial_write>
     566:	6839      	ldr	r1, [r7, #0]
     568:	0030      	movs	r0, r6
     56a:	f000 fb89 	bl	c80 <Print::printNumberHex(unsigned long)>
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }

	size_t println(unsigned char n, int base)	{ return print(n, base) + println(); }
	size_t println(int n, int base)			{ return print(n, base) + println(); }
     56e:	0030      	movs	r0, r6
     570:	f000 fb74 	bl	c5c <Print::println()>

void loop()
{
  Serial.println("Lendo os primeiros 15 registradores da câmera");
  
  for(i = 0 ; i < 15; i++){
     574:	7829      	ldrb	r1, [r5, #0]
     576:	3101      	adds	r1, #1
     578:	b2c9      	uxtb	r1, r1
     57a:	7029      	strb	r1, [r5, #0]
     57c:	290e      	cmp	r1, #14
     57e:	d9b7      	bls.n	4f0 <loop+0x38>
  Serial.print(i, HEX);
  Serial.print("  Valor: ");
  Serial.println(reading, HEX);
  } 

  delay(500);
     580:	20fa      	movs	r0, #250	; 0xfa
     582:	0040      	lsls	r0, r0, #1
     584:	f000 fd7c 	bl	1080 <delay>

}
     588:	bc3c      	pop	{r2, r3, r4, r5}
     58a:	4690      	mov	r8, r2
     58c:	4699      	mov	r9, r3
     58e:	46a2      	mov	sl, r4
     590:	46ab      	mov	fp, r5
     592:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
     594:	2201      	movs	r2, #1
     596:	4252      	negs	r2, r2
     598:	e7d8      	b.n	54c <loop+0x94>
     59a:	46c0      	nop			; (mov r8, r8)
     59c:	000031f8 	.word	0x000031f8
     5a0:	1ffffd90 	.word	0x1ffffd90
     5a4:	200006a8 	.word	0x200006a8
     5a8:	00003228 	.word	0x00003228
     5ac:	1ffffd20 	.word	0x1ffffd20
     5b0:	00003238 	.word	0x00003238
     5b4:	200006ac 	.word	0x200006ac

000005b8 <Print::availableForWrite()>:
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
     5b8:	2000      	movs	r0, #0
     5ba:	4770      	bx	lr

000005bc <TwoWire::available()>:
	}
	uint8_t requestFrom(uint8_t addr, uint8_t qty, uint32_t iaddr, uint8_t n, uint8_t stop);
	virtual size_t write(uint8_t data);
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
     5bc:	2238      	movs	r2, #56	; 0x38
     5be:	2339      	movs	r3, #57	; 0x39
     5c0:	5cc3      	ldrb	r3, [r0, r3]
     5c2:	5c80      	ldrb	r0, [r0, r2]
     5c4:	1a18      	subs	r0, r3, r0
	}
     5c6:	4770      	bx	lr

000005c8 <TwoWire::read()>:
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
     5c8:	2238      	movs	r2, #56	; 0x38
     5ca:	2139      	movs	r1, #57	; 0x39
     5cc:	5c83      	ldrb	r3, [r0, r2]
     5ce:	5c41      	ldrb	r1, [r0, r1]
     5d0:	4299      	cmp	r1, r3
     5d2:	d904      	bls.n	5de <TwoWire::read()+0x16>
		return rxBuffer[rxBufferIndex++];
     5d4:	1c59      	adds	r1, r3, #1
     5d6:	5481      	strb	r1, [r0, r2]
     5d8:	18c3      	adds	r3, r0, r3
     5da:	7e18      	ldrb	r0, [r3, #24]
	}
     5dc:	4770      	bx	lr
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
     5de:	2001      	movs	r0, #1
     5e0:	4240      	negs	r0, r0
     5e2:	e7fb      	b.n	5dc <TwoWire::read()+0x14>

000005e4 <TwoWire::peek()>:
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
     5e4:	2338      	movs	r3, #56	; 0x38
     5e6:	2239      	movs	r2, #57	; 0x39
     5e8:	5cc3      	ldrb	r3, [r0, r3]
     5ea:	5c82      	ldrb	r2, [r0, r2]
     5ec:	429a      	cmp	r2, r3
     5ee:	d902      	bls.n	5f6 <TwoWire::peek()+0x12>
		return rxBuffer[rxBufferIndex];
     5f0:	18c3      	adds	r3, r0, r3
     5f2:	7e18      	ldrb	r0, [r3, #24]
	}
     5f4:	4770      	bx	lr
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
     5f6:	2001      	movs	r0, #1
     5f8:	4240      	negs	r0, r0
     5fa:	e7fb      	b.n	5f4 <TwoWire::peek()+0x10>

000005fc <TwoWire::flush()>:
		return rxBuffer[rxBufferIndex];
	}
	virtual void flush(void) {
	}
     5fc:	4770      	bx	lr
     5fe:	46c0      	nop			; (mov r8, r8)

00000600 <TwoWire::write(unsigned char const*, unsigned int)>:
	return 0;
}

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
	if (transmitting || slave_mode) {
     600:	235e      	movs	r3, #94	; 0x5e
	}
	return 0;
}

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
     602:	b570      	push	{r4, r5, r6, lr}
	if (transmitting || slave_mode) {
     604:	5ac3      	ldrh	r3, [r0, r3]
	}
	return 0;
}

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
     606:	0004      	movs	r4, r0
     608:	0015      	movs	r5, r2
		}
		memcpy(txBuffer + txBufferLength, data, quantity);
		txBufferLength += quantity;
		return quantity;
	}
	return 0;
     60a:	2000      	movs	r0, #0
	return 0;
}

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
	if (transmitting || slave_mode) {
     60c:	2b00      	cmp	r3, #0
     60e:	d010      	beq.n	632 <TwoWire::write(unsigned char const*, unsigned int)+0x32>
		size_t avail = BUFFER_LENGTH+1 - txBufferLength;
     610:	235d      	movs	r3, #93	; 0x5d
     612:	5ce0      	ldrb	r0, [r4, r3]
     614:	3b3c      	subs	r3, #60	; 0x3c
     616:	1a1b      	subs	r3, r3, r0
		if (quantity > avail) {
     618:	429a      	cmp	r2, r3
     61a:	d80b      	bhi.n	634 <TwoWire::write(unsigned char const*, unsigned int)+0x34>
			quantity = avail;
			setWriteError();
		}
		memcpy(txBuffer + txBufferLength, data, quantity);
     61c:	0023      	movs	r3, r4
     61e:	333b      	adds	r3, #59	; 0x3b
     620:	1818      	adds	r0, r3, r0
     622:	002a      	movs	r2, r5
     624:	f002 fbca 	bl	2dbc <memcpy>
		txBufferLength += quantity;
     628:	225d      	movs	r2, #93	; 0x5d
     62a:	0028      	movs	r0, r5
     62c:	5ca3      	ldrb	r3, [r4, r2]
     62e:	195b      	adds	r3, r3, r5
     630:	54a3      	strb	r3, [r4, r2]
		return quantity;
	}
	return 0;
}
     632:	bd70      	pop	{r4, r5, r6, pc}
	int getWriteError() { return write_error; }
	void clearWriteError() { setWriteError(0); }
	int printf(const char *format, ...);
	int printf(const __FlashStringHelper *format, ...);
  protected:
	void setWriteError(int err = 1) { write_error = err; }
     634:	2201      	movs	r2, #1
     636:	001d      	movs	r5, r3
     638:	7122      	strb	r2, [r4, #4]
     63a:	e7ef      	b.n	61c <TwoWire::write(unsigned char const*, unsigned int)+0x1c>

0000063c <TwoWire::write(unsigned char)>:
//  I2C0_C2      // I2C Control Register 2
//  I2C0_FLT     // I2C Programmable Input Glitch Filter register

size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
     63c:	225e      	movs	r2, #94	; 0x5e
//  I2C0_D       // I2C Data I/O register
//  I2C0_C2      // I2C Control Register 2
//  I2C0_FLT     // I2C Programmable Input Glitch Filter register

size_t TwoWire::write(uint8_t data)
{
     63e:	b510      	push	{r4, lr}
	if (transmitting || slave_mode) {
     640:	5a82      	ldrh	r2, [r0, r2]
//  I2C0_D       // I2C Data I/O register
//  I2C0_C2      // I2C Control Register 2
//  I2C0_FLT     // I2C Programmable Input Glitch Filter register

size_t TwoWire::write(uint8_t data)
{
     642:	0003      	movs	r3, r0
			return 0;
		}
		txBuffer[txBufferLength++] = data;
		return 1;
	}
	return 0;
     644:	2000      	movs	r0, #0
//  I2C0_C2      // I2C Control Register 2
//  I2C0_FLT     // I2C Programmable Input Glitch Filter register

size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
     646:	2a00      	cmp	r2, #0
     648:	d009      	beq.n	65e <TwoWire::write(unsigned char)+0x22>
		if (txBufferLength >= BUFFER_LENGTH+1) {
     64a:	245d      	movs	r4, #93	; 0x5d
     64c:	5d1a      	ldrb	r2, [r3, r4]
     64e:	2a20      	cmp	r2, #32
     650:	d806      	bhi.n	660 <TwoWire::write(unsigned char)+0x24>
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
     652:	1c50      	adds	r0, r2, #1
     654:	5518      	strb	r0, [r3, r4]
		return 1;
     656:	2001      	movs	r0, #1
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
     658:	189b      	adds	r3, r3, r2
     65a:	333b      	adds	r3, #59	; 0x3b
     65c:	7019      	strb	r1, [r3, #0]
		return 1;
	}
	return 0;
}
     65e:	bd10      	pop	{r4, pc}
     660:	2201      	movs	r2, #1
     662:	711a      	strb	r2, [r3, #4]
     664:	e7fb      	b.n	65e <TwoWire::write(unsigned char)+0x22>
     666:	46c0      	nop			; (mov r8, r8)

00000668 <TwoWire::begin()>:
void TwoWire::begin(void)
{
	//serial_begin(BAUD2DIV(115200));
	//serial_print("\nWire Begin\n");

	rxBufferIndex = 0;
     668:	2300      	movs	r3, #0
     66a:	2238      	movs	r2, #56	; 0x38
     66c:	5483      	strb	r3, [r0, r2]
	rxBufferLength = 0;
     66e:	3201      	adds	r2, #1
     670:	5483      	strb	r3, [r0, r2]
	txBufferIndex = 0;
     672:	3223      	adds	r2, #35	; 0x23
     674:	5483      	strb	r3, [r0, r2]
	txBufferLength = 0;
     676:	3201      	adds	r2, #1
     678:	5483      	strb	r3, [r0, r2]
	transmitting = 0;
     67a:	3201      	adds	r2, #1
     67c:	5483      	strb	r3, [r0, r2]
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
     67e:	3201      	adds	r2, #1
	rxBufferIndex = 0;
	rxBufferLength = 0;
	txBufferIndex = 0;
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
     680:	6643      	str	r3, [r0, #100]	; 0x64
	user_onReceive = NULL;
     682:	6683      	str	r3, [r0, #104]	; 0x68
	slave_mode = 0;
     684:	5483      	strb	r3, [r0, r2]

void sda_rising_isr0(void);
void sda_rising_isr1(void);

void TwoWire::begin(void)
{
     686:	b5f0      	push	{r4, r5, r6, r7, lr}
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
     688:	6944      	ldr	r4, [r0, #20]
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
     68a:	26e0      	movs	r6, #224	; 0xe0
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
     68c:	6821      	ldr	r1, [r4, #0]
     68e:	6862      	ldr	r2, [r4, #4]
     690:	680d      	ldr	r5, [r1, #0]
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
     692:	4c1b      	ldr	r4, [pc, #108]	; (700 <TwoWire::begin()+0x98>)
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
     694:	432a      	orrs	r2, r5
     696:	600a      	str	r2, [r1, #0]
	port().C1 = 0;
     698:	6902      	ldr	r2, [r0, #16]
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
     69a:	00f6      	lsls	r6, r6, #3
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
	port().C1 = 0;
     69c:	7093      	strb	r3, [r2, #2]
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
     69e:	3361      	adds	r3, #97	; 0x61
     6a0:	6941      	ldr	r1, [r0, #20]
     6a2:	5cc3      	ldrb	r3, [r0, r3]
     6a4:	18cb      	adds	r3, r1, r3
     6a6:	7a1a      	ldrb	r2, [r3, #8]
     6a8:	0055      	lsls	r5, r2, #1
     6aa:	18aa      	adds	r2, r5, r2
     6ac:	0092      	lsls	r2, r2, #2
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
     6ae:	2564      	movs	r5, #100	; 0x64
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
     6b0:	18a2      	adds	r2, r4, r2
     6b2:	6857      	ldr	r7, [r2, #4]
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
     6b4:	7b5a      	ldrb	r2, [r3, #13]
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
     6b6:	2362      	movs	r3, #98	; 0x62
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
     6b8:	0212      	lsls	r2, r2, #8
     6ba:	4032      	ands	r2, r6
     6bc:	432a      	orrs	r2, r5
     6be:	603a      	str	r2, [r7, #0]
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
     6c0:	5cc2      	ldrb	r2, [r0, r3]
     6c2:	188a      	adds	r2, r1, r2
     6c4:	7c93      	ldrb	r3, [r2, #18]
     6c6:	005f      	lsls	r7, r3, #1
     6c8:	18fb      	adds	r3, r7, r3
     6ca:	009b      	lsls	r3, r3, #2
     6cc:	18e3      	adds	r3, r4, r3
     6ce:	685c      	ldr	r4, [r3, #4]
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
     6d0:	7dd3      	ldrb	r3, [r2, #23]
     6d2:	021b      	lsls	r3, r3, #8
     6d4:	401e      	ands	r6, r3
     6d6:	4335      	orrs	r5, r6
	//pinMode(4, OUTPUT);
}

void TwoWire::setClock(uint32_t frequency)
{
	if (!(hardware.clock_gate_register & hardware.clock_gate_mask)) return;
     6d8:	680b      	ldr	r3, [r1, #0]
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
     6da:	6025      	str	r5, [r4, #0]
	//pinMode(4, OUTPUT);
}

void TwoWire::setClock(uint32_t frequency)
{
	if (!(hardware.clock_gate_register & hardware.clock_gate_mask)) return;
     6dc:	681b      	ldr	r3, [r3, #0]
     6de:	684a      	ldr	r2, [r1, #4]
     6e0:	421a      	tst	r2, r3
     6e2:	d005      	beq.n	6f0 <TwoWire::begin()+0x88>
		port().F = 0x0A; // 1 MHz
	}
	port().FLT = 3;
#elif F_BUS == 24000000
	if (frequency < 400000) {
		port().F = 0x1F; // 100 kHz
     6e4:	231f      	movs	r3, #31
     6e6:	6902      	ldr	r2, [r0, #16]
     6e8:	7053      	strb	r3, [r2, #1]
	} else if (frequency < 1000000) {
		port().F = 0x12; // 375 kHz
	} else {
		port().F = 0x02; // 1 MHz
	}
	port().FLT = 2;
     6ea:	6902      	ldr	r2, [r0, #16]
     6ec:	3b1d      	subs	r3, #29
     6ee:	7193      	strb	r3, [r2, #6]
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	setClock(100000);
	port().C2 = I2C_C2_HDRS;
     6f0:	2320      	movs	r3, #32
     6f2:	6902      	ldr	r2, [r0, #16]
     6f4:	7153      	strb	r3, [r2, #5]
	port().C1 = I2C_C1_IICEN;
     6f6:	2280      	movs	r2, #128	; 0x80
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
     6f8:	6903      	ldr	r3, [r0, #16]
     6fa:	709a      	strb	r2, [r3, #2]
	//pinMode(3, OUTPUT);
	//pinMode(4, OUTPUT);
}
     6fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
     6fe:	46c0      	nop			; (mov r8, r8)
     700:	0000328c 	.word	0x0000328c

00000704 <TwoWire::wait_idle()>:
	}
	return 0;
}

bool TwoWire::wait_idle(void)
{
     704:	b5f0      	push	{r4, r5, r6, r7, lr}
     706:	465f      	mov	r7, fp
     708:	4656      	mov	r6, sl
     70a:	464d      	mov	r5, r9
     70c:	4644      	mov	r4, r8
     70e:	b4f0      	push	{r4, r5, r6, r7}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     710:	4b3e      	ldr	r3, [pc, #248]	; (80c <L_1828_delayMicroseconds+0x20>)
     712:	b083      	sub	sp, #12
     714:	4698      	mov	r8, r3
     716:	681b      	ldr	r3, [r3, #0]
     718:	0007      	movs	r7, r0
     71a:	9300      	str	r3, [sp, #0]
	return ret;
     71c:	9b00      	ldr	r3, [sp, #0]
	bool reset=false;
     71e:	2100      	movs	r1, #0
     720:	469a      	mov	sl, r3
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
     722:	2320      	movs	r3, #32
     724:	4699      	mov	r9, r3
		uint32_t waited = millis() - wait_begin;
#if 1
		if (waited > 15 && !reset) {
			reset = true;
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
     726:	3341      	adds	r3, #65	; 0x41
     728:	469b      	mov	fp, r3
     72a:	6902      	ldr	r2, [r0, #16]
{
	bool reset=false;
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
     72c:	4648      	mov	r0, r9
	uint8_t i2c_status(void) {
		return port().S;
     72e:	78d3      	ldrb	r3, [r2, #3]
     730:	4218      	tst	r0, r3
     732:	d063      	beq.n	7fc <L_1828_delayMicroseconds+0x10>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     734:	4643      	mov	r3, r8
		//Serial.write('.') ;
		uint32_t waited = millis() - wait_begin;
     736:	4650      	mov	r0, sl
     738:	681b      	ldr	r3, [r3, #0]
     73a:	9301      	str	r3, [sp, #4]
	return ret;
     73c:	9b01      	ldr	r3, [sp, #4]
     73e:	1a1b      	subs	r3, r3, r0
#if 1
		if (waited > 15 && !reset) {
     740:	2b0f      	cmp	r3, #15
     742:	d9f3      	bls.n	72c <TwoWire::wait_idle()+0x28>
     744:	2900      	cmp	r1, #0
     746:	d008      	beq.n	75a <TwoWire::wait_idle()+0x56>
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			delayMicroseconds(10);
			continue;
		}
#endif
		if (waited > 16) {
     748:	2b10      	cmp	r3, #16
     74a:	d0ef      	beq.n	72c <TwoWire::wait_idle()+0x28>
			// bus stuck busy too long
			port().C1 = 0;
     74c:	2300      	movs	r3, #0
     74e:	7093      	strb	r3, [r2, #2]
			port().C1 = I2C_C1_IICEN;
     750:	2280      	movs	r2, #128	; 0x80
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
     752:	693b      	ldr	r3, [r7, #16]
			//Serial.println("abort");
			//return 4; // timeout waiting for bus
			return false;
     754:	2000      	movs	r0, #0
		}
#endif
		if (waited > 16) {
			// bus stuck busy too long
			port().C1 = 0;
			port().C1 = I2C_C1_IICEN;
     756:	709a      	strb	r2, [r3, #2]
			//Serial.println("abort");
			//return 4; // timeout waiting for bus
			return false;
     758:	e051      	b.n	7fe <L_1828_delayMicroseconds+0x12>
		uint32_t waited = millis() - wait_begin;
#if 1
		if (waited > 15 && !reset) {
			reset = true;
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
     75a:	697a      	ldr	r2, [r7, #20]
     75c:	465b      	mov	r3, fp
     75e:	4694      	mov	ip, r2
     760:	5cfb      	ldrb	r3, [r7, r3]
			pinMode(sda_pin, INPUT_DISABLE);
     762:	3105      	adds	r1, #5
		uint32_t waited = millis() - wait_begin;
#if 1
		if (waited > 15 && !reset) {
			reset = true;
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
     764:	4463      	add	r3, ip
			pinMode(sda_pin, INPUT_DISABLE);
     766:	7a18      	ldrb	r0, [r3, #8]
     768:	f000 fc46 	bl	ff8 <pinMode>
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
     76c:	697a      	ldr	r2, [r7, #20]
     76e:	465b      	mov	r3, fp
     770:	4694      	mov	ip, r2
     772:	5cfb      	ldrb	r3, [r7, r3]
			pinMode(scl_pin, OUTPUT);
     774:	2101      	movs	r1, #1
		if (waited > 15 && !reset) {
			reset = true;
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
			pinMode(sda_pin, INPUT_DISABLE);
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
     776:	4463      	add	r3, ip
     778:	7c9d      	ldrb	r5, [r3, #18]
			pinMode(scl_pin, OUTPUT);
     77a:	2409      	movs	r4, #9
     77c:	0028      	movs	r0, r5
     77e:	f000 fc3b 	bl	ff8 <pinMode>
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
     782:	2650      	movs	r6, #80	; 0x50
			for (int i=0; i < 9; i++) {
				digitalWrite(scl_pin, LOW);
     784:	2100      	movs	r1, #0
     786:	0028      	movs	r0, r5
     788:	f000 fc14 	bl	fb4 <digitalWrite>
     78c:	0033      	movs	r3, r6

0000078e <L_1758_delayMicroseconds>:
     78e:	3b01      	subs	r3, #1
     790:	d1fd      	bne.n	78e <L_1758_delayMicroseconds>
				delayMicroseconds(5);
				digitalWrite(scl_pin, HIGH);
     792:	2101      	movs	r1, #1
     794:	0028      	movs	r0, r5
     796:	f000 fc0d 	bl	fb4 <digitalWrite>
     79a:	0033      	movs	r3, r6

0000079c <L_1772_delayMicroseconds>:
     79c:	3b01      	subs	r3, #1
     79e:	d1fd      	bne.n	79c <L_1772_delayMicroseconds>
     7a0:	3c01      	subs	r4, #1
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
			pinMode(sda_pin, INPUT_DISABLE);
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
			pinMode(scl_pin, OUTPUT);
			for (int i=0; i < 9; i++) {
     7a2:	2c00      	cmp	r4, #0
     7a4:	d1ee      	bne.n	784 <TwoWire::wait_idle()+0x80>
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
     7a6:	465b      	mov	r3, fp
     7a8:	6978      	ldr	r0, [r7, #20]
     7aa:	5cfa      	ldrb	r2, [r7, r3]
     7ac:	1882      	adds	r2, r0, r2
     7ae:	7a13      	ldrb	r3, [r2, #8]
     7b0:	0059      	lsls	r1, r3, #1
     7b2:	18cb      	adds	r3, r1, r3
     7b4:	4916      	ldr	r1, [pc, #88]	; (810 <L_1828_delayMicroseconds+0x24>)
     7b6:	009b      	lsls	r3, r3, #2
     7b8:	468c      	mov	ip, r1
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
     7ba:	21e0      	movs	r1, #224	; 0xe0
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
     7bc:	4463      	add	r3, ip
     7be:	685c      	ldr	r4, [r3, #4]
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
     7c0:	7b53      	ldrb	r3, [r2, #13]
     7c2:	2264      	movs	r2, #100	; 0x64
     7c4:	00c9      	lsls	r1, r1, #3
     7c6:	021b      	lsls	r3, r3, #8
     7c8:	400b      	ands	r3, r1
     7ca:	4313      	orrs	r3, r2
     7cc:	6023      	str	r3, [r4, #0]
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
     7ce:	2362      	movs	r3, #98	; 0x62
     7d0:	5cfb      	ldrb	r3, [r7, r3]
     7d2:	18c0      	adds	r0, r0, r3
     7d4:	7c83      	ldrb	r3, [r0, #18]
     7d6:	005c      	lsls	r4, r3, #1
     7d8:	18e3      	adds	r3, r4, r3
     7da:	009b      	lsls	r3, r3, #2
     7dc:	4463      	add	r3, ip
     7de:	685c      	ldr	r4, [r3, #4]
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
     7e0:	7dc3      	ldrb	r3, [r0, #23]
     7e2:	021b      	lsls	r3, r3, #8
     7e4:	4019      	ands	r1, r3
     7e6:	430a      	orrs	r2, r1
     7e8:	6022      	str	r2, [r4, #0]
     7ea:	23a0      	movs	r3, #160	; 0xa0

000007ec <L_1828_delayMicroseconds>:
     7ec:	3b01      	subs	r3, #1
     7ee:	d1fd      	bne.n	7ec <L_1828_delayMicroseconds>
{
	bool reset=false;
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
     7f0:	4648      	mov	r0, r9
     7f2:	693a      	ldr	r2, [r7, #16]
		//Serial.write('.') ;
		uint32_t waited = millis() - wait_begin;
#if 1
		if (waited > 15 && !reset) {
			reset = true;
     7f4:	2101      	movs	r1, #1
	uint8_t i2c_status(void) {
		return port().S;
     7f6:	78d3      	ldrb	r3, [r2, #3]
{
	bool reset=false;
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
     7f8:	4218      	tst	r0, r3
     7fa:	d19b      	bne.n	734 <TwoWire::wait_idle()+0x30>
			//Serial.println("abort");
			//return 4; // timeout waiting for bus
			return false;
		}
	}
	return true;
     7fc:	2001      	movs	r0, #1
}
     7fe:	b003      	add	sp, #12
     800:	bc3c      	pop	{r2, r3, r4, r5}
     802:	4690      	mov	r8, r2
     804:	4699      	mov	r9, r3
     806:	46a2      	mov	sl, r4
     808:	46ab      	mov	fp, r5
     80a:	bdf0      	pop	{r4, r5, r6, r7, pc}
     80c:	200006b4 	.word	0x200006b4
     810:	0000328c 	.word	0x0000328c

00000814 <TwoWire::endTransmission(unsigned char)>:

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
     814:	b5f0      	push	{r4, r5, r6, r7, lr}
     816:	465f      	mov	r7, fp
     818:	464d      	mov	r5, r9
     81a:	4644      	mov	r4, r8
     81c:	4656      	mov	r6, sl
	uint8_t i, status, ret=0;
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
     81e:	2312      	movs	r3, #18
	}
	return true;
}

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
     820:	b4f0      	push	{r4, r5, r6, r7}
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
     822:	2420      	movs	r4, #32
{
	uint8_t i, status, ret=0;
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
     824:	6902      	ldr	r2, [r0, #16]
	}
	return true;
}

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
     826:	b085      	sub	sp, #20
	uint8_t i, status, ret=0;
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
     828:	70d3      	strb	r3, [r2, #3]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
     82a:	6902      	ldr	r2, [r0, #16]
	}
	return true;
}

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
     82c:	0005      	movs	r5, r0
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
     82e:	7893      	ldrb	r3, [r2, #2]
	}
	return true;
}

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
     830:	468b      	mov	fp, r1
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
     832:	401c      	ands	r4, r3
     834:	d065      	beq.n	902 <TwoWire::endTransmission(unsigned char)+0xee>
		// we are already the bus master, so send a repeated start
		//Serial.print("rstart:");
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
     836:	23b4      	movs	r3, #180	; 0xb4
     838:	7093      	strb	r3, [r2, #2]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     83a:	4a3f      	ldr	r2, [pc, #252]	; (938 <TwoWire::endTransmission(unsigned char)+0x124>)
     83c:	692f      	ldr	r7, [r5, #16]
     83e:	6813      	ldr	r3, [r2, #0]
	}
	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
     840:	2020      	movs	r0, #32
     842:	9300      	str	r3, [sp, #0]
	return ret;
     844:	9c00      	ldr	r4, [sp, #0]
     846:	e005      	b.n	854 <TwoWire::endTransmission(unsigned char)+0x40>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     848:	6811      	ldr	r1, [r2, #0]
     84a:	9101      	str	r1, [sp, #4]
	return ret;
     84c:	9901      	ldr	r1, [sp, #4]
		//Serial.write('*') ;
		if (millis() - wait_begin > 4) {
     84e:	1b09      	subs	r1, r1, r4
     850:	2904      	cmp	r1, #4
     852:	d844      	bhi.n	8de <TwoWire::endTransmission(unsigned char)+0xca>
	uint8_t i2c_status(void) {
		return port().S;
     854:	78fb      	ldrb	r3, [r7, #3]
	}
	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
     856:	4003      	ands	r3, r0
     858:	d0f6      	beq.n	848 <TwoWire::endTransmission(unsigned char)+0x34>
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
     85a:	235d      	movs	r3, #93	; 0x5d
     85c:	2100      	movs	r1, #0
     85e:	5ceb      	ldrb	r3, [r5, r3]
     860:	468c      	mov	ip, r1
     862:	2b00      	cmp	r3, #0
     864:	d033      	beq.n	8ce <TwoWire::endTransmission(unsigned char)+0xba>
			}
		}
		port().S = I2C_S_IICIF;
		//Serial.write('$');
		status = i2c_status();
		if ((status & I2C_S_ARBL)) {
     866:	2310      	movs	r3, #16
     868:	4698      	mov	r8, r3
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("endTransmission err5\n");
			ret = 4; // 4:other error
			break;
		}
		if (status & I2C_S_RXAK) {
     86a:	3b0f      	subs	r3, #15
     86c:	4699      	mov	r9, r3
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
     86e:	335c      	adds	r3, #92	; 0x5c
		port().D = txBuffer[i];
		//Serial.write('^');
		wait_begin = millis();
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
     870:	2002      	movs	r0, #2
			if (!(status & I2C_S_BUSY)) break;
     872:	2420      	movs	r4, #32
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
     874:	469a      	mov	sl, r3
		port().D = txBuffer[i];
     876:	4663      	mov	r3, ip
     878:	18eb      	adds	r3, r5, r3
     87a:	333b      	adds	r3, #59	; 0x3b
     87c:	781b      	ldrb	r3, [r3, #0]
     87e:	713b      	strb	r3, [r7, #4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     880:	6813      	ldr	r3, [r2, #0]
     882:	6929      	ldr	r1, [r5, #16]
     884:	9303      	str	r3, [sp, #12]
	return ret;
     886:	9f03      	ldr	r7, [sp, #12]
     888:	e007      	b.n	89a <TwoWire::endTransmission(unsigned char)+0x86>
		//Serial.write('^');
		wait_begin = millis();
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
			if (!(status & I2C_S_BUSY)) break;
     88a:	421c      	tst	r4, r3
     88c:	d00a      	beq.n	8a4 <TwoWire::endTransmission(unsigned char)+0x90>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     88e:	6813      	ldr	r3, [r2, #0]
     890:	9302      	str	r3, [sp, #8]
	return ret;
     892:	9b02      	ldr	r3, [sp, #8]
			if (millis() - wait_begin > 5) {
     894:	1bdb      	subs	r3, r3, r7
     896:	2b05      	cmp	r3, #5
     898:	d82d      	bhi.n	8f6 <TwoWire::endTransmission(unsigned char)+0xe2>
		port().D = txBuffer[i];
		//Serial.write('^');
		wait_begin = millis();
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
     89a:	0006      	movs	r6, r0
     89c:	78cb      	ldrb	r3, [r1, #3]
     89e:	b2db      	uxtb	r3, r3
     8a0:	401e      	ands	r6, r3
     8a2:	d0f2      	beq.n	88a <TwoWire::endTransmission(unsigned char)+0x76>
			}
		}
		port().S = I2C_S_IICIF;
		//Serial.write('$');
		status = i2c_status();
		if ((status & I2C_S_ARBL)) {
     8a4:	4646      	mov	r6, r8
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
			}
		}
		port().S = I2C_S_IICIF;
     8a6:	70c8      	strb	r0, [r1, #3]
     8a8:	6929      	ldr	r1, [r5, #16]
     8aa:	78cb      	ldrb	r3, [r1, #3]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
     8ac:	000f      	movs	r7, r1
	uint8_t i2c_status(void) {
		return port().S;
     8ae:	b2db      	uxtb	r3, r3
		//Serial.write('$');
		status = i2c_status();
		if ((status & I2C_S_ARBL)) {
     8b0:	421e      	tst	r6, r3
     8b2:	d132      	bne.n	91a <TwoWire::endTransmission(unsigned char)+0x106>
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("endTransmission err4\n");
			ret = 4; // 4:other error
			break;
		}
		if (!(status & I2C_S_BUSY)) {
     8b4:	421c      	tst	r4, r3
     8b6:	d030      	beq.n	91a <TwoWire::endTransmission(unsigned char)+0x106>
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("endTransmission err5\n");
			ret = 4; // 4:other error
			break;
		}
		if (status & I2C_S_RXAK) {
     8b8:	464e      	mov	r6, r9
     8ba:	421e      	tst	r6, r3
     8bc:	d135      	bne.n	92a <TwoWire::endTransmission(unsigned char)+0x116>
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
     8be:	4663      	mov	r3, ip
     8c0:	3301      	adds	r3, #1
     8c2:	b2db      	uxtb	r3, r3
     8c4:	469c      	mov	ip, r3
     8c6:	4653      	mov	r3, sl
     8c8:	5ceb      	ldrb	r3, [r5, r3]
     8ca:	4563      	cmp	r3, ip
     8cc:	d8d3      	bhi.n	876 <TwoWire::endTransmission(unsigned char)+0x62>
	return true;
}

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
	uint8_t i, status, ret=0;
     8ce:	2000      	movs	r0, #0
			}
			sendStop = 1;
			break;
		}
	}
	if (sendStop) {
     8d0:	465b      	mov	r3, fp
     8d2:	2b00      	cmp	r3, #0
     8d4:	d125      	bne.n	922 <TwoWire::endTransmission(unsigned char)+0x10e>
		// send the stop condition
		port().C1 = I2C_C1_IICEN;
		// TODO: do we wait for this somehow?
	}
	transmitting = 0;
     8d6:	2200      	movs	r2, #0
     8d8:	235e      	movs	r3, #94	; 0x5e
     8da:	54ea      	strb	r2, [r5, r3]
     8dc:	e004      	b.n	8e8 <TwoWire::endTransmission(unsigned char)+0xd4>
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		//Serial.write('*') ;
		if (millis() - wait_begin > 4) {
			port().C1 = 0;
			port().C1 = I2C_C1_IICEN;
     8de:	2280      	movs	r2, #128	; 0x80
			//Serial.println("abort2");
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
     8e0:	2004      	movs	r0, #4
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		//Serial.write('*') ;
		if (millis() - wait_begin > 4) {
			port().C1 = 0;
     8e2:	70bb      	strb	r3, [r7, #2]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
     8e4:	692b      	ldr	r3, [r5, #16]
			port().C1 = I2C_C1_IICEN;
     8e6:	709a      	strb	r2, [r3, #2]
	}
	transmitting = 0;
	//Serial.print(" ret=");
	//Serial.println(ret);
	return ret;
}
     8e8:	b005      	add	sp, #20
     8ea:	bc3c      	pop	{r2, r3, r4, r5}
     8ec:	4690      	mov	r8, r2
     8ee:	4699      	mov	r9, r3
     8f0:	46a2      	mov	sl, r4
     8f2:	46ab      	mov	fp, r5
     8f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
			if (!(status & I2C_S_BUSY)) break;
			if (millis() - wait_begin > 5) {
				port().C1 = 0;
				port().C1 = I2C_C1_IICEN;
     8f6:	2280      	movs	r2, #128	; 0x80
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
			if (!(status & I2C_S_BUSY)) break;
			if (millis() - wait_begin > 5) {
				port().C1 = 0;
     8f8:	708e      	strb	r6, [r1, #2]
     8fa:	692b      	ldr	r3, [r5, #16]
				port().C1 = I2C_C1_IICEN;
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
     8fc:	2004      	movs	r0, #4
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
			if (!(status & I2C_S_BUSY)) break;
			if (millis() - wait_begin > 5) {
				port().C1 = 0;
				port().C1 = I2C_C1_IICEN;
     8fe:	709a      	strb	r2, [r3, #2]
     900:	e7f2      	b.n	8e8 <TwoWire::endTransmission(unsigned char)+0xd4>
		// we are already the bus master, so send a repeated start
		//Serial.print("rstart:");
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
     902:	f7ff feff 	bl	704 <TwoWire::wait_idle()>
     906:	0003      	movs	r3, r0
			//Serial.printf("endTransmission err1\n");
			return 4; // timeout waiting for bus
     908:	2004      	movs	r0, #4
		// we are already the bus master, so send a repeated start
		//Serial.print("rstart:");
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
     90a:	2b00      	cmp	r3, #0
     90c:	d0ec      	beq.n	8e8 <TwoWire::endTransmission(unsigned char)+0xd4>
			//Serial.printf("endTransmission err1\n");
			return 4; // timeout waiting for bus
		}
		// become the bus master in transmit mode (send start)
		slave_mode = 0;
     90e:	235f      	movs	r3, #95	; 0x5f
     910:	54ec      	strb	r4, [r5, r3]
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
     912:	692a      	ldr	r2, [r5, #16]
     914:	3351      	adds	r3, #81	; 0x51
     916:	7093      	strb	r3, [r2, #2]
     918:	e78f      	b.n	83a <TwoWire::endTransmission(unsigned char)+0x26>
			ret = 4; // 4:other error
			break;
		}
		if (!(status & I2C_S_BUSY)) {
			// suddenly lost control of the bus!
			port().C1 = I2C_C1_IICEN;
     91a:	2380      	movs	r3, #128	; 0x80
			//Serial.printf("endTransmission err5\n");
			ret = 4; // 4:other error
     91c:	2004      	movs	r0, #4
			ret = 4; // 4:other error
			break;
		}
		if (!(status & I2C_S_BUSY)) {
			// suddenly lost control of the bus!
			port().C1 = I2C_C1_IICEN;
     91e:	708b      	strb	r3, [r1, #2]
     920:	e7d6      	b.n	8d0 <TwoWire::endTransmission(unsigned char)+0xbc>
     922:	6929      	ldr	r1, [r5, #16]
			break;
		}
	}
	if (sendStop) {
		// send the stop condition
		port().C1 = I2C_C1_IICEN;
     924:	2380      	movs	r3, #128	; 0x80
     926:	708b      	strb	r3, [r1, #2]
     928:	e7d5      	b.n	8d6 <TwoWire::endTransmission(unsigned char)+0xc2>
			if (i == 0) {
				//Serial.printf("endTransmission err6\n");
				ret = 2; // 2:received NACK on transmit of address
			} else {
				//Serial.printf("endTransmission err7\n");
				ret = 3; // 3:received NACK on transmit of data 
     92a:	4663      	mov	r3, ip
     92c:	2003      	movs	r0, #3
     92e:	425a      	negs	r2, r3
     930:	4153      	adcs	r3, r2
     932:	1ac0      	subs	r0, r0, r3
     934:	e7f6      	b.n	924 <TwoWire::endTransmission(unsigned char)+0x110>
     936:	46c0      	nop			; (mov r8, r8)
     938:	200006b4 	.word	0x200006b4

0000093c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>:
	return ret;
}


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
     93c:	b5f0      	push	{r4, r5, r6, r7, lr}
     93e:	465f      	mov	r7, fp
     940:	4656      	mov	r6, sl
     942:	4644      	mov	r4, r8
     944:	464d      	mov	r5, r9
     946:	b4f0      	push	{r4, r5, r6, r7}
     948:	b08b      	sub	sp, #44	; 0x2c
     94a:	9200      	str	r2, [sp, #0]
     94c:	9301      	str	r3, [sp, #4]
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
	uint32_t wait_begin;

	rxBufferIndex = 0;
     94e:	2238      	movs	r2, #56	; 0x38
     950:	2300      	movs	r3, #0
     952:	2620      	movs	r6, #32
     954:	5483      	strb	r3, [r0, r2]
	rxBufferLength = 0;
     956:	3201      	adds	r2, #1
     958:	5483      	strb	r3, [r0, r2]
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
     95a:	6902      	ldr	r2, [r0, #16]
     95c:	3312      	adds	r3, #18
     95e:	70d3      	strb	r3, [r2, #3]
     960:	6903      	ldr	r3, [r0, #16]
	return ret;
}


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
     962:	0004      	movs	r4, r0
	rxBufferLength = 0;
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
     964:	789a      	ldrb	r2, [r3, #2]
	return ret;
}


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
     966:	000f      	movs	r7, r1
     968:	4016      	ands	r6, r2
	rxBufferLength = 0;
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
     96a:	d042      	beq.n	9f2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xb6>
		// we are already the bus master, so send a repeated start
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
     96c:	22b4      	movs	r2, #180	; 0xb4
     96e:	709a      	strb	r2, [r3, #2]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     970:	4b71      	ldr	r3, [pc, #452]	; (b38 <L_3363_delayMicroseconds+0x1e>)
     972:	6921      	ldr	r1, [r4, #16]
     974:	681a      	ldr	r2, [r3, #0]
     976:	2020      	movs	r0, #32
     978:	9202      	str	r2, [sp, #8]
	return ret;
     97a:	9d02      	ldr	r5, [sp, #8]
     97c:	e005      	b.n	98a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x4e>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     97e:	681a      	ldr	r2, [r3, #0]
     980:	9203      	str	r2, [sp, #12]
	return ret;
     982:	9a03      	ldr	r2, [sp, #12]
	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		if (millis() - wait_begin > 4) {
     984:	1b52      	subs	r2, r2, r5
     986:	2a04      	cmp	r2, #4
     988:	d827      	bhi.n	9da <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x9e>
	uint8_t i2c_status(void) {
		return port().S;
     98a:	78ce      	ldrb	r6, [r1, #3]
     98c:	4006      	ands	r6, r0

	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
     98e:	d0f6      	beq.n	97e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x42>
			//Serial.printf("requestFrom err2\n");
			return 0; // error generating start condition
		}
	}
	// send the address
	port().D = (address << 1) | 1;
     990:	2201      	movs	r2, #1
     992:	0078      	lsls	r0, r7, #1
     994:	4302      	orrs	r2, r0
     996:	b2d2      	uxtb	r2, r2
     998:	710a      	strb	r2, [r1, #4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     99a:	681a      	ldr	r2, [r3, #0]
     99c:	6921      	ldr	r1, [r4, #16]
     99e:	9204      	str	r2, [sp, #16]
	return ret;
     9a0:	9f04      	ldr	r7, [sp, #16]
     9a2:	2002      	movs	r0, #2
     9a4:	e005      	b.n	9b2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x76>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     9a6:	681a      	ldr	r2, [r3, #0]
     9a8:	9205      	str	r2, [sp, #20]
	return ret;
     9aa:	9a05      	ldr	r2, [sp, #20]
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
     9ac:	1bd2      	subs	r2, r2, r7
     9ae:	2a05      	cmp	r2, #5
     9b0:	d813      	bhi.n	9da <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x9e>
		}
	}
	// send the address
	port().D = (address << 1) | 1;
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
     9b2:	78ce      	ldrb	r6, [r1, #3]
     9b4:	4006      	ands	r6, r0
     9b6:	d0f6      	beq.n	9a6 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x6a>
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("requestFrom err3\n");
			return 0; // clock stretch too long (during address)
		}
	}
	port().S = I2C_S_IICIF;
     9b8:	2202      	movs	r2, #2
     9ba:	2611      	movs	r6, #17
     9bc:	70ca      	strb	r2, [r1, #3]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
     9be:	6922      	ldr	r2, [r4, #16]
	uint8_t i2c_status(void) {
		return port().S;
     9c0:	78d1      	ldrb	r1, [r2, #3]
     9c2:	400e      	ands	r6, r1
	status = i2c_status();
	if ((status & I2C_S_RXAK) || (status & I2C_S_ARBL)) {
     9c4:	d11f      	bne.n	a06 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xca>
		// or we lost bus arbitration to another master
		port().C1 = I2C_C1_IICEN;
		//Serial.printf("requestFrom err4\n");
		return 0;
	}
	if (length == 0) {
     9c6:	9900      	ldr	r1, [sp, #0]
     9c8:	2900      	cmp	r1, #0
     9ca:	d120      	bne.n	a0e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xd2>
		// TODO: does anybody really do zero length reads?
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
     9cc:	9901      	ldr	r1, [sp, #4]
     9ce:	23a0      	movs	r3, #160	; 0xa0
     9d0:	2900      	cmp	r1, #0
     9d2:	d000      	beq.n	9d6 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x9a>
     9d4:	e08e      	b.n	af4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1b8>
     9d6:	7093      	strb	r3, [r2, #2]
		//Serial.printf("requestFrom err5\n");
		return 0;
     9d8:	e003      	b.n	9e2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xa6>
	port().D = (address << 1) | 1;
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
			port().C1 = I2C_C1_IICEN;
     9da:	2280      	movs	r2, #128	; 0x80
	// send the address
	port().D = (address << 1) | 1;
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
     9dc:	708e      	strb	r6, [r1, #2]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
     9de:	6923      	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
     9e0:	709a      	strb	r2, [r3, #2]
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
	rxBufferLength = count;
	return count;
}
     9e2:	0030      	movs	r0, r6
     9e4:	b00b      	add	sp, #44	; 0x2c
     9e6:	bc3c      	pop	{r2, r3, r4, r5}
     9e8:	4690      	mov	r8, r2
     9ea:	4699      	mov	r9, r3
     9ec:	46a2      	mov	sl, r4
     9ee:	46ab      	mov	fp, r5
     9f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (port().C1 & I2C_C1_MST) {
		// we are already the bus master, so send a repeated start
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
     9f2:	f7ff fe87 	bl	704 <TwoWire::wait_idle()>
     9f6:	2800      	cmp	r0, #0
     9f8:	d0f3      	beq.n	9e2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xa6>
			//Serial.printf("requestFrom err1\n");
			return 0; // timeout waiting for bus
		}
		// become the bus master in transmit mode (send start)
		slave_mode = 0;
     9fa:	235f      	movs	r3, #95	; 0x5f
     9fc:	54e6      	strb	r6, [r4, r3]
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
     9fe:	6922      	ldr	r2, [r4, #16]
     a00:	3351      	adds	r3, #81	; 0x51
     a02:	7093      	strb	r3, [r2, #2]
     a04:	e7b4      	b.n	970 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x34>
	port().S = I2C_S_IICIF;
	status = i2c_status();
	if ((status & I2C_S_RXAK) || (status & I2C_S_ARBL)) {
		// the slave device did not acknowledge
		// or we lost bus arbitration to another master
		port().C1 = I2C_C1_IICEN;
     a06:	2380      	movs	r3, #128	; 0x80
		//Serial.printf("requestFrom err4\n");
		return 0;
     a08:	2600      	movs	r6, #0
	port().S = I2C_S_IICIF;
	status = i2c_status();
	if ((status & I2C_S_RXAK) || (status & I2C_S_ARBL)) {
		// the slave device did not acknowledge
		// or we lost bus arbitration to another master
		port().C1 = I2C_C1_IICEN;
     a0a:	7093      	strb	r3, [r2, #2]
		//Serial.printf("requestFrom err4\n");
		return 0;
     a0c:	e7e9      	b.n	9e2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xa6>
		// TODO: does anybody really do zero length reads?
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
		//Serial.printf("requestFrom err5\n");
		return 0;
	} else if (length == 1) {
     a0e:	2901      	cmp	r1, #1
     a10:	d078      	beq.n	b04 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1c8>
     a12:	000e      	movs	r6, r1
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
     a14:	21a0      	movs	r1, #160	; 0xa0
     a16:	7091      	strb	r1, [r2, #2]
     a18:	6920      	ldr	r0, [r4, #16]
	}
	tmp = port().D; // initiate the first receive
     a1a:	7902      	ldrb	r2, [r0, #4]
     a1c:	2200      	movs	r2, #0
     a1e:	4690      	mov	r8, r2
	//delayMicroseconds(250);
	while (length > 1) {
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
     a20:	3202      	adds	r2, #2
     a22:	4694      	mov	ip, r2
     a24:	4693      	mov	fp, r2
				return count; // clock stretch too long (during data)
			}
		}
		port().S = I2C_S_IICIF;
		status = port().S;
		if ((status & I2C_S_ARBL)) {
     a26:	320e      	adds	r2, #14
     a28:	4692      	mov	sl, r2
			// or suddenly lost control of the bus!
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7a\n");
			return count;
		}
		if (!(status & I2C_S_BUSY)) {
     a2a:	3210      	adds	r2, #16
     a2c:	4691      	mov	r9, r2
     a2e:	4647      	mov	r7, r8
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     a30:	681a      	ldr	r2, [r3, #0]
     a32:	9206      	str	r2, [sp, #24]
	return ret;
     a34:	9d06      	ldr	r5, [sp, #24]
     a36:	e005      	b.n	a44 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x108>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     a38:	6819      	ldr	r1, [r3, #0]
     a3a:	9107      	str	r1, [sp, #28]
	return ret;
     a3c:	9907      	ldr	r1, [sp, #28]
	tmp = port().D; // initiate the first receive
	//delayMicroseconds(250);
	while (length > 1) {
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
			if (millis() - wait_begin > 5) {
     a3e:	1b49      	subs	r1, r1, r5
     a40:	2905      	cmp	r1, #5
     a42:	d847      	bhi.n	ad4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x198>
	}
	tmp = port().D; // initiate the first receive
	//delayMicroseconds(250);
	while (length > 1) {
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
     a44:	4661      	mov	r1, ip
     a46:	78c2      	ldrb	r2, [r0, #3]
     a48:	400a      	ands	r2, r1
     a4a:	d0f5      	beq.n	a38 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xfc>
				rxBufferLength = count;
				//Serial.printf("requestFrom err6\n");
				return count; // clock stretch too long (during data)
			}
		}
		port().S = I2C_S_IICIF;
     a4c:	465a      	mov	r2, fp
		status = port().S;
		if ((status & I2C_S_ARBL)) {
     a4e:	4655      	mov	r5, sl
				rxBufferLength = count;
				//Serial.printf("requestFrom err6\n");
				return count; // clock stretch too long (during data)
			}
		}
		port().S = I2C_S_IICIF;
     a50:	70c2      	strb	r2, [r0, #3]
     a52:	6920      	ldr	r0, [r4, #16]
		status = port().S;
     a54:	78c1      	ldrb	r1, [r0, #3]
     a56:	0002      	movs	r2, r0
     a58:	b2c9      	uxtb	r1, r1
		if ((status & I2C_S_ARBL)) {
     a5a:	420d      	tst	r5, r1
     a5c:	d159      	bne.n	b12 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1d6>
			// or suddenly lost control of the bus!
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7a\n");
			return count;
		}
		if (!(status & I2C_S_BUSY)) {
     a5e:	464d      	mov	r5, r9
     a60:	420d      	tst	r5, r1
     a62:	d056      	beq.n	b12 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1d6>
			// or suddenly lost control of the bus!
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
     a64:	3e01      	subs	r6, #1
     a66:	b2f6      	uxtb	r6, r6
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
     a68:	2e01      	cmp	r6, #1
     a6a:	d046      	beq.n	afa <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1be>
		if (count < BUFFER_LENGTH) {
     a6c:	2f1f      	cmp	r7, #31
     a6e:	d93b      	bls.n	ae8 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1ac>
			rxBuffer[count++] = port().D;
		} else {
			tmp = port().D;
     a70:	7901      	ldrb	r1, [r0, #4]
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
	}
	tmp = port().D; // initiate the first receive
	//delayMicroseconds(250);
	while (length > 1) {
     a72:	2e01      	cmp	r6, #1
     a74:	d1dc      	bne.n	a30 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xf4>
     a76:	46b8      	mov	r8, r7
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     a78:	6819      	ldr	r1, [r3, #0]
		} else {
			tmp = port().D;
		}
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
     a7a:	2502      	movs	r5, #2
     a7c:	9108      	str	r1, [sp, #32]
	return ret;
     a7e:	9e08      	ldr	r6, [sp, #32]
     a80:	e005      	b.n	a8e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x152>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     a82:	6818      	ldr	r0, [r3, #0]
     a84:	9009      	str	r0, [sp, #36]	; 0x24
	return ret;
     a86:	9809      	ldr	r0, [sp, #36]	; 0x24
		if (millis() - wait_begin > 5) {
     a88:	1b80      	subs	r0, r0, r6
     a8a:	2805      	cmp	r0, #5
     a8c:	d84e      	bhi.n	b2c <L_3363_delayMicroseconds+0x12>
		} else {
			tmp = port().D;
		}
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
     a8e:	78d1      	ldrb	r1, [r2, #3]
     a90:	4029      	ands	r1, r5
     a92:	d0f6      	beq.n	a82 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x146>
			rxBufferLength = count;
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
		}
	}
	port().S = I2C_S_IICIF;
     a94:	2302      	movs	r3, #2
	status = port().S;
	if ((status & I2C_S_ARBL)) {
     a96:	2110      	movs	r1, #16
			rxBufferLength = count;
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
		}
	}
	port().S = I2C_S_IICIF;
     a98:	70d3      	strb	r3, [r2, #3]
     a9a:	6922      	ldr	r2, [r4, #16]
	status = port().S;
     a9c:	78d3      	ldrb	r3, [r2, #3]
     a9e:	b2db      	uxtb	r3, r3
	if ((status & I2C_S_ARBL)) {
     aa0:	4219      	tst	r1, r3
     aa2:	d138      	bne.n	b16 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1da>
     aa4:	4646      	mov	r6, r8
		delayMicroseconds(5);
		port().C1 &= ~I2C_C1_TXAK;
		//Serial.printf("requestFrom err9a\n");
		return count;
	}
	if (!(status & I2C_S_BUSY)) {
     aa6:	069b      	lsls	r3, r3, #26
     aa8:	d59b      	bpl.n	9e2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xa6>
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//Serial.printf("requestFrom err9b\n");
		return count;
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
     aaa:	23b0      	movs	r3, #176	; 0xb0
     aac:	7093      	strb	r3, [r2, #2]
	if (count < BUFFER_LENGTH) {
     aae:	2e1f      	cmp	r6, #31
     ab0:	d83e      	bhi.n	b30 <L_3363_delayMicroseconds+0x16>
		rxBuffer[count++] = port().D;
     ab2:	1c72      	adds	r2, r6, #1
     ab4:	b2d2      	uxtb	r2, r2
     ab6:	4690      	mov	r8, r2
     ab8:	6923      	ldr	r3, [r4, #16]
     aba:	19a1      	adds	r1, r4, r6
     abc:	7918      	ldrb	r0, [r3, #4]
     abe:	7608      	strb	r0, [r1, #24]
#if F_CPU > 120000000
	__asm__("nop");
	__asm__("nop");
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
     ac0:	9a01      	ldr	r2, [sp, #4]
     ac2:	2a00      	cmp	r2, #0
     ac4:	d001      	beq.n	aca <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x18e>
     ac6:	2280      	movs	r2, #128	; 0x80
     ac8:	709a      	strb	r2, [r3, #2]
	rxBufferLength = count;
     aca:	2339      	movs	r3, #57	; 0x39
     acc:	4642      	mov	r2, r8
	return count;
     ace:	4646      	mov	r6, r8
	__asm__("nop");
	__asm__("nop");
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
	rxBufferLength = count;
     ad0:	54e2      	strb	r2, [r4, r3]
	return count;
     ad2:	e786      	b.n	9e2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xa6>
     ad4:	46b8      	mov	r8, r7
	//delayMicroseconds(250);
	while (length > 1) {
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
			if (millis() - wait_begin > 5) {
				port().C1 = 0;
     ad6:	7082      	strb	r2, [r0, #2]
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
			port().C1 = I2C_C1_IICEN;
     ad8:	2380      	movs	r3, #128	; 0x80
     ada:	6922      	ldr	r2, [r4, #16]
			rxBufferLength = count;
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
     adc:	4646      	mov	r6, r8
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
			port().C1 = I2C_C1_IICEN;
     ade:	7093      	strb	r3, [r2, #2]
			rxBufferLength = count;
     ae0:	4642      	mov	r2, r8
     ae2:	3b47      	subs	r3, #71	; 0x47
     ae4:	54e2      	strb	r2, [r4, r3]
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
     ae6:	e77c      	b.n	9e2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xa6>
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
		if (count < BUFFER_LENGTH) {
			rxBuffer[count++] = port().D;
     ae8:	7905      	ldrb	r5, [r0, #4]
     aea:	1c79      	adds	r1, r7, #1
     aec:	19e7      	adds	r7, r4, r7
     aee:	763d      	strb	r5, [r7, #24]
     af0:	b2cf      	uxtb	r7, r1
     af2:	e7be      	b.n	a72 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x136>
		return 0;
	}
	if (length == 0) {
		// TODO: does anybody really do zero length reads?
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
     af4:	3b20      	subs	r3, #32
     af6:	7093      	strb	r3, [r2, #2]
     af8:	e773      	b.n	9e2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xa6>
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
     afa:	22a8      	movs	r2, #168	; 0xa8
     afc:	7082      	strb	r2, [r0, #2]
     afe:	6920      	ldr	r0, [r4, #16]
     b00:	0002      	movs	r2, r0
     b02:	e7b3      	b.n	a6c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x130>
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
		//Serial.printf("requestFrom err5\n");
		return 0;
	} else if (length == 1) {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
     b04:	31a7      	adds	r1, #167	; 0xa7
     b06:	7091      	strb	r1, [r2, #2]
     b08:	6922      	ldr	r2, [r4, #16]
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
	}
	tmp = port().D; // initiate the first receive
     b0a:	7911      	ldrb	r1, [r2, #4]


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
     b0c:	2100      	movs	r1, #0
     b0e:	4688      	mov	r8, r1
     b10:	e7b2      	b.n	a78 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x13c>
     b12:	003e      	movs	r6, r7
     b14:	e765      	b.n	9e2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xa6>
	if ((status & I2C_S_ARBL)) {
		// we lost bus arbitration to another master
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//digitalWriteFast(13, HIGH);
		port().S = I2C_S_ARBL;
     b16:	70d1      	strb	r1, [r2, #3]
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
     b18:	2350      	movs	r3, #80	; 0x50

00000b1a <L_3363_delayMicroseconds>:
     b1a:	3b01      	subs	r3, #1
     b1c:	d1fd      	bne.n	b1a <L_3363_delayMicroseconds>
     b1e:	6922      	ldr	r2, [r4, #16]
		delayMicroseconds(5);
		port().C1 &= ~I2C_C1_TXAK;
     b20:	3908      	subs	r1, #8
     b22:	7893      	ldrb	r3, [r2, #2]
		//Serial.printf("requestFrom err9a\n");
		return count;
     b24:	4646      	mov	r6, r8
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//digitalWriteFast(13, HIGH);
		port().S = I2C_S_ARBL;
		delayMicroseconds(5);
		port().C1 &= ~I2C_C1_TXAK;
     b26:	438b      	bics	r3, r1
     b28:	7093      	strb	r3, [r2, #2]
		//Serial.printf("requestFrom err9a\n");
		return count;
     b2a:	e75a      	b.n	9e2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xa6>
		}
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
     b2c:	7091      	strb	r1, [r2, #2]
     b2e:	e7d3      	b.n	ad8 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x19c>
     b30:	6923      	ldr	r3, [r4, #16]
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
	if (count < BUFFER_LENGTH) {
		rxBuffer[count++] = port().D;
	} else {
		tmp = port().D;
     b32:	791a      	ldrb	r2, [r3, #4]
     b34:	e7c4      	b.n	ac0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x184>
     b36:	46c0      	nop			; (mov r8, r8)
     b38:	200006b4 	.word	0x200006b4

00000b3c <i2c0_isr>:
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
	//serial_print(".");
	if (status & I2C_S_ARBL) {
     b3c:	2210      	movs	r2, #16
#define MAKE_CONST(x) (__builtin_constant_p(x) ? (x) : (x))

#ifdef WIRE_IMPLEMENT_WIRE
constexpr uintptr_t i2c0_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C0));
TwoWire Wire(i2c0_addr, TwoWire::i2c0_hardware);
void i2c0_isr(void) { Wire.isr(); }
     b3e:	b570      	push	{r4, r5, r6, lr}
     b40:	4d44      	ldr	r5, [pc, #272]	; (c54 <i2c0_isr+0x118>)
     b42:	692b      	ldr	r3, [r5, #16]
void TwoWire::isr(void)
{
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
     b44:	78dc      	ldrb	r4, [r3, #3]
     b46:	b2e4      	uxtb	r4, r4
	//serial_print(".");
	if (status & I2C_S_ARBL) {
     b48:	4222      	tst	r2, r4
     b4a:	d01f      	beq.n	b8c <i2c0_isr+0x50>
		// Arbitration Lost
		port().S = I2C_S_ARBL;
     b4c:	70da      	strb	r2, [r3, #3]
		if (receiving && rxBufferLength > 0) {
			// TODO: does this detect the STOP condition in slave receive mode?


		}
		if (!(status & I2C_S_IAAS)) return;
     b4e:	0663      	lsls	r3, r4, #25
     b50:	d51b      	bpl.n	b8a <i2c0_isr+0x4e>
	}
	if (status & I2C_S_IAAS) {
		//serial_print("\n");
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
     b52:	2304      	movs	r3, #4
     b54:	401c      	ands	r4, r3
     b56:	d052      	beq.n	bfe <i2c0_isr+0xc2>
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
     b58:	2300      	movs	r3, #0
			txBufferLength = 0;
     b5a:	245d      	movs	r4, #93	; 0x5d
		//serial_print("\n");
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
     b5c:	4a3e      	ldr	r2, [pc, #248]	; (c58 <i2c0_isr+0x11c>)
			txBufferLength = 0;
     b5e:	552b      	strb	r3, [r5, r4]
		//serial_print("\n");
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
     b60:	7013      	strb	r3, [r2, #0]
			txBufferLength = 0;
			if (user_onRequest != NULL) {
     b62:	6e6b      	ldr	r3, [r5, #100]	; 0x64
     b64:	2b00      	cmp	r3, #0
     b66:	d05e      	beq.n	c26 <i2c0_isr+0xea>
				user_onRequest();
     b68:	4798      	blx	r3
			}
			if (txBufferLength == 0) {
     b6a:	5d2b      	ldrb	r3, [r5, r4]
     b6c:	2b00      	cmp	r3, #0
     b6e:	d05a      	beq.n	c26 <i2c0_isr+0xea>
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
				txBuffer[0] = 0;
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
     b70:	23d0      	movs	r3, #208	; 0xd0
     b72:	692a      	ldr	r2, [r5, #16]
     b74:	7093      	strb	r3, [r2, #2]
			port().D = txBuffer[0];
     b76:	3b95      	subs	r3, #149	; 0x95
     b78:	5ceb      	ldrb	r3, [r5, r3]
     b7a:	692a      	ldr	r2, [r5, #16]
     b7c:	7113      	strb	r3, [r2, #4]
			txBufferIndex = 1;
     b7e:	235c      	movs	r3, #92	; 0x5c
     b80:	2201      	movs	r2, #1
     b82:	54ea      	strb	r2, [r5, r3]
     b84:	692b      	ldr	r3, [r5, #16]
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
			rxBuffer[rxBufferLength++] = data;
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
     b86:	2202      	movs	r2, #2
     b88:	70da      	strb	r2, [r3, #3]
#define MAKE_CONST(x) (__builtin_constant_p(x) ? (x) : (x))

#ifdef WIRE_IMPLEMENT_WIRE
constexpr uintptr_t i2c0_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C0));
TwoWire Wire(i2c0_addr, TwoWire::i2c0_hardware);
void i2c0_isr(void) { Wire.isr(); }
     b8a:	bd70      	pop	{r4, r5, r6, pc}


		}
		if (!(status & I2C_S_IAAS)) return;
	}
	if (status & I2C_S_IAAS) {
     b8c:	2240      	movs	r2, #64	; 0x40
     b8e:	4022      	ands	r2, r4
     b90:	d1df      	bne.n	b52 <i2c0_isr+0x16>
		port().S = I2C_S_IICIF;
		return;
	}
	#if defined(WIRE_HAS_STOP_INTERRUPT)
	c1 = port().FLT;
	if ((c1 & I2C_FLT_STOPF) && (c1 & I2C_FLT_STOPIE)) {
     b92:	2060      	movs	r0, #96	; 0x60
		}
		port().S = I2C_S_IICIF;
		return;
	}
	#if defined(WIRE_HAS_STOP_INTERRUPT)
	c1 = port().FLT;
     b94:	7999      	ldrb	r1, [r3, #6]
     b96:	b2c9      	uxtb	r1, r1
	if ((c1 & I2C_FLT_STOPF) && (c1 & I2C_FLT_STOPIE)) {
     b98:	4008      	ands	r0, r1
     b9a:	2860      	cmp	r0, #96	; 0x60
     b9c:	d04a      	beq.n	c34 <i2c0_isr+0xf8>
			user_onReceive(rxBufferLength);
		}
	}
	#endif
	c1 = port().C1;
	if (c1 & I2C_C1_TX) {
     b9e:	2110      	movs	r1, #16
			rxBufferIndex = 0;
			user_onReceive(rxBufferLength);
		}
	}
	#endif
	c1 = port().C1;
     ba0:	789a      	ldrb	r2, [r3, #2]
	if (c1 & I2C_C1_TX) {
     ba2:	400a      	ands	r2, r1
     ba4:	d015      	beq.n	bd2 <i2c0_isr+0x96>
		// Continue Slave Transmit
		//serial_print("t");
		if ((status & I2C_S_RXAK) == 0) {
     ba6:	2201      	movs	r2, #1
     ba8:	4014      	ands	r4, r2
     baa:	d135      	bne.n	c18 <i2c0_isr+0xdc>
			//serial_print(".");
			// Master ACK'd previous byte
			if (txBufferIndex < txBufferLength) {
     bac:	205d      	movs	r0, #93	; 0x5d
     bae:	314c      	adds	r1, #76	; 0x4c
     bb0:	5c6a      	ldrb	r2, [r5, r1]
     bb2:	5c28      	ldrb	r0, [r5, r0]
     bb4:	4290      	cmp	r0, r2
     bb6:	d94a      	bls.n	c4e <i2c0_isr+0x112>
				port().D = txBuffer[txBufferIndex++];
     bb8:	1c50      	adds	r0, r2, #1
     bba:	18aa      	adds	r2, r5, r2
     bbc:	5468      	strb	r0, [r5, r1]
     bbe:	323b      	adds	r2, #59	; 0x3b
     bc0:	7812      	ldrb	r2, [r2, #0]
     bc2:	711a      	strb	r2, [r3, #4]
			} else {
				port().D = 0;
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
     bc4:	23d0      	movs	r3, #208	; 0xd0
     bc6:	692a      	ldr	r2, [r5, #16]
     bc8:	7093      	strb	r3, [r2, #2]
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
			rxBuffer[rxBufferLength++] = data;
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
     bca:	2202      	movs	r2, #2
     bcc:	692b      	ldr	r3, [r5, #16]
     bce:	70da      	strb	r2, [r3, #3]
     bd0:	e7db      	b.n	b8a <i2c0_isr+0x4e>
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
			data = port().D;
		}
	} else {
		// Continue Slave Receive
		irqcount = 0;
     bd2:	2160      	movs	r1, #96	; 0x60
     bd4:	546a      	strb	r2, [r5, r1]
		#ifdef WIRE_HAS_STOP_INTERRUPT
		port().FLT |= I2C_FLT_STOPIE;
     bd6:	2220      	movs	r2, #32
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
     bd8:	2039      	movs	r0, #57	; 0x39
		}
	} else {
		// Continue Slave Receive
		irqcount = 0;
		#ifdef WIRE_HAS_STOP_INTERRUPT
		port().FLT |= I2C_FLT_STOPIE;
     bda:	7999      	ldrb	r1, [r3, #6]
     bdc:	430a      	orrs	r2, r1
     bde:	719a      	strb	r2, [r3, #6]
     be0:	692b      	ldr	r3, [r5, #16]
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
     be2:	5c29      	ldrb	r1, [r5, r0]
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
     be4:	791a      	ldrb	r2, [r3, #4]
     be6:	b2d2      	uxtb	r2, r2
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
     be8:	291f      	cmp	r1, #31
     bea:	d8cc      	bhi.n	b86 <i2c0_isr+0x4a>
     bec:	4c1a      	ldr	r4, [pc, #104]	; (c58 <i2c0_isr+0x11c>)
     bee:	7824      	ldrb	r4, [r4, #0]
     bf0:	2c00      	cmp	r4, #0
     bf2:	d0c8      	beq.n	b86 <i2c0_isr+0x4a>
			rxBuffer[rxBufferLength++] = data;
     bf4:	1c4c      	adds	r4, r1, #1
     bf6:	542c      	strb	r4, [r5, r0]
     bf8:	186d      	adds	r5, r5, r1
     bfa:	762a      	strb	r2, [r5, #24]
     bfc:	e7c3      	b.n	b86 <i2c0_isr+0x4a>
			port().D = txBuffer[0];
			txBufferIndex = 1;
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
     bfe:	2201      	movs	r2, #1
     c00:	4b15      	ldr	r3, [pc, #84]	; (c58 <i2c0_isr+0x11c>)
     c02:	701a      	strb	r2, [r3, #0]
			rxBufferLength = 0;
     c04:	2339      	movs	r3, #57	; 0x39
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
     c06:	692a      	ldr	r2, [r5, #16]
			txBufferIndex = 1;
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
			rxBufferLength = 0;
     c08:	54ec      	strb	r4, [r5, r3]
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
     c0a:	3387      	adds	r3, #135	; 0x87
     c0c:	7093      	strb	r3, [r2, #2]
     c0e:	692b      	ldr	r3, [r5, #16]
			data = port().D;
     c10:	791a      	ldrb	r2, [r3, #4]
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
			rxBuffer[rxBufferLength++] = data;
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
     c12:	2202      	movs	r2, #2
     c14:	70da      	strb	r2, [r3, #3]
     c16:	e7b8      	b.n	b8a <i2c0_isr+0x4e>
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
		} else {
			//serial_print("*");
			// Master did not ACK previous byte
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
     c18:	22c0      	movs	r2, #192	; 0xc0
     c1a:	709a      	strb	r2, [r3, #2]
     c1c:	692b      	ldr	r3, [r5, #16]
			data = port().D;
     c1e:	791a      	ldrb	r2, [r3, #4]
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
			rxBuffer[rxBufferLength++] = data;
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
     c20:	2202      	movs	r2, #2
     c22:	70da      	strb	r2, [r3, #3]
     c24:	e7b1      	b.n	b8a <i2c0_isr+0x4e>
			}
			if (txBufferLength == 0) {
				// is this correct, transmitting a single zero
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
     c26:	2201      	movs	r2, #1
     c28:	235d      	movs	r3, #93	; 0x5d
     c2a:	54ea      	strb	r2, [r5, r3]
				txBuffer[0] = 0;
     c2c:	2200      	movs	r2, #0
     c2e:	3b22      	subs	r3, #34	; 0x22
     c30:	54ea      	strb	r2, [r5, r3]
     c32:	e79d      	b.n	b70 <i2c0_isr+0x34>
		return;
	}
	#if defined(WIRE_HAS_STOP_INTERRUPT)
	c1 = port().FLT;
	if ((c1 & I2C_FLT_STOPF) && (c1 & I2C_FLT_STOPIE)) {
		port().FLT = c1 & ~I2C_FLT_STOPIE;
     c34:	3840      	subs	r0, #64	; 0x40
     c36:	4381      	bics	r1, r0
     c38:	7199      	strb	r1, [r3, #6]
		if (user_onReceive != NULL) {
     c3a:	6eab      	ldr	r3, [r5, #104]	; 0x68
     c3c:	2b00      	cmp	r3, #0
     c3e:	d004      	beq.n	c4a <i2c0_isr+0x10e>
			rxBufferIndex = 0;
     c40:	2138      	movs	r1, #56	; 0x38
     c42:	546a      	strb	r2, [r5, r1]
			user_onReceive(rxBufferLength);
     c44:	2239      	movs	r2, #57	; 0x39
     c46:	5ca8      	ldrb	r0, [r5, r2]
     c48:	4798      	blx	r3
     c4a:	692b      	ldr	r3, [r5, #16]
     c4c:	e7a7      	b.n	b9e <i2c0_isr+0x62>
			//serial_print(".");
			// Master ACK'd previous byte
			if (txBufferIndex < txBufferLength) {
				port().D = txBuffer[txBufferIndex++];
			} else {
				port().D = 0;
     c4e:	711c      	strb	r4, [r3, #4]
     c50:	e7b8      	b.n	bc4 <i2c0_isr+0x88>
     c52:	46c0      	nop			; (mov r8, r8)
     c54:	1ffffd20 	.word	0x1ffffd20
     c58:	200006b0 	.word	0x200006b0

00000c5c <Print::println()>:
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
     c5c:	b510      	push	{r4, lr}
     c5e:	0004      	movs	r4, r0
     c60:	b082      	sub	sp, #8
	uint8_t buf[2]={'\r', '\n'};
     c62:	2202      	movs	r2, #2
     c64:	4905      	ldr	r1, [pc, #20]	; (c7c <Print::println()+0x20>)
     c66:	a801      	add	r0, sp, #4
     c68:	f002 f8a8 	bl	2dbc <memcpy>
	return write(buf, 2);
     c6c:	6823      	ldr	r3, [r4, #0]
     c6e:	2202      	movs	r2, #2
     c70:	685b      	ldr	r3, [r3, #4]
     c72:	a901      	add	r1, sp, #4
     c74:	0020      	movs	r0, r4
     c76:	4798      	blx	r3
}
     c78:	b002      	add	sp, #8
     c7a:	bd10      	pop	{r4, pc}
     c7c:	00003288 	.word	0x00003288

00000c80 <Print::printNumberHex(unsigned long)>:
        if (sign) *--p = '-';
        return write(p, sizeof(buf) - (p - buf));
}

size_t Print::printNumberHex(unsigned long n)
{
     c80:	b530      	push	{r4, r5, lr}
        uint8_t digit, buf[8], *p;

        p = buf + (sizeof(buf));
        do {
                digit = n & 15;
     c82:	250f      	movs	r5, #15
        if (sign) *--p = '-';
        return write(p, sizeof(buf) - (p - buf));
}

size_t Print::printNumberHex(unsigned long n)
{
     c84:	b083      	sub	sp, #12
     c86:	000b      	movs	r3, r1
        uint8_t digit, buf[8], *p;

        p = buf + (sizeof(buf));
     c88:	a902      	add	r1, sp, #8
        do {
                digit = n & 15;
     c8a:	002a      	movs	r2, r5
     c8c:	401a      	ands	r2, r3
                *--p = (digit < 10) ? '0' + digit : 'A' + digit - 10;
     c8e:	0014      	movs	r4, r2
     c90:	3901      	subs	r1, #1
     c92:	3437      	adds	r4, #55	; 0x37
     c94:	2a09      	cmp	r2, #9
     c96:	d801      	bhi.n	c9c <Print::printNumberHex(unsigned long)+0x1c>
     c98:	3230      	adds	r2, #48	; 0x30
     c9a:	0014      	movs	r4, r2
     c9c:	700c      	strb	r4, [r1, #0]
                n >>= 4;
     c9e:	091b      	lsrs	r3, r3, #4
size_t Print::printNumberHex(unsigned long n)
{
        uint8_t digit, buf[8], *p;

        p = buf + (sizeof(buf));
        do {
     ca0:	d1f3      	bne.n	c8a <Print::printNumberHex(unsigned long)+0xa>
                digit = n & 15;
                *--p = (digit < 10) ? '0' + digit : 'A' + digit - 10;
                n >>= 4;
        } while (n);
        return write(p, sizeof(buf) - (p - buf));
     ca2:	ab02      	add	r3, sp, #8
     ca4:	1a5a      	subs	r2, r3, r1
     ca6:	6803      	ldr	r3, [r0, #0]
     ca8:	685b      	ldr	r3, [r3, #4]
     caa:	4798      	blx	r3
}
     cac:	b003      	add	sp, #12
     cae:	bd30      	pop	{r4, r5, pc}

00000cb0 <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
     cb0:	b510      	push	{r4, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
     cb2:	f7ff fbdd 	bl	470 <setup>
	while (1) {
		loop();
     cb6:	f7ff fbff 	bl	4b8 <loop>
		yield();
     cba:	f001 f8b7 	bl	1e2c <yield>
     cbe:	e7fa      	b.n	cb6 <main+0x6>

00000cc0 <fault_isr>:
void _init_Teensyduino_internal_(void) __attribute__((noinline));
void __libc_init_array(void);


void fault_isr(void)
{
     cc0:	b570      	push	{r4, r5, r6, lr}
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
     cc2:	2680      	movs	r6, #128	; 0x80
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
     cc4:	2580      	movs	r5, #128	; 0x80
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
     cc6:	4c11      	ldr	r4, [pc, #68]	; (d0c <fault_isr+0x4c>)
     cc8:	02f6      	lsls	r6, r6, #11
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
     cca:	00ed      	lsls	r5, r5, #3
     ccc:	e008      	b.n	ce0 <fault_isr+0x20>
     cce:	6823      	ldr	r3, [r4, #0]
     cd0:	422b      	tst	r3, r5
     cd2:	d10d      	bne.n	cf0 <fault_isr+0x30>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
     cd4:	6823      	ldr	r3, [r4, #0]
     cd6:	051b      	lsls	r3, r3, #20
     cd8:	d40f      	bmi.n	cfa <fault_isr+0x3a>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
     cda:	6823      	ldr	r3, [r4, #0]
     cdc:	04db      	lsls	r3, r3, #19
     cde:	d411      	bmi.n	d04 <fault_isr+0x44>
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
     ce0:	6823      	ldr	r3, [r4, #0]
     ce2:	4233      	tst	r3, r6
     ce4:	d0f3      	beq.n	cce <fault_isr+0xe>
     ce6:	f000 faed 	bl	12c4 <usb_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
     cea:	6823      	ldr	r3, [r4, #0]
     cec:	422b      	tst	r3, r5
     cee:	d0f1      	beq.n	cd4 <fault_isr+0x14>
     cf0:	f001 faf0 	bl	22d4 <uart0_status_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
     cf4:	6823      	ldr	r3, [r4, #0]
     cf6:	051b      	lsls	r3, r3, #20
     cf8:	d5ef      	bpl.n	cda <fault_isr+0x1a>
     cfa:	f001 fb61 	bl	23c0 <uart1_status_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
     cfe:	6823      	ldr	r3, [r4, #0]
     d00:	04db      	lsls	r3, r3, #19
     d02:	d5ed      	bpl.n	ce0 <fault_isr+0x20>
     d04:	f001 fbd2 	bl	24ac <uart2_status_isr>
     d08:	e7ea      	b.n	ce0 <fault_isr+0x20>
     d0a:	46c0      	nop			; (mov r8, r8)
     d0c:	40048034 	.word	0x40048034

00000d10 <unused_isr>:
	}
}

void unused_isr(void)
{
     d10:	b510      	push	{r4, lr}
	fault_isr();
     d12:	f7ff ffd5 	bl	cc0 <fault_isr>
     d16:	46c0      	nop			; (mov r8, r8)

00000d18 <startup_early_hook>:

static void startup_default_early_hook(void) {
#if defined(KINETISK)
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
#elif defined(KINETISL)
	SIM_COPC = 0;  // disable the watchdog
     d18:	2200      	movs	r2, #0
     d1a:	4b01      	ldr	r3, [pc, #4]	; (d20 <startup_early_hook+0x8>)
     d1c:	601a      	str	r2, [r3, #0]
#endif
}
     d1e:	4770      	bx	lr
     d20:	40048100 	.word	0x40048100

00000d24 <startup_late_hook>:
static void startup_default_late_hook(void) {}
     d24:	4770      	bx	lr
     d26:	46c0      	nop			; (mov r8, r8)

00000d28 <_sbrk>:

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

void * _sbrk(int incr)
{
     d28:	b510      	push	{r4, lr}
	char *prev, *stack;

	prev = __brkval;
     d2a:	4c0a      	ldr	r4, [pc, #40]	; (d54 <_sbrk+0x2c>)
     d2c:	6821      	ldr	r1, [r4, #0]
	if (incr != 0) {
     d2e:	2800      	cmp	r0, #0
     d30:	d007      	beq.n	d42 <_sbrk+0x1a>
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
     d32:	466a      	mov	r2, sp
		if (prev + incr >= stack - STACK_MARGIN) {
     d34:	180b      	adds	r3, r1, r0
     d36:	4808      	ldr	r0, [pc, #32]	; (d58 <_sbrk+0x30>)
     d38:	4684      	mov	ip, r0
     d3a:	4462      	add	r2, ip
     d3c:	4293      	cmp	r3, r2
     d3e:	d202      	bcs.n	d46 <_sbrk+0x1e>
			errno = ENOMEM;
			return (void *)-1;
		}
		__brkval = prev + incr;
     d40:	6023      	str	r3, [r4, #0]
	}
	return prev;
}
     d42:	0008      	movs	r0, r1
     d44:	bd10      	pop	{r4, pc}

	prev = __brkval;
	if (incr != 0) {
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
		if (prev + incr >= stack - STACK_MARGIN) {
			errno = ENOMEM;
     d46:	f001 fd5b 	bl	2800 <__errno>
     d4a:	230c      	movs	r3, #12
			return (void *)-1;
     d4c:	2101      	movs	r1, #1

	prev = __brkval;
	if (incr != 0) {
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
		if (prev + incr >= stack - STACK_MARGIN) {
			errno = ENOMEM;
     d4e:	6003      	str	r3, [r0, #0]
			return (void *)-1;
     d50:	4249      	negs	r1, r1
     d52:	e7f6      	b.n	d42 <_sbrk+0x1a>
     d54:	1ffffd8c 	.word	0x1ffffd8c
     d58:	fffffe00 	.word	0xfffffe00

00000d5c <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
     d5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     d5e:	0006      	movs	r6, r0
     d60:	000d      	movs	r5, r1
     d62:	0017      	movs	r7, r2
	unsigned digit;
	int i=0, j;
     d64:	2400      	movs	r4, #0
     d66:	e009      	b.n	d7c <ultoa+0x20>
	char t;

	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
     d68:	3130      	adds	r1, #48	; 0x30
     d6a:	b2c9      	uxtb	r1, r1
     d6c:	5529      	strb	r1, [r5, r4]
		val /= radix;
     d6e:	0030      	movs	r0, r6
     d70:	0039      	movs	r1, r7
     d72:	f001 fc9b 	bl	26ac <__aeabi_uidiv>
     d76:	1e06      	subs	r6, r0, #0
		if (val == 0) break;
     d78:	d00f      	beq.n	d9a <ultoa+0x3e>
		i++;
     d7a:	3401      	adds	r4, #1
	unsigned digit;
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
     d7c:	0039      	movs	r1, r7
     d7e:	0030      	movs	r0, r6
     d80:	f001 fd1a 	bl	27b8 <__aeabi_uidivmod>
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
     d84:	2909      	cmp	r1, #9
     d86:	d9ef      	bls.n	d68 <ultoa+0xc>
     d88:	3137      	adds	r1, #55	; 0x37
     d8a:	b2c9      	uxtb	r1, r1
     d8c:	5529      	strb	r1, [r5, r4]
		val /= radix;
     d8e:	0030      	movs	r0, r6
     d90:	0039      	movs	r1, r7
     d92:	f001 fc8b 	bl	26ac <__aeabi_uidiv>
     d96:	1e06      	subs	r6, r0, #0
		if (val == 0) break;
     d98:	d1ef      	bne.n	d7a <ultoa+0x1e>
		i++;
	}
	buf[i + 1] = 0;
     d9a:	192b      	adds	r3, r5, r4
     d9c:	7058      	strb	r0, [r3, #1]
	for (j=0; j < i; j++, i--) {
     d9e:	2300      	movs	r3, #0
     da0:	2c00      	cmp	r4, #0
     da2:	d007      	beq.n	db4 <ultoa+0x58>
		t = buf[j];
     da4:	5cea      	ldrb	r2, [r5, r3]
		buf[j] = buf[i];
     da6:	5d29      	ldrb	r1, [r5, r4]
     da8:	54e9      	strb	r1, [r5, r3]
		buf[i] = t;
     daa:	552a      	strb	r2, [r5, r4]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
     dac:	3301      	adds	r3, #1
     dae:	3c01      	subs	r4, #1
     db0:	42a3      	cmp	r3, r4
     db2:	dbf7      	blt.n	da4 <ultoa+0x48>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
     db4:	0028      	movs	r0, r5
     db6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00000db8 <_init_Teensyduino_internal_>:
	NVIC_ENABLE_IRQ(IRQ_PORTB);
	NVIC_ENABLE_IRQ(IRQ_PORTC);
	NVIC_ENABLE_IRQ(IRQ_PORTD);
	NVIC_ENABLE_IRQ(IRQ_PORTE);
#elif defined(__MKL26Z64__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
     db8:	2280      	movs	r2, #128	; 0x80
#endif

//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
     dba:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     dbc:	464f      	mov	r7, r9
     dbe:	4646      	mov	r6, r8
	NVIC_ENABLE_IRQ(IRQ_PORTB);
	NVIC_ENABLE_IRQ(IRQ_PORTC);
	NVIC_ENABLE_IRQ(IRQ_PORTD);
	NVIC_ENABLE_IRQ(IRQ_PORTE);
#elif defined(__MKL26Z64__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
     dc0:	4b61      	ldr	r3, [pc, #388]	; (f48 <_init_Teensyduino_internal_+0x190>)
     dc2:	05d2      	lsls	r2, r2, #23
#endif

//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
     dc4:	b4c0      	push	{r6, r7}
	NVIC_ENABLE_IRQ(IRQ_PORTB);
	NVIC_ENABLE_IRQ(IRQ_PORTC);
	NVIC_ENABLE_IRQ(IRQ_PORTD);
	NVIC_ENABLE_IRQ(IRQ_PORTE);
#elif defined(__MKL26Z64__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
     dc6:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
     dc8:	2280      	movs	r2, #128	; 0x80
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
     dca:	2000      	movs	r0, #0
	NVIC_ENABLE_IRQ(IRQ_PORTC);
	NVIC_ENABLE_IRQ(IRQ_PORTD);
	NVIC_ENABLE_IRQ(IRQ_PORTE);
#elif defined(__MKL26Z64__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
     dcc:	0612      	lsls	r2, r2, #24
     dce:	601a      	str	r2, [r3, #0]
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
     dd0:	4b5e      	ldr	r3, [pc, #376]	; (f4c <_init_Teensyduino_internal_+0x194>)
	FTM0_MOD = DEFAULT_FTM_MOD;
     dd2:	495f      	ldr	r1, [pc, #380]	; (f50 <_init_Teensyduino_internal_+0x198>)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
     dd4:	6018      	str	r0, [r3, #0]
	FTM0_MOD = DEFAULT_FTM_MOD;
     dd6:	4b5f      	ldr	r3, [pc, #380]	; (f54 <_init_Teensyduino_internal_+0x19c>)
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
     dd8:	4a5f      	ldr	r2, [pc, #380]	; (f58 <_init_Teensyduino_internal_+0x1a0>)
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
     dda:	6019      	str	r1, [r3, #0]
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
     ddc:	2328      	movs	r3, #40	; 0x28
     dde:	6013      	str	r3, [r2, #0]
	FTM0_C1SC = 0x28;
     de0:	4a5e      	ldr	r2, [pc, #376]	; (f5c <_init_Teensyduino_internal_+0x1a4>)
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
     de2:	4c5f      	ldr	r4, [pc, #380]	; (f60 <_init_Teensyduino_internal_+0x1a8>)
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
     de4:	6013      	str	r3, [r2, #0]
	FTM0_C2SC = 0x28;
     de6:	4a5f      	ldr	r2, [pc, #380]	; (f64 <_init_Teensyduino_internal_+0x1ac>)
     de8:	6013      	str	r3, [r2, #0]
	FTM0_C3SC = 0x28;
     dea:	4a5f      	ldr	r2, [pc, #380]	; (f68 <_init_Teensyduino_internal_+0x1b0>)
     dec:	6013      	str	r3, [r2, #0]
	FTM0_C4SC = 0x28;
     dee:	4a5f      	ldr	r2, [pc, #380]	; (f6c <_init_Teensyduino_internal_+0x1b4>)
     df0:	6013      	str	r3, [r2, #0]
	FTM0_C5SC = 0x28;
     df2:	4a5f      	ldr	r2, [pc, #380]	; (f70 <_init_Teensyduino_internal_+0x1b8>)
     df4:	6013      	str	r3, [r2, #0]
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
     df6:	2209      	movs	r2, #9
     df8:	6022      	str	r2, [r4, #0]
	FTM1_CNT = 0;
     dfa:	4c5e      	ldr	r4, [pc, #376]	; (f74 <_init_Teensyduino_internal_+0x1bc>)
     dfc:	6020      	str	r0, [r4, #0]
	FTM1_MOD = DEFAULT_FTM_MOD;
     dfe:	4c5e      	ldr	r4, [pc, #376]	; (f78 <_init_Teensyduino_internal_+0x1c0>)
     e00:	6021      	str	r1, [r4, #0]
	FTM1_C0SC = 0x28;
     e02:	4c5e      	ldr	r4, [pc, #376]	; (f7c <_init_Teensyduino_internal_+0x1c4>)
     e04:	6023      	str	r3, [r4, #0]
	FTM1_C1SC = 0x28;
     e06:	4c5e      	ldr	r4, [pc, #376]	; (f80 <_init_Teensyduino_internal_+0x1c8>)
     e08:	6023      	str	r3, [r4, #0]
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
     e0a:	4c5e      	ldr	r4, [pc, #376]	; (f84 <_init_Teensyduino_internal_+0x1cc>)
     e0c:	6022      	str	r2, [r4, #0]
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
     e0e:	4c5e      	ldr	r4, [pc, #376]	; (f88 <_init_Teensyduino_internal_+0x1d0>)
     e10:	6020      	str	r0, [r4, #0]
	FTM2_MOD = DEFAULT_FTM_MOD;
     e12:	485e      	ldr	r0, [pc, #376]	; (f8c <_init_Teensyduino_internal_+0x1d4>)
     e14:	6001      	str	r1, [r0, #0]
	FTM2_C0SC = 0x28;
     e16:	495e      	ldr	r1, [pc, #376]	; (f90 <_init_Teensyduino_internal_+0x1d8>)
     e18:	600b      	str	r3, [r1, #0]
	FTM2_C1SC = 0x28;
     e1a:	495e      	ldr	r1, [pc, #376]	; (f94 <_init_Teensyduino_internal_+0x1dc>)
     e1c:	600b      	str	r3, [r1, #0]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
     e1e:	4b5e      	ldr	r3, [pc, #376]	; (f98 <_init_Teensyduino_internal_+0x1e0>)
     e20:	601a      	str	r2, [r3, #0]
	TPM1_MOD = 32767;
	TPM1_C0SC = 0x28;
	TPM1_C1SC = 0x28;
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
#endif
	analog_init();
     e22:	f001 f9e5 	bl	21f0 <analog_init>

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
     e26:	b672      	cpsid	i
	current = SYST_CVR;
     e28:	4b5c      	ldr	r3, [pc, #368]	; (f9c <_init_Teensyduino_internal_+0x1e4>)
	count = systick_millis_count;
     e2a:	4e5d      	ldr	r6, [pc, #372]	; (fa0 <_init_Teensyduino_internal_+0x1e8>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
     e2c:	681a      	ldr	r2, [r3, #0]
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
     e2e:	4b5d      	ldr	r3, [pc, #372]	; (fa4 <_init_Teensyduino_internal_+0x1ec>)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
	count = systick_millis_count;
     e30:	6834      	ldr	r4, [r6, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
     e32:	681b      	ldr	r3, [r3, #0]
	__enable_irq();
     e34:	b662      	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
     e36:	015b      	lsls	r3, r3, #5
     e38:	d504      	bpl.n	e44 <_init_Teensyduino_internal_+0x8c>
     e3a:	2132      	movs	r1, #50	; 0x32
     e3c:	4291      	cmp	r1, r2
     e3e:	4189      	sbcs	r1, r1
     e40:	4249      	negs	r1, r1
     e42:	1864      	adds	r4, r4, r1
	current = ((F_CPU / 1000) - 1) - current;
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
     e44:	4b58      	ldr	r3, [pc, #352]	; (fa8 <_init_Teensyduino_internal_+0x1f0>)
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
     e46:	2780      	movs	r7, #128	; 0x80
	current = ((F_CPU / 1000) - 1) - current;
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
     e48:	1a9a      	subs	r2, r3, r2
     e4a:	4b58      	ldr	r3, [pc, #352]	; (fac <_init_Teensyduino_internal_+0x1f4>)
     e4c:	2519      	movs	r5, #25
     e4e:	4353      	muls	r3, r2
     e50:	22fa      	movs	r2, #250	; 0xfa
     e52:	0092      	lsls	r2, r2, #2
     e54:	4354      	muls	r4, r2
     e56:	0d9b      	lsrs	r3, r3, #22
     e58:	191c      	adds	r4, r3, r4
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
     e5a:	4b50      	ldr	r3, [pc, #320]	; (f9c <_init_Teensyduino_internal_+0x1e4>)
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
     e5c:	04ff      	lsls	r7, r7, #19
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
     e5e:	4699      	mov	r9, r3
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
     e60:	4b50      	ldr	r3, [pc, #320]	; (fa4 <_init_Teensyduino_internal_+0x1ec>)
     e62:	4698      	mov	r8, r3

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
     e64:	b672      	cpsid	i
	current = SYST_CVR;
     e66:	464b      	mov	r3, r9
     e68:	6818      	ldr	r0, [r3, #0]
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
     e6a:	4643      	mov	r3, r8
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
	count = systick_millis_count;
     e6c:	6831      	ldr	r1, [r6, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
     e6e:	681b      	ldr	r3, [r3, #0]
	__enable_irq();
     e70:	b662      	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
     e72:	423b      	tst	r3, r7
     e74:	d004      	beq.n	e80 <_init_Teensyduino_internal_+0xc8>
     e76:	2232      	movs	r2, #50	; 0x32
     e78:	4282      	cmp	r2, r0
     e7a:	4192      	sbcs	r2, r2
     e7c:	4252      	negs	r2, r2
     e7e:	1889      	adds	r1, r1, r2
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
     e80:	4b49      	ldr	r3, [pc, #292]	; (fa8 <_init_Teensyduino_internal_+0x1f0>)
     e82:	4a4a      	ldr	r2, [pc, #296]	; (fac <_init_Teensyduino_internal_+0x1f4>)
     e84:	1a1b      	subs	r3, r3, r0
     e86:	4353      	muls	r3, r2
     e88:	22fa      	movs	r2, #250	; 0xfa
     e8a:	0092      	lsls	r2, r2, #2
     e8c:	434a      	muls	r2, r1
     e8e:	0d9b      	lsrs	r3, r3, #22
     e90:	1b1b      	subs	r3, r3, r4
     e92:	189b      	adds	r3, r3, r2
     e94:	4a46      	ldr	r2, [pc, #280]	; (fb0 <_init_Teensyduino_internal_+0x1f8>)
     e96:	4293      	cmp	r3, r2
     e98:	d907      	bls.n	eaa <_init_Teensyduino_internal_+0xf2>
				ms--;
     e9a:	3d01      	subs	r5, #1
				if (ms == 0) return;
     e9c:	2d00      	cmp	r5, #0
     e9e:	d007      	beq.n	eb0 <_init_Teensyduino_internal_+0xf8>
				start += 1000;
     ea0:	23fa      	movs	r3, #250	; 0xfa
     ea2:	009b      	lsls	r3, r3, #2
     ea4:	469c      	mov	ip, r3
     ea6:	4464      	add	r4, ip
     ea8:	e7dc      	b.n	e64 <_init_Teensyduino_internal_+0xac>
			}
			yield();
     eaa:	f000 ffbf 	bl	1e2c <yield>
     eae:	e7d9      	b.n	e64 <_init_Teensyduino_internal_+0xac>
	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
	usb_init();
     eb0:	f000 fd16 	bl	18e0 <usb_init>

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
     eb4:	b672      	cpsid	i
	current = SYST_CVR;
     eb6:	4b39      	ldr	r3, [pc, #228]	; (f9c <_init_Teensyduino_internal_+0x1e4>)
     eb8:	681a      	ldr	r2, [r3, #0]
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
     eba:	4b3a      	ldr	r3, [pc, #232]	; (fa4 <_init_Teensyduino_internal_+0x1ec>)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
	count = systick_millis_count;
     ebc:	6834      	ldr	r4, [r6, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
     ebe:	681b      	ldr	r3, [r3, #0]
	__enable_irq();
     ec0:	b662      	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
     ec2:	015b      	lsls	r3, r3, #5
     ec4:	d504      	bpl.n	ed0 <_init_Teensyduino_internal_+0x118>
     ec6:	2132      	movs	r1, #50	; 0x32
     ec8:	4291      	cmp	r1, r2
     eca:	4189      	sbcs	r1, r1
     ecc:	4249      	negs	r1, r1
     ece:	1864      	adds	r4, r4, r1
	current = ((F_CPU / 1000) - 1) - current;
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
     ed0:	4b35      	ldr	r3, [pc, #212]	; (fa8 <_init_Teensyduino_internal_+0x1f0>)
     ed2:	2514      	movs	r5, #20
     ed4:	1a9a      	subs	r2, r3, r2
     ed6:	4b35      	ldr	r3, [pc, #212]	; (fac <_init_Teensyduino_internal_+0x1f4>)
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
     ed8:	2780      	movs	r7, #128	; 0x80
	current = ((F_CPU / 1000) - 1) - current;
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
     eda:	4353      	muls	r3, r2
     edc:	22fa      	movs	r2, #250	; 0xfa
     ede:	0092      	lsls	r2, r2, #2
     ee0:	4354      	muls	r4, r2
     ee2:	0d9b      	lsrs	r3, r3, #22
     ee4:	191c      	adds	r4, r3, r4
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
     ee6:	4b2d      	ldr	r3, [pc, #180]	; (f9c <_init_Teensyduino_internal_+0x1e4>)
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
	current = ((F_CPU / 1000) - 1) - current;
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
     ee8:	35ff      	adds	r5, #255	; 0xff
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
     eea:	4699      	mov	r9, r3
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
     eec:	4b2d      	ldr	r3, [pc, #180]	; (fa4 <_init_Teensyduino_internal_+0x1ec>)
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
     eee:	04ff      	lsls	r7, r7, #19
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
     ef0:	4698      	mov	r8, r3

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
     ef2:	b672      	cpsid	i
	current = SYST_CVR;
     ef4:	464b      	mov	r3, r9
     ef6:	6818      	ldr	r0, [r3, #0]
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
     ef8:	4643      	mov	r3, r8
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
	count = systick_millis_count;
     efa:	6831      	ldr	r1, [r6, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
     efc:	681b      	ldr	r3, [r3, #0]
	__enable_irq();
     efe:	b662      	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
     f00:	423b      	tst	r3, r7
     f02:	d004      	beq.n	f0e <_init_Teensyduino_internal_+0x156>
     f04:	2232      	movs	r2, #50	; 0x32
     f06:	4282      	cmp	r2, r0
     f08:	4192      	sbcs	r2, r2
     f0a:	4252      	negs	r2, r2
     f0c:	1889      	adds	r1, r1, r2
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
     f0e:	4b26      	ldr	r3, [pc, #152]	; (fa8 <_init_Teensyduino_internal_+0x1f0>)
     f10:	4a26      	ldr	r2, [pc, #152]	; (fac <_init_Teensyduino_internal_+0x1f4>)
     f12:	1a1b      	subs	r3, r3, r0
     f14:	4353      	muls	r3, r2
     f16:	22fa      	movs	r2, #250	; 0xfa
     f18:	0092      	lsls	r2, r2, #2
     f1a:	434a      	muls	r2, r1
     f1c:	0d9b      	lsrs	r3, r3, #22
     f1e:	1b1b      	subs	r3, r3, r4
     f20:	189b      	adds	r3, r3, r2
     f22:	4a23      	ldr	r2, [pc, #140]	; (fb0 <_init_Teensyduino_internal_+0x1f8>)
     f24:	4293      	cmp	r3, r2
     f26:	d907      	bls.n	f38 <_init_Teensyduino_internal_+0x180>
				ms--;
     f28:	3d01      	subs	r5, #1
				if (ms == 0) return;
     f2a:	2d00      	cmp	r5, #0
     f2c:	d007      	beq.n	f3e <_init_Teensyduino_internal_+0x186>
				start += 1000;
     f2e:	23fa      	movs	r3, #250	; 0xfa
     f30:	009b      	lsls	r3, r3, #2
     f32:	469c      	mov	ip, r3
     f34:	4464      	add	r4, ip
     f36:	e7dc      	b.n	ef2 <_init_Teensyduino_internal_+0x13a>
			}
			yield();
     f38:	f000 ff78 	bl	1e2c <yield>
     f3c:	e7d9      	b.n	ef2 <_init_Teensyduino_internal_+0x13a>
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
	usb_init();
	delay(TEENSY_INIT_USB_DELAY_AFTER);
}
     f3e:	bc0c      	pop	{r2, r3}
     f40:	4690      	mov	r8, r2
     f42:	4699      	mov	r9, r3
     f44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     f46:	46c0      	nop			; (mov r8, r8)
     f48:	e000e100 	.word	0xe000e100
     f4c:	40038004 	.word	0x40038004
     f50:	0000bfff 	.word	0x0000bfff
     f54:	40038008 	.word	0x40038008
     f58:	4003800c 	.word	0x4003800c
     f5c:	40038014 	.word	0x40038014
     f60:	40038000 	.word	0x40038000
     f64:	4003801c 	.word	0x4003801c
     f68:	40038024 	.word	0x40038024
     f6c:	4003802c 	.word	0x4003802c
     f70:	40038034 	.word	0x40038034
     f74:	40039004 	.word	0x40039004
     f78:	40039008 	.word	0x40039008
     f7c:	4003900c 	.word	0x4003900c
     f80:	40039014 	.word	0x40039014
     f84:	40039000 	.word	0x40039000
     f88:	4003a004 	.word	0x4003a004
     f8c:	4003a008 	.word	0x4003a008
     f90:	4003a00c 	.word	0x4003a00c
     f94:	4003a014 	.word	0x4003a014
     f98:	4003a000 	.word	0x4003a000
     f9c:	e000e018 	.word	0xe000e018
     fa0:	200006b4 	.word	0x200006b4
     fa4:	e000ed04 	.word	0xe000ed04
     fa8:	0000bb7f 	.word	0x0000bb7f
     fac:	00015555 	.word	0x00015555
     fb0:	000003e7 	.word	0x000003e7

00000fb4 <digitalWrite>:


// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
     fb4:	b510      	push	{r4, lr}
	if (pin >= CORE_NUM_DIGITAL) return;
     fb6:	281a      	cmp	r0, #26
     fb8:	d80c      	bhi.n	fd4 <digitalWrite+0x20>
			*portSetRegister(pin) = 1;
		} else {
			*portClearRegister(pin) = 1;
		}
#else
	if (*portModeRegister(pin) & digitalPinToBitMask(pin)) {
     fba:	0042      	lsls	r2, r0, #1
     fbc:	4b0d      	ldr	r3, [pc, #52]	; (ff4 <digitalWrite+0x40>)
     fbe:	1810      	adds	r0, r2, r0
     fc0:	0080      	lsls	r0, r0, #2
     fc2:	58c2      	ldr	r2, [r0, r3]
     fc4:	1818      	adds	r0, r3, r0
     fc6:	7d14      	ldrb	r4, [r2, #20]
     fc8:	7a03      	ldrb	r3, [r0, #8]
     fca:	4223      	tst	r3, r4
     fcc:	d003      	beq.n	fd6 <digitalWrite+0x22>
		if (val) {
     fce:	2900      	cmp	r1, #0
     fd0:	d009      	beq.n	fe6 <digitalWrite+0x32>
			*portSetRegister(pin) = digitalPinToBitMask(pin);
     fd2:	7113      	strb	r3, [r2, #4]
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
     fd4:	bd10      	pop	{r4, pc}
		} else {
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
     fd6:	6843      	ldr	r3, [r0, #4]
		if (val) {
     fd8:	2900      	cmp	r1, #0
     fda:	d106      	bne.n	fea <digitalWrite+0x36>
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
			//*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else {
			// TODO use bitband for atomic read-mod-write
			*config &= ~(PORT_PCR_PE);
     fdc:	2102      	movs	r1, #2
     fde:	681a      	ldr	r2, [r3, #0]
     fe0:	438a      	bics	r2, r1
     fe2:	601a      	str	r2, [r3, #0]
     fe4:	e7f6      	b.n	fd4 <digitalWrite+0x20>
#else
	if (*portModeRegister(pin) & digitalPinToBitMask(pin)) {
		if (val) {
			*portSetRegister(pin) = digitalPinToBitMask(pin);
		} else {
			*portClearRegister(pin) = digitalPinToBitMask(pin);
     fe6:	7213      	strb	r3, [r2, #8]
     fe8:	e7f4      	b.n	fd4 <digitalWrite+0x20>
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
     fea:	2203      	movs	r2, #3
     fec:	6819      	ldr	r1, [r3, #0]
     fee:	430a      	orrs	r2, r1
     ff0:	601a      	str	r2, [r3, #0]
     ff2:	e7ef      	b.n	fd4 <digitalWrite+0x20>
     ff4:	0000328c 	.word	0x0000328c

00000ff8 <pinMode>:
}



void pinMode(uint8_t pin, uint8_t mode)
{
     ff8:	b510      	push	{r4, lr}
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
     ffa:	281a      	cmp	r0, #26
     ffc:	d816      	bhi.n	102c <pinMode+0x34>
	config = portConfigRegister(pin);
     ffe:	0043      	lsls	r3, r0, #1
    1000:	1818      	adds	r0, r3, r0
    1002:	4c1e      	ldr	r4, [pc, #120]	; (107c <pinMode+0x84>)
    1004:	0080      	lsls	r0, r0, #2
    1006:	1822      	adds	r2, r4, r0
    1008:	6853      	ldr	r3, [r2, #4]

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    100a:	2901      	cmp	r1, #1
    100c:	d00f      	beq.n	102e <pinMode+0x36>
    100e:	2904      	cmp	r1, #4
    1010:	d01e      	beq.n	1050 <pinMode+0x58>
                }
	} else {
#ifdef KINETISK
		*portModeRegister(pin) = 0;
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
    1012:	5904      	ldr	r4, [r0, r4]
    1014:	7a12      	ldrb	r2, [r2, #8]
    1016:	7d20      	ldrb	r0, [r4, #20]
    1018:	4390      	bics	r0, r2
    101a:	7520      	strb	r0, [r4, #20]
#endif
		if (mode == INPUT) {
    101c:	2900      	cmp	r1, #0
    101e:	d013      	beq.n	1048 <pinMode+0x50>
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
    1020:	2902      	cmp	r1, #2
    1022:	d023      	beq.n	106c <pinMode+0x74>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else if (mode == INPUT_PULLDOWN) {
    1024:	2903      	cmp	r1, #3
    1026:	d025      	beq.n	1074 <pinMode+0x7c>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
		} else { // INPUT_DISABLE
			*config = 0;
    1028:	2200      	movs	r2, #0
    102a:	601a      	str	r2, [r3, #0]
		}
	}
}
    102c:	bd10      	pop	{r4, pc}

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
    102e:	5901      	ldr	r1, [r0, r4]
    1030:	7a12      	ldrb	r2, [r2, #8]
    1032:	7d08      	ldrb	r0, [r1, #20]
    1034:	4302      	orrs	r2, r0
    1036:	750a      	strb	r2, [r1, #20]
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    1038:	22a2      	movs	r2, #162	; 0xa2
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    103a:	2120      	movs	r1, #32
#ifdef KINETISK
		*portModeRegister(pin) = 1;
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    103c:	0052      	lsls	r2, r2, #1
    103e:	601a      	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    1040:	681a      	ldr	r2, [r3, #0]
    1042:	438a      	bics	r2, r1
    1044:	601a      	str	r2, [r3, #0]
    1046:	e7f1      	b.n	102c <pinMode+0x34>
		*portModeRegister(pin) = 0;
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
    1048:	2280      	movs	r2, #128	; 0x80
    104a:	0052      	lsls	r2, r2, #1
    104c:	601a      	str	r2, [r3, #0]
    104e:	e7ed      	b.n	102c <pinMode+0x34>

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
    1050:	5901      	ldr	r1, [r0, r4]
    1052:	7a12      	ldrb	r2, [r2, #8]
    1054:	7d08      	ldrb	r0, [r1, #20]
    1056:	4302      	orrs	r2, r0
    1058:	750a      	strb	r2, [r1, #20]
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    105a:	22a2      	movs	r2, #162	; 0xa2
    105c:	0052      	lsls	r2, r2, #1
    105e:	601a      	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
    1060:	6819      	ldr	r1, [r3, #0]
    1062:	3a25      	subs	r2, #37	; 0x25
    1064:	3aff      	subs	r2, #255	; 0xff
    1066:	430a      	orrs	r2, r1
    1068:	601a      	str	r2, [r3, #0]
    106a:	e7df      	b.n	102c <pinMode+0x34>
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
    106c:	2204      	movs	r2, #4
    106e:	32ff      	adds	r2, #255	; 0xff
    1070:	601a      	str	r2, [r3, #0]
    1072:	e7db      	b.n	102c <pinMode+0x34>
		} else if (mode == INPUT_PULLDOWN) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
    1074:	2281      	movs	r2, #129	; 0x81
    1076:	0052      	lsls	r2, r2, #1
    1078:	601a      	str	r2, [r3, #0]
    107a:	e7d7      	b.n	102c <pinMode+0x34>
    107c:	0000328c 	.word	0x0000328c

00001080 <delay>:
#endif
	return count * 1000 + current / (F_CPU / 1000000);
}

void delay(uint32_t ms)
{
    1080:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1082:	464f      	mov	r7, r9
    1084:	4646      	mov	r6, r8
    1086:	0005      	movs	r5, r0
    1088:	b4c0      	push	{r6, r7}

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    108a:	b672      	cpsid	i
	current = SYST_CVR;
    108c:	4b24      	ldr	r3, [pc, #144]	; (1120 <delay+0xa0>)
	count = systick_millis_count;
    108e:	4e25      	ldr	r6, [pc, #148]	; (1124 <delay+0xa4>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    1090:	681c      	ldr	r4, [r3, #0]
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    1092:	4b25      	ldr	r3, [pc, #148]	; (1128 <delay+0xa8>)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
	count = systick_millis_count;
    1094:	6831      	ldr	r1, [r6, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    1096:	681b      	ldr	r3, [r3, #0]
	__enable_irq();
    1098:	b662      	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    109a:	015b      	lsls	r3, r3, #5
    109c:	d504      	bpl.n	10a8 <delay+0x28>
    109e:	2232      	movs	r2, #50	; 0x32
    10a0:	42a2      	cmp	r2, r4
    10a2:	4192      	sbcs	r2, r2
    10a4:	4252      	negs	r2, r2
    10a6:	1889      	adds	r1, r1, r2

void delay(uint32_t ms)
{
	uint32_t start = micros();

	if (ms > 0) {
    10a8:	2d00      	cmp	r5, #0
    10aa:	d034      	beq.n	1116 <delay+0x96>
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
	current = ((F_CPU / 1000) - 1) - current;
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
    10ac:	4b1f      	ldr	r3, [pc, #124]	; (112c <delay+0xac>)
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    10ae:	2780      	movs	r7, #128	; 0x80
	current = ((F_CPU / 1000) - 1) - current;
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
    10b0:	1b1c      	subs	r4, r3, r4
    10b2:	4b1f      	ldr	r3, [pc, #124]	; (1130 <delay+0xb0>)
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    10b4:	04ff      	lsls	r7, r7, #19
	current = ((F_CPU / 1000) - 1) - current;
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
    10b6:	4363      	muls	r3, r4
    10b8:	24fa      	movs	r4, #250	; 0xfa
    10ba:	00a4      	lsls	r4, r4, #2
    10bc:	434c      	muls	r4, r1
    10be:	0d9b      	lsrs	r3, r3, #22
    10c0:	191c      	adds	r4, r3, r4
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    10c2:	4b17      	ldr	r3, [pc, #92]	; (1120 <delay+0xa0>)
    10c4:	4699      	mov	r9, r3
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    10c6:	4b18      	ldr	r3, [pc, #96]	; (1128 <delay+0xa8>)
    10c8:	4698      	mov	r8, r3

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    10ca:	b672      	cpsid	i
	current = SYST_CVR;
    10cc:	464b      	mov	r3, r9
    10ce:	6818      	ldr	r0, [r3, #0]
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    10d0:	4643      	mov	r3, r8
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
	count = systick_millis_count;
    10d2:	6831      	ldr	r1, [r6, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    10d4:	681b      	ldr	r3, [r3, #0]
	__enable_irq();
    10d6:	b662      	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    10d8:	423b      	tst	r3, r7
    10da:	d004      	beq.n	10e6 <delay+0x66>
    10dc:	2232      	movs	r2, #50	; 0x32
    10de:	4282      	cmp	r2, r0
    10e0:	4192      	sbcs	r2, r2
    10e2:	4252      	negs	r2, r2
    10e4:	1889      	adds	r1, r1, r2
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    10e6:	4b11      	ldr	r3, [pc, #68]	; (112c <delay+0xac>)
    10e8:	4a11      	ldr	r2, [pc, #68]	; (1130 <delay+0xb0>)
    10ea:	1a1b      	subs	r3, r3, r0
    10ec:	4353      	muls	r3, r2
    10ee:	22fa      	movs	r2, #250	; 0xfa
    10f0:	0092      	lsls	r2, r2, #2
    10f2:	434a      	muls	r2, r1
    10f4:	0d9b      	lsrs	r3, r3, #22
    10f6:	1b1b      	subs	r3, r3, r4
    10f8:	189b      	adds	r3, r3, r2
    10fa:	4a0e      	ldr	r2, [pc, #56]	; (1134 <delay+0xb4>)
    10fc:	4293      	cmp	r3, r2
    10fe:	d907      	bls.n	1110 <delay+0x90>
				ms--;
    1100:	3d01      	subs	r5, #1
				if (ms == 0) return;
    1102:	2d00      	cmp	r5, #0
    1104:	d007      	beq.n	1116 <delay+0x96>
				start += 1000;
    1106:	23fa      	movs	r3, #250	; 0xfa
    1108:	009b      	lsls	r3, r3, #2
    110a:	469c      	mov	ip, r3
    110c:	4464      	add	r4, ip
    110e:	e7dc      	b.n	10ca <delay+0x4a>
			}
			yield();
    1110:	f000 fe8c 	bl	1e2c <yield>
		}
    1114:	e7d9      	b.n	10ca <delay+0x4a>
	}
}
    1116:	bc0c      	pop	{r2, r3}
    1118:	4690      	mov	r8, r2
    111a:	4699      	mov	r9, r3
    111c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    111e:	46c0      	nop			; (mov r8, r8)
    1120:	e000e018 	.word	0xe000e018
    1124:	200006b4 	.word	0x200006b4
    1128:	e000ed04 	.word	0xe000ed04
    112c:	0000bb7f 	.word	0x0000bb7f
    1130:	00015555 	.word	0x00015555
    1134:	000003e7 	.word	0x000003e7

00001138 <endpoint0_transmit>:
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    1138:	2302      	movs	r3, #2
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
}


static void endpoint0_transmit(const void *data, uint32_t len)
{
    113a:	b5f0      	push	{r4, r5, r6, r7, lr}
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    113c:	4e0b      	ldr	r6, [pc, #44]	; (116c <endpoint0_transmit+0x34>)
    113e:	4c0c      	ldr	r4, [pc, #48]	; (1170 <endpoint0_transmit+0x38>)
    1140:	7837      	ldrb	r7, [r6, #0]
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
}


static void endpoint0_transmit(const void *data, uint32_t len)
{
    1142:	000d      	movs	r5, r1
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    1144:	433b      	orrs	r3, r7
    1146:	00db      	lsls	r3, r3, #3
    1148:	18e2      	adds	r2, r4, r3
    114a:	6050      	str	r0, [r2, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    114c:	4a09      	ldr	r2, [pc, #36]	; (1174 <endpoint0_transmit+0x3c>)
    114e:	20c8      	movs	r0, #200	; 0xc8
    1150:	7811      	ldrb	r1, [r2, #0]
    1152:	2900      	cmp	r1, #0
    1154:	d100      	bne.n	1158 <endpoint0_transmit+0x20>
    1156:	3840      	subs	r0, #64	; 0x40
    1158:	042d      	lsls	r5, r5, #16
    115a:	4328      	orrs	r0, r5
    115c:	50e0      	str	r0, [r4, r3]
	ep0_tx_data_toggle ^= 1;
    115e:	2301      	movs	r3, #1
    1160:	4059      	eors	r1, r3
	ep0_tx_bdt_bank ^= 1;
    1162:	407b      	eors	r3, r7
    1164:	7033      	strb	r3, [r6, #0]
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    1166:	7011      	strb	r1, [r2, #0]
	ep0_tx_bdt_bank ^= 1;
}
    1168:	bdf0      	pop	{r4, r5, r6, r7, pc}
    116a:	46c0      	nop			; (mov r8, r8)
    116c:	20000720 	.word	0x20000720
    1170:	1ffff800 	.word	0x1ffff800
    1174:	20000799 	.word	0x20000799

00001178 <usb_rx>:


usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
    1178:	1e43      	subs	r3, r0, #1




usb_packet_t *usb_rx(uint32_t endpoint)
{
    117a:	b510      	push	{r4, lr}
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    117c:	2000      	movs	r0, #0
    117e:	2b03      	cmp	r3, #3
    1180:	d80e      	bhi.n	11a0 <usb_rx+0x28>
	__disable_irq();
    1182:	b672      	cpsid	i
	ret = rx_first[endpoint];
    1184:	4a07      	ldr	r2, [pc, #28]	; (11a4 <usb_rx+0x2c>)
    1186:	0099      	lsls	r1, r3, #2
    1188:	5888      	ldr	r0, [r1, r2]
	if (ret) {
    118a:	2800      	cmp	r0, #0
    118c:	d007      	beq.n	119e <usb_rx+0x26>
		rx_first[endpoint] = ret->next;
    118e:	6844      	ldr	r4, [r0, #4]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    1190:	005b      	lsls	r3, r3, #1
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
	__disable_irq();
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
    1192:	508c      	str	r4, [r1, r2]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    1194:	4904      	ldr	r1, [pc, #16]	; (11a8 <usb_rx+0x30>)
    1196:	8804      	ldrh	r4, [r0, #0]
    1198:	5a5a      	ldrh	r2, [r3, r1]
    119a:	1b12      	subs	r2, r2, r4
    119c:	525a      	strh	r2, [r3, r1]
	}
	__enable_irq();
    119e:	b662      	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    11a0:	bd10      	pop	{r4, pc}
    11a2:	46c0      	nop			; (mov r8, r8)
    11a4:	20000710 	.word	0x20000710
    11a8:	20000980 	.word	0x20000980

000011ac <usb_tx_packet_count>:
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    11ac:	1e43      	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return 0;
    11ae:	2000      	movs	r0, #0
    11b0:	2b03      	cmp	r3, #3
    11b2:	d809      	bhi.n	11c8 <usb_tx_packet_count+0x1c>
	__disable_irq();
    11b4:	b672      	cpsid	i
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    11b6:	4a05      	ldr	r2, [pc, #20]	; (11cc <usb_tx_packet_count+0x20>)
    11b8:	009b      	lsls	r3, r3, #2
    11ba:	589b      	ldr	r3, [r3, r2]
    11bc:	2b00      	cmp	r3, #0
    11be:	d002      	beq.n	11c6 <usb_tx_packet_count+0x1a>
    11c0:	3001      	adds	r0, #1
    11c2:	685b      	ldr	r3, [r3, #4]
    11c4:	e7fa      	b.n	11bc <usb_tx_packet_count+0x10>
	__enable_irq();
    11c6:	b662      	cpsie	i
	return count;
}
    11c8:	4770      	bx	lr
    11ca:	46c0      	nop			; (mov r8, r8)
    11cc:	20000764 	.word	0x20000764

000011d0 <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory(usb_packet_t *packet)
{
    11d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    11d2:	b672      	cpsid	i
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    11d4:	2201      	movs	r2, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    11d6:	2608      	movs	r6, #8
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    11d8:	4694      	mov	ip, r2
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    11da:	4f16      	ldr	r7, [pc, #88]	; (1234 <usb_rx_memory+0x64>)
			if (table[index(i, RX, EVEN)].desc == 0) {
    11dc:	4c16      	ldr	r4, [pc, #88]	; (1238 <usb_rx_memory+0x68>)
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    11de:	1e53      	subs	r3, r2, #1
    11e0:	5cfb      	ldrb	r3, [r7, r3]
    11e2:	4233      	tst	r3, r6
    11e4:	d01b      	beq.n	121e <usb_rx_memory+0x4e>
			if (table[index(i, RX, EVEN)].desc == 0) {
    11e6:	0151      	lsls	r1, r2, #5
    11e8:	590d      	ldr	r5, [r1, r4]
    11ea:	0093      	lsls	r3, r2, #2
    11ec:	2d00      	cmp	r5, #0
    11ee:	d105      	bne.n	11fc <usb_rx_memory+0x2c>
				table[index(i, RX, EVEN)].addr = packet->buf;
    11f0:	1863      	adds	r3, r4, r1
    11f2:	3008      	adds	r0, #8
    11f4:	6058      	str	r0, [r3, #4]
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    11f6:	4b11      	ldr	r3, [pc, #68]	; (123c <usb_rx_memory+0x6c>)
    11f8:	5063      	str	r3, [r4, r1]
    11fa:	e00a      	b.n	1212 <usb_rx_memory+0x42>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    11fc:	4661      	mov	r1, ip
    11fe:	430b      	orrs	r3, r1
    1200:	00db      	lsls	r3, r3, #3
    1202:	5919      	ldr	r1, [r3, r4]
    1204:	2900      	cmp	r1, #0
    1206:	d10a      	bne.n	121e <usb_rx_memory+0x4e>
				table[index(i, RX, ODD)].addr = packet->buf;
    1208:	18e2      	adds	r2, r4, r3
    120a:	3008      	adds	r0, #8
    120c:	6050      	str	r0, [r2, #4]
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    120e:	4a0c      	ldr	r2, [pc, #48]	; (1240 <usb_rx_memory+0x70>)
    1210:	50e2      	str	r2, [r4, r3]
				usb_rx_memory_needed--;
    1212:	4a0c      	ldr	r2, [pc, #48]	; (1244 <usb_rx_memory+0x74>)
    1214:	7813      	ldrb	r3, [r2, #0]
    1216:	3b01      	subs	r3, #1
    1218:	7013      	strb	r3, [r2, #0]
				__enable_irq();
    121a:	b662      	cpsie	i
				//serial_phex(i);
				//serial_print(",odd\n");
				return;
    121c:	e008      	b.n	1230 <usb_rx_memory+0x60>
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    121e:	3201      	adds	r2, #1
    1220:	2a05      	cmp	r2, #5
    1222:	d1dc      	bne.n	11de <usb_rx_memory+0xe>
				//serial_print(",odd\n");
				return;
			}
		}
	}
	__enable_irq();
    1224:	b662      	cpsie	i
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
    1226:	2200      	movs	r2, #0
    1228:	4b06      	ldr	r3, [pc, #24]	; (1244 <usb_rx_memory+0x74>)
    122a:	701a      	strb	r2, [r3, #0]
	usb_free(packet);
    122c:	f000 fbf6 	bl	1a1c <usb_free>
	return;
}
    1230:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1232:	46c0      	nop			; (mov r8, r8)
    1234:	000033f8 	.word	0x000033f8
    1238:	1ffff800 	.word	0x1ffff800
    123c:	00400088 	.word	0x00400088
    1240:	004000c8 	.word	0x004000c8
    1244:	2000078e 	.word	0x2000078e

00001248 <usb_tx>:
void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
    1248:	1e42      	subs	r2, r0, #1

//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
    124a:	b510      	push	{r4, lr}
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
    124c:	2a03      	cmp	r2, #3
    124e:	d830      	bhi.n	12b2 <usb_tx+0x6a>
//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    1250:	2302      	movs	r3, #2
    1252:	0080      	lsls	r0, r0, #2
    1254:	4318      	orrs	r0, r3
    1256:	4b17      	ldr	r3, [pc, #92]	; (12b4 <usb_tx+0x6c>)
    1258:	00c0      	lsls	r0, r0, #3
    125a:	181b      	adds	r3, r3, r0
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
	__disable_irq();
    125c:	b672      	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
    125e:	4c16      	ldr	r4, [pc, #88]	; (12b8 <usb_tx+0x70>)
    1260:	5ca0      	ldrb	r0, [r4, r2]
    1262:	2803      	cmp	r0, #3
    1264:	d80b      	bhi.n	127e <usb_tx+0x36>
    1266:	f001 fa0d 	bl	2684 <__gnu_thumb1_case_uqi>
    126a:	0416      	.short	0x0416
    126c:	0702      	.short	0x0702
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
		next = TX_STATE_EVEN_FREE;
		break;
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
    126e:	2005      	movs	r0, #5
    1270:	e012      	b.n	1298 <usb_tx+0x50>
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
		break;
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
    1272:	3308      	adds	r3, #8
		next = TX_STATE_EVEN_FREE;
    1274:	2002      	movs	r0, #2
		break;
    1276:	e00f      	b.n	1298 <usb_tx+0x50>
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
		break;
	  case TX_STATE_ODD_FREE:
		b++;
    1278:	3308      	adds	r3, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    127a:	2004      	movs	r0, #4
		break;
    127c:	e00c      	b.n	1298 <usb_tx+0x50>
	  default:
		if (tx_first[endpoint] == NULL) {
    127e:	480f      	ldr	r0, [pc, #60]	; (12bc <usb_tx+0x74>)
    1280:	0092      	lsls	r2, r2, #2
    1282:	5814      	ldr	r4, [r2, r0]
    1284:	4b0e      	ldr	r3, [pc, #56]	; (12c0 <usb_tx+0x78>)
    1286:	2c00      	cmp	r4, #0
    1288:	d101      	bne.n	128e <usb_tx+0x46>
			tx_first[endpoint] = packet;
    128a:	5011      	str	r1, [r2, r0]
    128c:	e001      	b.n	1292 <usb_tx+0x4a>
		} else {
			tx_last[endpoint]->next = packet;
    128e:	5898      	ldr	r0, [r3, r2]
    1290:	6041      	str	r1, [r0, #4]
		}
		tx_last[endpoint] = packet;
    1292:	5099      	str	r1, [r3, r2]
    1294:	e00c      	b.n	12b0 <usb_tx+0x68>
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
    1296:	2003      	movs	r0, #3
		}
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
    1298:	54a0      	strb	r0, [r4, r2]
	b->addr = packet->buf;
    129a:	000a      	movs	r2, r1
    129c:	3208      	adds	r2, #8
    129e:	605a      	str	r2, [r3, #4]
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    12a0:	22c8      	movs	r2, #200	; 0xc8
    12a2:	0718      	lsls	r0, r3, #28
    12a4:	d400      	bmi.n	12a8 <usb_tx+0x60>
    12a6:	3a40      	subs	r2, #64	; 0x40
    12a8:	8809      	ldrh	r1, [r1, #0]
    12aa:	0409      	lsls	r1, r1, #16
    12ac:	430a      	orrs	r2, r1
    12ae:	601a      	str	r2, [r3, #0]
	__enable_irq();
    12b0:	b662      	cpsie	i
}
    12b2:	bd10      	pop	{r4, pc}
    12b4:	1ffff800 	.word	0x1ffff800
    12b8:	200006cc 	.word	0x200006cc
    12bc:	20000764 	.word	0x20000764
    12c0:	20000774 	.word	0x20000774

000012c4 <usb_isr>:
#endif
		}
		USB0_ISTAT = USB_ISTAT_SOFTOK;
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    12c4:	2308      	movs	r3, #8
}



void usb_isr(void)
{
    12c6:	b5f0      	push	{r4, r5, r6, r7, lr}
    12c8:	465f      	mov	r7, fp
    12ca:	4644      	mov	r4, r8
    12cc:	4656      	mov	r6, sl
    12ce:	464d      	mov	r5, r9
#endif
		}
		USB0_ISTAT = USB_ISTAT_SOFTOK;
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    12d0:	469b      	mov	fp, r3
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    12d2:	3b07      	subs	r3, #7
    12d4:	4698      	mov	r8, r3
}



void usb_isr(void)
{
    12d6:	b4f0      	push	{r4, r5, r6, r7}
    12d8:	b083      	sub	sp, #12
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    12da:	4bbd      	ldr	r3, [pc, #756]	; (15d0 <usb_isr+0x30c>)
    12dc:	781c      	ldrb	r4, [r3, #0]
    12de:	001d      	movs	r5, r3

	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    12e0:	2304      	movs	r3, #4
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    12e2:	b2e4      	uxtb	r4, r4

	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    12e4:	421c      	tst	r4, r3
    12e6:	d01d      	beq.n	1324 <usb_isr+0x60>
		if (usb_configuration) {
    12e8:	4bba      	ldr	r3, [pc, #744]	; (15d4 <usb_isr+0x310>)
    12ea:	781b      	ldrb	r3, [r3, #0]
    12ec:	2b00      	cmp	r3, #0
    12ee:	d016      	beq.n	131e <usb_isr+0x5a>
			t = usb_reboot_timer;
    12f0:	4ab9      	ldr	r2, [pc, #740]	; (15d8 <usb_isr+0x314>)
    12f2:	7813      	ldrb	r3, [r2, #0]
    12f4:	b2db      	uxtb	r3, r3
			if (t) {
    12f6:	2b00      	cmp	r3, #0
    12f8:	d005      	beq.n	1306 <usb_isr+0x42>
				usb_reboot_timer = --t;
    12fa:	3b01      	subs	r3, #1
    12fc:	b2db      	uxtb	r3, r3
    12fe:	7013      	strb	r3, [r2, #0]
				if (!t) _reboot_Teensyduino_();
    1300:	2b00      	cmp	r3, #0
    1302:	d100      	bne.n	1306 <usb_isr+0x42>


void _reboot_Teensyduino_(void)
{
	// TODO: initialize R0 with a code....
	__asm__ volatile("bkpt");
    1304:	be00      	bkpt	0x0000
			if (t) {
				usb_reboot_timer = --t;
				if (!t) _reboot_Teensyduino_();
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
    1306:	4ab5      	ldr	r2, [pc, #724]	; (15dc <usb_isr+0x318>)
    1308:	7813      	ldrb	r3, [r2, #0]
    130a:	b2db      	uxtb	r3, r3
			if (t) {
    130c:	2b00      	cmp	r3, #0
    130e:	d006      	beq.n	131e <usb_isr+0x5a>
				usb_cdc_transmit_flush_timer = --t;
    1310:	3b01      	subs	r3, #1
    1312:	b2db      	uxtb	r3, r3
    1314:	7013      	strb	r3, [r2, #0]
				if (t == 0) usb_serial_flush_callback();
    1316:	2b00      	cmp	r3, #0
    1318:	d101      	bne.n	131e <usb_isr+0x5a>
    131a:	f000 fd63 	bl	1de4 <usb_serial_flush_callback>
#endif
#ifdef MULTITOUCH_INTERFACE
			usb_touchscreen_update_callback();
#endif
		}
		USB0_ISTAT = USB_ISTAT_SOFTOK;
    131e:	2204      	movs	r2, #4
    1320:	4bab      	ldr	r3, [pc, #684]	; (15d0 <usb_isr+0x30c>)
    1322:	701a      	strb	r2, [r3, #0]
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    1324:	4659      	mov	r1, fp
    1326:	4021      	ands	r1, r4
    1328:	d100      	bne.n	132c <usb_isr+0x68>
    132a:	e269      	b.n	1800 <usb_isr+0x53c>
		uint8_t endpoint;
		stat = USB0_STAT;
    132c:	4bac      	ldr	r3, [pc, #688]	; (15e0 <usb_isr+0x31c>)
    132e:	4cad      	ldr	r4, [pc, #692]	; (15e4 <usb_isr+0x320>)
    1330:	781b      	ldrb	r3, [r3, #0]
    1332:	b2db      	uxtb	r3, r3
    1334:	089e      	lsrs	r6, r3, #2
		//serial_print("token: ep=");
		//serial_phex(stat >> 4);
		//serial_print(stat & 0x08 ? ",tx" : ",rx");
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
    1336:	091d      	lsrs	r5, r3, #4
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    1338:	00f6      	lsls	r6, r6, #3
		//serial_print("token: ep=");
		//serial_phex(stat >> 4);
		//serial_print(stat & 0x08 ? ",tx" : ",rx");
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
    133a:	2d00      	cmp	r5, #0
    133c:	d000      	beq.n	1340 <usb_isr+0x7c>
    133e:	e1ef      	b.n	1720 <usb_isr+0x45c>
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    1340:	19a6      	adds	r6, r4, r6
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    1342:	6833      	ldr	r3, [r6, #0]
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
	//count = b->desc >> 16;
	buf = b->addr;
    1344:	6871      	ldr	r1, [r6, #4]
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    1346:	0698      	lsls	r0, r3, #26
    1348:	0f00      	lsrs	r0, r0, #28
    134a:	3801      	subs	r0, #1
    134c:	280c      	cmp	r0, #12
    134e:	d900      	bls.n	1352 <usb_isr+0x8e>
    1350:	e1e2      	b.n	1718 <usb_isr+0x454>
    1352:	f001 f9a1 	bl	2698 <__gnu_thumb1_case_uhi>
    1356:	01a4      	.short	0x01a4
    1358:	01e101a4 	.word	0x01e101a4
    135c:	01e101e1 	.word	0x01e101e1
    1360:	01e101e1 	.word	0x01e101e1
    1364:	01bd01e1 	.word	0x01bd01e1
    1368:	01e101e1 	.word	0x01e101e1
    136c:	000d01e1 	.word	0x000d01e1
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    1370:	684b      	ldr	r3, [r1, #4]
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    1372:	4d9d      	ldr	r5, [pc, #628]	; (15e8 <usb_isr+0x324>)
    1374:	680a      	ldr	r2, [r1, #0]
		setup.word2 = *(uint32_t *)(buf + 4);
    1376:	606b      	str	r3, [r5, #4]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    1378:	4b9c      	ldr	r3, [pc, #624]	; (15ec <usb_isr+0x328>)
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    137a:	499d      	ldr	r1, [pc, #628]	; (15f0 <usb_isr+0x32c>)
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    137c:	469a      	mov	sl, r3
    137e:	2300      	movs	r3, #0
    1380:	4650      	mov	r0, sl
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    1382:	6031      	str	r1, [r6, #0]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    1384:	4646      	mov	r6, r8
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    1386:	6003      	str	r3, [r0, #0]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    1388:	489a      	ldr	r0, [pc, #616]	; (15f4 <usb_isr+0x330>)
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    138a:	602a      	str	r2, [r5, #0]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    138c:	7006      	strb	r6, [r0, #0]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    138e:	489a      	ldr	r0, [pc, #616]	; (15f8 <usb_isr+0x334>)
    1390:	b292      	uxth	r2, r2
			//serial_print("leftover tx even\n");
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
    1392:	6123      	str	r3, [r4, #16]
		table[index(0, TX, ODD)].desc = 0;
    1394:	61a3      	str	r3, [r4, #24]
    1396:	9101      	str	r1, [sp, #4]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    1398:	4282      	cmp	r2, r0
    139a:	d818      	bhi.n	13ce <usb_isr+0x10a>
    139c:	21d0      	movs	r1, #208	; 0xd0
    139e:	00c9      	lsls	r1, r1, #3
    13a0:	428a      	cmp	r2, r1
    13a2:	d300      	bcc.n	13a6 <usb_isr+0xe2>
    13a4:	e0f3      	b.n	158e <usb_isr+0x2ca>
    13a6:	2181      	movs	r1, #129	; 0x81
    13a8:	0049      	lsls	r1, r1, #1
    13aa:	428a      	cmp	r2, r1
    13ac:	d100      	bne.n	13b0 <usb_isr+0xec>
    13ae:	e0ce      	b.n	154e <usb_isr+0x28a>
    13b0:	d806      	bhi.n	13c0 <usb_isr+0xfc>
    13b2:	2a80      	cmp	r2, #128	; 0x80
    13b4:	d100      	bne.n	13b8 <usb_isr+0xf4>
    13b6:	e0b2      	b.n	151e <usb_isr+0x25a>
    13b8:	2a82      	cmp	r2, #130	; 0x82
    13ba:	d100      	bne.n	13be <usb_isr+0xfa>
    13bc:	e0b4      	b.n	1528 <usb_isr+0x264>
    13be:	e103      	b.n	15c8 <usb_isr+0x304>
    13c0:	4b8e      	ldr	r3, [pc, #568]	; (15fc <usb_isr+0x338>)
    13c2:	429a      	cmp	r2, r3
    13c4:	d100      	bne.n	13c8 <usb_isr+0x104>
    13c6:	e0d2      	b.n	156e <usb_isr+0x2aa>
    13c8:	33ff      	adds	r3, #255	; 0xff
    13ca:	33ff      	adds	r3, #255	; 0xff
    13cc:	e01c      	b.n	1408 <usb_isr+0x144>
    13ce:	498c      	ldr	r1, [pc, #560]	; (1600 <usb_isr+0x33c>)
    13d0:	428a      	cmp	r2, r1
    13d2:	d100      	bne.n	13d6 <usb_isr+0x112>
    13d4:	e160      	b.n	1698 <usb_isr+0x3d4>
    13d6:	d812      	bhi.n	13fe <usb_isr+0x13a>
    13d8:	2388      	movs	r3, #136	; 0x88
    13da:	011b      	lsls	r3, r3, #4
    13dc:	429a      	cmp	r2, r3
    13de:	d100      	bne.n	13e2 <usb_isr+0x11e>
    13e0:	e097      	b.n	1512 <usb_isr+0x24e>
    13e2:	3380      	adds	r3, #128	; 0x80
    13e4:	429a      	cmp	r2, r3
    13e6:	d000      	beq.n	13ea <usb_isr+0x126>
    13e8:	e0ee      	b.n	15c8 <usb_isr+0x304>
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
    13ea:	4b7a      	ldr	r3, [pc, #488]	; (15d4 <usb_isr+0x310>)
    13ec:	78aa      	ldrb	r2, [r5, #2]
    13ee:	0026      	movs	r6, r4
    13f0:	701a      	strb	r2, [r3, #0]
    13f2:	23a0      	movs	r3, #160	; 0xa0
    13f4:	4699      	mov	r9, r3
    13f6:	3620      	adds	r6, #32
    13f8:	44a1      	add	r9, r4
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
			if (table[i].desc & BDT_OWN) {
    13fa:	2780      	movs	r7, #128	; 0x80
    13fc:	e008      	b.n	1410 <usb_isr+0x14c>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    13fe:	4981      	ldr	r1, [pc, #516]	; (1604 <usb_isr+0x340>)
    1400:	428a      	cmp	r2, r1
    1402:	d100      	bne.n	1406 <usb_isr+0x142>
    1404:	e0d8      	b.n	15b8 <usb_isr+0x2f4>
    1406:	4b80      	ldr	r3, [pc, #512]	; (1608 <usb_isr+0x344>)
    1408:	429a      	cmp	r2, r3
    140a:	d100      	bne.n	140e <usb_isr+0x14a>
    140c:	e11e      	b.n	164c <usb_isr+0x388>
    140e:	e0db      	b.n	15c8 <usb_isr+0x304>
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
			if (table[i].desc & BDT_OWN) {
    1410:	6833      	ldr	r3, [r6, #0]
    1412:	423b      	tst	r3, r7
    1414:	d003      	beq.n	141e <usb_isr+0x15a>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    1416:	6870      	ldr	r0, [r6, #4]
    1418:	3808      	subs	r0, #8
    141a:	f000 faff 	bl	1a1c <usb_free>
    141e:	3608      	adds	r6, #8
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    1420:	454e      	cmp	r6, r9
    1422:	d1f5      	bne.n	1410 <usb_isr+0x14c>
    1424:	2600      	movs	r6, #0
    1426:	0037      	movs	r7, r6
    1428:	46b1      	mov	r9, r6
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    142a:	4b78      	ldr	r3, [pc, #480]	; (160c <usb_isr+0x348>)
    142c:	58f0      	ldr	r0, [r6, r3]
			while (p) {
    142e:	2800      	cmp	r0, #0
    1430:	d004      	beq.n	143c <usb_isr+0x178>
				n = p->next;
    1432:	6846      	ldr	r6, [r0, #4]
				usb_free(p);
    1434:	f000 faf2 	bl	1a1c <usb_free>
				p = n;
    1438:	0030      	movs	r0, r6
    143a:	e7f8      	b.n	142e <usb_isr+0x16a>
    143c:	464e      	mov	r6, r9
			}
			rx_first[i] = NULL;
    143e:	4b73      	ldr	r3, [pc, #460]	; (160c <usb_isr+0x348>)
    1440:	5198      	str	r0, [r3, r6]
			rx_last[i] = NULL;
    1442:	4b73      	ldr	r3, [pc, #460]	; (1610 <usb_isr+0x34c>)
    1444:	50f0      	str	r0, [r6, r3]
			p = tx_first[i];
    1446:	4b73      	ldr	r3, [pc, #460]	; (1614 <usb_isr+0x350>)
    1448:	4699      	mov	r9, r3
    144a:	58f0      	ldr	r0, [r6, r3]
			while (p) {
    144c:	2800      	cmp	r0, #0
    144e:	d005      	beq.n	145c <usb_isr+0x198>
				n = p->next;
    1450:	6843      	ldr	r3, [r0, #4]
    1452:	9300      	str	r3, [sp, #0]
				usb_free(p);
    1454:	f000 fae2 	bl	1a1c <usb_free>
				p = n;
    1458:	9800      	ldr	r0, [sp, #0]
    145a:	e7f7      	b.n	144c <usb_isr+0x188>
			}
			tx_first[i] = NULL;
    145c:	464b      	mov	r3, r9
    145e:	5198      	str	r0, [r3, r6]
			tx_last[i] = NULL;
    1460:	4b6d      	ldr	r3, [pc, #436]	; (1618 <usb_isr+0x354>)
			usb_rx_byte_count_data[i] = 0;
    1462:	4a6e      	ldr	r2, [pc, #440]	; (161c <usb_isr+0x358>)
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    1464:	50f0      	str	r0, [r6, r3]
			usb_rx_byte_count_data[i] = 0;
    1466:	007b      	lsls	r3, r7, #1
    1468:	52d0      	strh	r0, [r2, r3]
			switch (tx_state[i]) {
    146a:	4b6d      	ldr	r3, [pc, #436]	; (1620 <usb_isr+0x35c>)
    146c:	5cf8      	ldrb	r0, [r7, r3]
    146e:	3802      	subs	r0, #2
    1470:	2803      	cmp	r0, #3
    1472:	d807      	bhi.n	1484 <usb_isr+0x1c0>
    1474:	f001 f906 	bl	2684 <__gnu_thumb1_case_uqi>
    1478:	04020402 	.word	0x04020402
			  case TX_STATE_EVEN_FREE:
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    147c:	2200      	movs	r2, #0
    147e:	e000      	b.n	1482 <usb_isr+0x1be>
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    1480:	4642      	mov	r2, r8
    1482:	55da      	strb	r2, [r3, r7]
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
    1484:	3701      	adds	r7, #1
    1486:	3604      	adds	r6, #4
    1488:	2f04      	cmp	r7, #4
    148a:	d1cd      	bne.n	1428 <usb_isr+0x164>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    148c:	2300      	movs	r3, #0
    148e:	4f65      	ldr	r7, [pc, #404]	; (1624 <usb_isr+0x360>)
    1490:	703b      	strb	r3, [r7, #0]
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    1492:	3301      	adds	r3, #1
    1494:	4699      	mov	r9, r3
			epconf = *cfg++;
    1496:	464a      	mov	r2, r9
    1498:	4b63      	ldr	r3, [pc, #396]	; (1628 <usb_isr+0x364>)
    149a:	4964      	ldr	r1, [pc, #400]	; (162c <usb_isr+0x368>)
    149c:	3a01      	subs	r2, #1
    149e:	444b      	add	r3, r9
    14a0:	5c8a      	ldrb	r2, [r1, r2]
    14a2:	009b      	lsls	r3, r3, #2
			*reg = epconf;
    14a4:	701a      	strb	r2, [r3, #0]
    14a6:	464b      	mov	r3, r9
    14a8:	009e      	lsls	r6, r3, #2
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    14aa:	465b      	mov	r3, fp
    14ac:	421a      	tst	r2, r3
    14ae:	d020      	beq.n	14f2 <usb_isr+0x22e>
				usb_packet_t *p;
				p = usb_malloc();
    14b0:	f000 fa94 	bl	19dc <usb_malloc>
    14b4:	464b      	mov	r3, r9
    14b6:	015b      	lsls	r3, r3, #5
				if (p) {
    14b8:	2800      	cmp	r0, #0
    14ba:	d005      	beq.n	14c8 <usb_isr+0x204>
					table[index(i, RX, EVEN)].addr = p->buf;
    14bc:	18e2      	adds	r2, r4, r3
    14be:	3008      	adds	r0, #8
    14c0:	6050      	str	r0, [r2, #4]
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    14c2:	4a5b      	ldr	r2, [pc, #364]	; (1630 <usb_isr+0x36c>)
    14c4:	50e2      	str	r2, [r4, r3]
    14c6:	e003      	b.n	14d0 <usb_isr+0x20c>
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    14c8:	50e0      	str	r0, [r4, r3]
					usb_rx_memory_needed++;
    14ca:	783b      	ldrb	r3, [r7, #0]
    14cc:	3301      	adds	r3, #1
    14ce:	703b      	strb	r3, [r7, #0]
				}
				p = usb_malloc();
    14d0:	f000 fa84 	bl	19dc <usb_malloc>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    14d4:	4643      	mov	r3, r8
    14d6:	4333      	orrs	r3, r6
    14d8:	00db      	lsls	r3, r3, #3
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
    14da:	2800      	cmp	r0, #0
    14dc:	d005      	beq.n	14ea <usb_isr+0x226>
					table[index(i, RX, ODD)].addr = p->buf;
    14de:	18e2      	adds	r2, r4, r3
    14e0:	3008      	adds	r0, #8
    14e2:	6050      	str	r0, [r2, #4]
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    14e4:	9a01      	ldr	r2, [sp, #4]
    14e6:	50e2      	str	r2, [r4, r3]
    14e8:	e003      	b.n	14f2 <usb_isr+0x22e>
				} else {
					table[index(i, RX, ODD)].desc = 0;
    14ea:	50e0      	str	r0, [r4, r3]
					usb_rx_memory_needed++;
    14ec:	783b      	ldrb	r3, [r7, #0]
    14ee:	3301      	adds	r3, #1
    14f0:	703b      	strb	r3, [r7, #0]
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    14f2:	2202      	movs	r2, #2
    14f4:	2300      	movs	r3, #0
    14f6:	4332      	orrs	r2, r6
    14f8:	00d2      	lsls	r2, r2, #3
    14fa:	50a3      	str	r3, [r4, r2]
			table[index(i, TX, ODD)].desc = 0;
    14fc:	2203      	movs	r2, #3
    14fe:	4316      	orrs	r6, r2
    1500:	4096      	lsls	r6, r2
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    1502:	3a02      	subs	r2, #2
    1504:	4694      	mov	ip, r2
    1506:	44e1      	add	r9, ip
    1508:	464a      	mov	r2, r9
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
			table[index(i, TX, ODD)].desc = 0;
    150a:	51a3      	str	r3, [r4, r6]
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    150c:	2a05      	cmp	r2, #5
    150e:	d1c2      	bne.n	1496 <usb_isr+0x1d2>
    1510:	e09d      	b.n	164e <usb_isr+0x38a>
			}
#endif
		}
		break;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    1512:	4b30      	ldr	r3, [pc, #192]	; (15d4 <usb_isr+0x310>)
    1514:	4c47      	ldr	r4, [pc, #284]	; (1634 <usb_isr+0x370>)
    1516:	781b      	ldrb	r3, [r3, #0]
    1518:	7023      	strb	r3, [r4, #0]
		datalen = 1;
    151a:	2301      	movs	r3, #1
    151c:	e098      	b.n	1650 <usb_isr+0x38c>
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    151e:	4c45      	ldr	r4, [pc, #276]	; (1634 <usb_isr+0x370>)
    1520:	7023      	strb	r3, [r4, #0]
		reply_buffer[1] = 0;
    1522:	7063      	strb	r3, [r4, #1]
		datalen = 2;
    1524:	2302      	movs	r3, #2
    1526:	e093      	b.n	1650 <usb_isr+0x38c>
    1528:	227f      	movs	r2, #127	; 0x7f
    152a:	88a9      	ldrh	r1, [r5, #4]
    152c:	400a      	ands	r2, r1
		data = reply_buffer;
		break;
	  case 0x0082: // GET_STATUS (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS) {
    152e:	2a04      	cmp	r2, #4
    1530:	d84a      	bhi.n	15c8 <usb_isr+0x304>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    1532:	4c40      	ldr	r4, [pc, #256]	; (1634 <usb_isr+0x370>)
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    1534:	0092      	lsls	r2, r2, #2
		if (i > NUM_ENDPOINTS) {
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    1536:	7023      	strb	r3, [r4, #0]
		reply_buffer[1] = 0;
    1538:	7063      	strb	r3, [r4, #1]
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    153a:	4b3f      	ldr	r3, [pc, #252]	; (1638 <usb_isr+0x374>)
    153c:	469c      	mov	ip, r3
    153e:	2302      	movs	r3, #2
    1540:	4462      	add	r2, ip
    1542:	7812      	ldrb	r2, [r2, #0]
    1544:	421a      	tst	r2, r3
    1546:	d100      	bne.n	154a <usb_isr+0x286>
    1548:	e082      	b.n	1650 <usb_isr+0x38c>
    154a:	7026      	strb	r6, [r4, #0]
    154c:	e080      	b.n	1650 <usb_isr+0x38c>
    154e:	237f      	movs	r3, #127	; 0x7f
    1550:	88aa      	ldrh	r2, [r5, #4]
    1552:	401a      	ands	r2, r3
		data = reply_buffer;
		datalen = 2;
		break;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    1554:	2a04      	cmp	r2, #4
    1556:	d837      	bhi.n	15c8 <usb_isr+0x304>
    1558:	886b      	ldrh	r3, [r5, #2]
    155a:	2b00      	cmp	r3, #0
    155c:	d134      	bne.n	15c8 <usb_isr+0x304>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
    155e:	4936      	ldr	r1, [pc, #216]	; (1638 <usb_isr+0x374>)
    1560:	2002      	movs	r0, #2
    1562:	468c      	mov	ip, r1
    1564:	0092      	lsls	r2, r2, #2
    1566:	4462      	add	r2, ip
    1568:	7811      	ldrb	r1, [r2, #0]
    156a:	4381      	bics	r1, r0
    156c:	e02a      	b.n	15c4 <usb_isr+0x300>
    156e:	237f      	movs	r3, #127	; 0x7f
    1570:	88aa      	ldrh	r2, [r5, #4]
    1572:	401a      	ands	r2, r3
		// TODO: do we need to clear the data toggle here?
		break;
	  case 0x0302: // SET_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    1574:	2a04      	cmp	r2, #4
    1576:	d827      	bhi.n	15c8 <usb_isr+0x304>
    1578:	886b      	ldrh	r3, [r5, #2]
    157a:	2b00      	cmp	r3, #0
    157c:	d124      	bne.n	15c8 <usb_isr+0x304>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) |= 0x02;
    157e:	492e      	ldr	r1, [pc, #184]	; (1638 <usb_isr+0x374>)
    1580:	2002      	movs	r0, #2
    1582:	468c      	mov	ip, r1
    1584:	0092      	lsls	r2, r2, #2
    1586:	4462      	add	r2, ip
    1588:	7811      	ldrb	r1, [r2, #0]
    158a:	4301      	orrs	r1, r0
    158c:	e01a      	b.n	15c4 <usb_isr+0x300>
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    158e:	886a      	ldrh	r2, [r5, #2]
    1590:	88a9      	ldrh	r1, [r5, #4]
    1592:	4b2a      	ldr	r3, [pc, #168]	; (163c <usb_isr+0x378>)
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
    1594:	685c      	ldr	r4, [r3, #4]
    1596:	2c00      	cmp	r4, #0
    1598:	d016      	beq.n	15c8 <usb_isr+0x304>
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    159a:	8818      	ldrh	r0, [r3, #0]
    159c:	4290      	cmp	r0, r2
    159e:	d109      	bne.n	15b4 <usb_isr+0x2f0>
    15a0:	8858      	ldrh	r0, [r3, #2]
    15a2:	4288      	cmp	r0, r1
    15a4:	d106      	bne.n	15b4 <usb_isr+0x2f0>
				data = list->addr;
				if ((setup.wValue >> 8) == 3) {
    15a6:	0a12      	lsrs	r2, r2, #8
    15a8:	2a03      	cmp	r2, #3
    15aa:	d101      	bne.n	15b0 <usb_isr+0x2ec>
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured
					// length.
					datalen = *(list->addr);
    15ac:	7823      	ldrb	r3, [r4, #0]
    15ae:	e04f      	b.n	1650 <usb_isr+0x38c>
				} else {
					datalen = list->length;
    15b0:	891b      	ldrh	r3, [r3, #8]
    15b2:	e04d      	b.n	1650 <usb_isr+0x38c>
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
    15b4:	330c      	adds	r3, #12
    15b6:	e7ed      	b.n	1594 <usb_isr+0x2d0>
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
#if defined(CDC_STATUS_INTERFACE)
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		usb_cdc_line_rtsdtr_millis = systick_millis_count;
    15b8:	4a21      	ldr	r2, [pc, #132]	; (1640 <usb_isr+0x37c>)
    15ba:	6811      	ldr	r1, [r2, #0]
    15bc:	4a21      	ldr	r2, [pc, #132]	; (1644 <usb_isr+0x380>)
    15be:	6011      	str	r1, [r2, #0]
		usb_cdc_line_rtsdtr = setup.wValue;
    15c0:	78a9      	ldrb	r1, [r5, #2]
    15c2:	4a21      	ldr	r2, [pc, #132]	; (1648 <usb_isr+0x384>)
    15c4:	7011      	strb	r1, [r2, #0]
    15c6:	e042      	b.n	164e <usb_isr+0x38a>
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    15c8:	220f      	movs	r2, #15
    15ca:	4b1b      	ldr	r3, [pc, #108]	; (1638 <usb_isr+0x374>)
    15cc:	701a      	strb	r2, [r3, #0]
    15ce:	e063      	b.n	1698 <usb_isr+0x3d4>
    15d0:	40072080 	.word	0x40072080
    15d4:	20000798 	.word	0x20000798
    15d8:	20000721 	.word	0x20000721
    15dc:	2000079a 	.word	0x2000079a
    15e0:	40072090 	.word	0x40072090
    15e4:	1ffff800 	.word	0x1ffff800
    15e8:	20000784 	.word	0x20000784
    15ec:	200006b8 	.word	0x200006b8
    15f0:	004000c8 	.word	0x004000c8
    15f4:	20000799 	.word	0x20000799
    15f8:	00000681 	.word	0x00000681
    15fc:	00000302 	.word	0x00000302
    1600:	00002021 	.word	0x00002021
    1604:	00002221 	.word	0x00002221
    1608:	00002321 	.word	0x00002321
    160c:	20000710 	.word	0x20000710
    1610:	200006bc 	.word	0x200006bc
    1614:	20000764 	.word	0x20000764
    1618:	20000774 	.word	0x20000774
    161c:	20000980 	.word	0x20000980
    1620:	200006cc 	.word	0x200006cc
    1624:	2000078e 	.word	0x2000078e
    1628:	1001c830 	.word	0x1001c830
    162c:	000033f8 	.word	0x000033f8
    1630:	00400088 	.word	0x00400088
    1634:	20000790 	.word	0x20000790
    1638:	400720c0 	.word	0x400720c0
    163c:	000033fc 	.word	0x000033fc
    1640:	200006b4 	.word	0x200006b4
    1644:	20000990 	.word	0x20000990
    1648:	200007a8 	.word	0x200007a8
static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
	uint32_t datalen = 0;
    164c:	2300      	movs	r3, #0

static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
    164e:	001c      	movs	r4, r3
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    1650:	88ed      	ldrh	r5, [r5, #6]
    1652:	429d      	cmp	r5, r3
    1654:	d900      	bls.n	1658 <usb_isr+0x394>
    1656:	001d      	movs	r5, r3
    1658:	002e      	movs	r6, r5
    165a:	2d40      	cmp	r5, #64	; 0x40
    165c:	d900      	bls.n	1660 <usb_isr+0x39c>
    165e:	2640      	movs	r6, #64	; 0x40
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
    1660:	0020      	movs	r0, r4
    1662:	0031      	movs	r1, r6
    1664:	f7ff fd68 	bl	1138 <endpoint0_transmit>
	data += size;
    1668:	19a4      	adds	r4, r4, r6
	datalen -= size;
    166a:	1bad      	subs	r5, r5, r6
	if (datalen == 0 && size < EP0_SIZE) return;
    166c:	d103      	bne.n	1676 <usb_isr+0x3b2>
    166e:	002f      	movs	r7, r5
    1670:	2e40      	cmp	r6, #64	; 0x40
    1672:	d004      	beq.n	167e <usb_isr+0x3ba>
    1674:	e010      	b.n	1698 <usb_isr+0x3d4>
    1676:	2740      	movs	r7, #64	; 0x40
    1678:	42af      	cmp	r7, r5
    167a:	d900      	bls.n	167e <usb_isr+0x3ba>
    167c:	002f      	movs	r7, r5

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
    167e:	0020      	movs	r0, r4
    1680:	0039      	movs	r1, r7
    1682:	f7ff fd59 	bl	1138 <endpoint0_transmit>
	data += size;
    1686:	19e4      	adds	r4, r4, r7
	datalen -= size;
    1688:	1bed      	subs	r5, r5, r7
	if (datalen == 0 && size < EP0_SIZE) return;
    168a:	d101      	bne.n	1690 <usb_isr+0x3cc>
    168c:	2f40      	cmp	r7, #64	; 0x40
    168e:	d103      	bne.n	1698 <usb_isr+0x3d4>

	ep0_tx_ptr = data;
    1690:	4653      	mov	r3, sl
    1692:	601c      	str	r4, [r3, #0]
	ep0_tx_len = datalen;
    1694:	4b79      	ldr	r3, [pc, #484]	; (187c <usb_isr+0x5b8>)
    1696:	801d      	strh	r5, [r3, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    1698:	4b79      	ldr	r3, [pc, #484]	; (1880 <usb_isr+0x5bc>)
    169a:	4642      	mov	r2, r8
    169c:	e03b      	b.n	1716 <usb_isr+0x452>
		break;
	case 0x01:  // OUT transaction received from host
	case 0x02:
		//serial_print("PID=OUT\n");
#ifdef CDC_STATUS_INTERFACE
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    169e:	4a79      	ldr	r2, [pc, #484]	; (1884 <usb_isr+0x5c0>)
    16a0:	4b79      	ldr	r3, [pc, #484]	; (1888 <usb_isr+0x5c4>)
    16a2:	8812      	ldrh	r2, [r2, #0]
    16a4:	429a      	cmp	r2, r3
    16a6:	d110      	bne.n	16ca <usb_isr+0x406>
    16a8:	2300      	movs	r3, #0
			int i;
			uint8_t *dst = (uint8_t *)usb_cdc_line_coding;
			//serial_print("set line coding ");
			for (i=0; i<7; i++) {
				//serial_phex(*buf);
				*dst++ = *buf++;
    16aa:	4a78      	ldr	r2, [pc, #480]	; (188c <usb_isr+0x5c8>)
    16ac:	5cc8      	ldrb	r0, [r1, r3]
    16ae:	54d0      	strb	r0, [r2, r3]
#ifdef CDC_STATUS_INTERFACE
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
			int i;
			uint8_t *dst = (uint8_t *)usb_cdc_line_coding;
			//serial_print("set line coding ");
			for (i=0; i<7; i++) {
    16b0:	3301      	adds	r3, #1
    16b2:	2b07      	cmp	r3, #7
    16b4:	d1fa      	bne.n	16ac <usb_isr+0x3e8>
				//serial_phex(*buf);
				*dst++ = *buf++;
			}
			//serial_phex32(usb_cdc_line_coding[0]);
			//serial_print("\n");
			if (usb_cdc_line_coding[0] == 134) usb_reboot_timer = 15;
    16b6:	6813      	ldr	r3, [r2, #0]
    16b8:	2b86      	cmp	r3, #134	; 0x86
    16ba:	d102      	bne.n	16c2 <usb_isr+0x3fe>
    16bc:	220f      	movs	r2, #15
    16be:	4b74      	ldr	r3, [pc, #464]	; (1890 <usb_isr+0x5cc>)
    16c0:	701a      	strb	r2, [r3, #0]
			endpoint0_transmit(NULL, 0);
    16c2:	2100      	movs	r1, #0
    16c4:	0008      	movs	r0, r1
    16c6:	f7ff fd37 	bl	1138 <endpoint0_transmit>
		if (usb_audio_set_feature(&setup, buf)) {
			endpoint0_transmit(NULL, 0);
		}
#endif
		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    16ca:	4b72      	ldr	r3, [pc, #456]	; (1894 <usb_isr+0x5d0>)
    16cc:	6033      	str	r3, [r6, #0]
    16ce:	e023      	b.n	1718 <usb_isr+0x454>
		//serial_print("PID=IN:");
		//serial_phex(stat);
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
    16d0:	4f71      	ldr	r7, [pc, #452]	; (1898 <usb_isr+0x5d4>)
    16d2:	683e      	ldr	r6, [r7, #0]
		if (data) {
    16d4:	2e00      	cmp	r6, #0
    16d6:	d014      	beq.n	1702 <usb_isr+0x43e>
			size = ep0_tx_len;
    16d8:	4b68      	ldr	r3, [pc, #416]	; (187c <usb_isr+0x5b8>)
    16da:	881c      	ldrh	r4, [r3, #0]
    16dc:	4699      	mov	r9, r3
    16de:	0025      	movs	r5, r4
    16e0:	2c40      	cmp	r4, #64	; 0x40
    16e2:	d900      	bls.n	16e6 <usb_isr+0x422>
    16e4:	2540      	movs	r5, #64	; 0x40
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
    16e6:	0029      	movs	r1, r5
    16e8:	0030      	movs	r0, r6
    16ea:	f7ff fd25 	bl	1138 <endpoint0_transmit>
			data += size;
			ep0_tx_len -= size;
    16ee:	464b      	mov	r3, r9
    16f0:	1b64      	subs	r4, r4, r5
    16f2:	b2a4      	uxth	r4, r4
    16f4:	801c      	strh	r4, [r3, #0]
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    16f6:	2c00      	cmp	r4, #0
    16f8:	d101      	bne.n	16fe <usb_isr+0x43a>
    16fa:	2d40      	cmp	r5, #64	; 0x40
    16fc:	d100      	bne.n	1700 <usb_isr+0x43c>
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
    16fe:	1974      	adds	r4, r6, r5
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    1700:	603c      	str	r4, [r7, #0]
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
    1702:	22a0      	movs	r2, #160	; 0xa0
    1704:	4b5f      	ldr	r3, [pc, #380]	; (1884 <usb_isr+0x5c0>)
    1706:	00d2      	lsls	r2, r2, #3
    1708:	8819      	ldrh	r1, [r3, #0]
    170a:	4291      	cmp	r1, r2
    170c:	d104      	bne.n	1718 <usb_isr+0x454>
			setup.bRequest = 0;
    170e:	2200      	movs	r2, #0
    1710:	705a      	strb	r2, [r3, #1]
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    1712:	789a      	ldrb	r2, [r3, #2]
    1714:	4b61      	ldr	r3, [pc, #388]	; (189c <usb_isr+0x5d8>)
    1716:	701a      	strb	r2, [r3, #0]
	//default:
		//serial_print("PID=unknown:");
		//serial_phex(pid);
		//serial_print("\n");
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    1718:	4642      	mov	r2, r8
    171a:	4b59      	ldr	r3, [pc, #356]	; (1880 <usb_isr+0x5bc>)
    171c:	701a      	strb	r2, [r3, #0]
    171e:	e06b      	b.n	17f8 <usb_isr+0x534>
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    1720:	465a      	mov	r2, fp
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
    1722:	19a4      	adds	r4, r4, r6
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    1724:	6860      	ldr	r0, [r4, #4]
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    1726:	3d01      	subs	r5, #1
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    1728:	3808      	subs	r0, #8
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    172a:	b2ed      	uxtb	r5, r5
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    172c:	4013      	ands	r3, r2
    172e:	d037      	beq.n	17a0 <usb_isr+0x4dc>
				usb_free(packet);
    1730:	f000 f974 	bl	1a1c <usb_free>
				packet = tx_first[endpoint];
    1734:	4a5a      	ldr	r2, [pc, #360]	; (18a0 <usb_isr+0x5dc>)
    1736:	00a9      	lsls	r1, r5, #2
    1738:	588e      	ldr	r6, [r1, r2]
    173a:	4b5a      	ldr	r3, [pc, #360]	; (18a4 <usb_isr+0x5e0>)
				if (packet) {
    173c:	2e00      	cmp	r6, #0
    173e:	d01c      	beq.n	177a <usb_isr+0x4b6>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    1740:	6870      	ldr	r0, [r6, #4]
    1742:	5088      	str	r0, [r1, r2]
					b->addr = packet->buf;
    1744:	0032      	movs	r2, r6
					switch (tx_state[endpoint]) {
    1746:	5d58      	ldrb	r0, [r3, r5]
				usb_free(packet);
				packet = tx_first[endpoint];
				if (packet) {
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
					b->addr = packet->buf;
    1748:	3208      	adds	r2, #8
    174a:	6062      	str	r2, [r4, #4]
					switch (tx_state[endpoint]) {
    174c:	2803      	cmp	r0, #3
    174e:	d80b      	bhi.n	1768 <usb_isr+0x4a4>
    1750:	f000 ff98 	bl	2684 <__gnu_thumb1_case_uqi>
    1754:	08060402 	.word	0x08060402
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
    1758:	2203      	movs	r2, #3
    175a:	e004      	b.n	1766 <usb_isr+0x4a2>
						break;
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
    175c:	2202      	movs	r2, #2
    175e:	e002      	b.n	1766 <usb_isr+0x4a2>
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
    1760:	2205      	movs	r2, #5
    1762:	e000      	b.n	1766 <usb_isr+0x4a2>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
    1764:	2204      	movs	r2, #4
    1766:	555a      	strb	r2, [r3, r5]
						break;
					  default:
						break;
					}
					b->desc = BDT_DESC(packet->len,
    1768:	465a      	mov	r2, fp
    176a:	23c8      	movs	r3, #200	; 0xc8
    176c:	4214      	tst	r4, r2
    176e:	d100      	bne.n	1772 <usb_isr+0x4ae>
    1770:	3b40      	subs	r3, #64	; 0x40
    1772:	8832      	ldrh	r2, [r6, #0]
    1774:	0412      	lsls	r2, r2, #16
    1776:	4313      	orrs	r3, r2
    1778:	e03d      	b.n	17f6 <usb_isr+0x532>
						((uint32_t)b & 8) ? DATA1 : DATA0);
				} else {
					//serial_print("tx no packet\n");
					switch (tx_state[endpoint]) {
    177a:	5d58      	ldrb	r0, [r3, r5]
    177c:	2803      	cmp	r0, #3
    177e:	d808      	bhi.n	1792 <usb_isr+0x4ce>
    1780:	f000 ff80 	bl	2684 <__gnu_thumb1_case_uqi>
    1784:	04023a3a 	.word	0x04023a3a
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    1788:	2200      	movs	r2, #0
    178a:	e000      	b.n	178e <usb_isr+0x4ca>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    178c:	4642      	mov	r2, r8
    178e:	555a      	strb	r2, [r3, r5]
						break;
    1790:	e032      	b.n	17f8 <usb_isr+0x534>
					  default:
						tx_state[endpoint] = ((uint32_t)b & 8) ?
    1792:	465a      	mov	r2, fp
    1794:	4014      	ands	r4, r2
    1796:	1e62      	subs	r2, r4, #1
    1798:	4194      	sbcs	r4, r2
    179a:	3402      	adds	r4, #2
    179c:	555c      	strb	r4, [r3, r5]
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
    179e:	e02b      	b.n	17f8 <usb_isr+0x534>
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
    17a0:	6822      	ldr	r2, [r4, #0]
    17a2:	0c12      	lsrs	r2, r2, #16
    17a4:	b291      	uxth	r1, r2
    17a6:	8001      	strh	r1, [r0, #0]
				if (packet->len > 0) {
    17a8:	2a00      	cmp	r2, #0
    17aa:	d01e      	beq.n	17ea <usb_isr+0x526>
					packet->index = 0;
					packet->next = NULL;
					if (rx_first[endpoint] == NULL) {
    17ac:	4e3e      	ldr	r6, [pc, #248]	; (18a8 <usb_isr+0x5e4>)
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
				if (packet->len > 0) {
					packet->index = 0;
    17ae:	8043      	strh	r3, [r0, #2]
					packet->next = NULL;
    17b0:	6043      	str	r3, [r0, #4]
					if (rx_first[endpoint] == NULL) {
    17b2:	00ab      	lsls	r3, r5, #2
    17b4:	599f      	ldr	r7, [r3, r6]
    17b6:	4a3d      	ldr	r2, [pc, #244]	; (18ac <usb_isr+0x5e8>)
    17b8:	2f00      	cmp	r7, #0
    17ba:	d101      	bne.n	17c0 <usb_isr+0x4fc>
						//serial_print("rx 1st, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_first[endpoint] = packet;
    17bc:	5198      	str	r0, [r3, r6]
    17be:	e001      	b.n	17c4 <usb_isr+0x500>
						//serial_print("rx Nth, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
    17c0:	58d6      	ldr	r6, [r2, r3]
    17c2:	6070      	str	r0, [r6, #4]
					}
					rx_last[endpoint] = packet;
    17c4:	50d0      	str	r0, [r2, r3]
					usb_rx_byte_count_data[endpoint] += packet->len;
    17c6:	4a3a      	ldr	r2, [pc, #232]	; (18b0 <usb_isr+0x5ec>)
    17c8:	006d      	lsls	r5, r5, #1
    17ca:	5aab      	ldrh	r3, [r5, r2]
    17cc:	18cb      	adds	r3, r1, r3
    17ce:	52ab      	strh	r3, [r5, r2]
					// TODO: implement a per-endpoint maximum # of allocated
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
    17d0:	f000 f904 	bl	19dc <usb_malloc>
					if (packet) {
    17d4:	2800      	cmp	r0, #0
    17d6:	d002      	beq.n	17de <usb_isr+0x51a>
						b->addr = packet->buf;
    17d8:	3008      	adds	r0, #8
    17da:	6060      	str	r0, [r4, #4]
    17dc:	e005      	b.n	17ea <usb_isr+0x526>
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
    17de:	4a35      	ldr	r2, [pc, #212]	; (18b4 <usb_isr+0x5f0>)
						b->desc = BDT_DESC(64,
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
    17e0:	6020      	str	r0, [r4, #0]
						usb_rx_memory_needed++;
    17e2:	7813      	ldrb	r3, [r2, #0]
    17e4:	3301      	adds	r3, #1
    17e6:	7013      	strb	r3, [r2, #0]
    17e8:	e006      	b.n	17f8 <usb_isr+0x534>
					}
				} else {
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    17ea:	465b      	mov	r3, fp
    17ec:	421c      	tst	r4, r3
    17ee:	d101      	bne.n	17f4 <usb_isr+0x530>
    17f0:	4b31      	ldr	r3, [pc, #196]	; (18b8 <usb_isr+0x5f4>)
    17f2:	e000      	b.n	17f6 <usb_isr+0x532>
    17f4:	4b27      	ldr	r3, [pc, #156]	; (1894 <usb_isr+0x5d0>)
    17f6:	6023      	str	r3, [r4, #0]
				}
			}

		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    17f8:	465a      	mov	r2, fp
    17fa:	4b30      	ldr	r3, [pc, #192]	; (18bc <usb_isr+0x5f8>)
    17fc:	701a      	strb	r2, [r3, #0]
		goto restart;
    17fe:	e56c      	b.n	12da <usb_isr+0x16>
	}



	if (status & USB_ISTAT_USBRST /* 01 */ ) {
    1800:	2601      	movs	r6, #1
    1802:	4234      	tst	r4, r6
    1804:	d01e      	beq.n	1844 <usb_isr+0x580>
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    1806:	2302      	movs	r3, #2
    1808:	481d      	ldr	r0, [pc, #116]	; (1880 <usb_isr+0x5bc>)
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    180a:	4a2b      	ldr	r2, [pc, #172]	; (18b8 <usb_isr+0x5f4>)

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    180c:	7003      	strb	r3, [r0, #0]
		ep0_tx_bdt_bank = 0;
    180e:	4b2c      	ldr	r3, [pc, #176]	; (18c0 <usb_isr+0x5fc>)

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    1810:	4c2c      	ldr	r4, [pc, #176]	; (18c4 <usb_isr+0x600>)
	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;
    1812:	7019      	strb	r1, [r3, #0]

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    1814:	4b2c      	ldr	r3, [pc, #176]	; (18c8 <usb_isr+0x604>)
    1816:	601a      	str	r2, [r3, #0]
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
    1818:	609a      	str	r2, [r3, #8]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    181a:	4a2c      	ldr	r2, [pc, #176]	; (18cc <usb_isr+0x608>)
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    181c:	605c      	str	r4, [r3, #4]
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    181e:	60da      	str	r2, [r3, #12]
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    1820:	220d      	movs	r2, #13
		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
    1822:	6119      	str	r1, [r3, #16]
		table[index(0, TX, ODD)].desc = 0;
    1824:	6199      	str	r1, [r3, #24]

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    1826:	4b2a      	ldr	r3, [pc, #168]	; (18d0 <usb_isr+0x60c>)
    1828:	701a      	strb	r2, [r3, #0]

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    182a:	23ff      	movs	r3, #255	; 0xff
    182c:	4a29      	ldr	r2, [pc, #164]	; (18d4 <usb_isr+0x610>)
    182e:	7013      	strb	r3, [r2, #0]
		USB0_ISTAT = 0xFF;

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    1830:	4a1a      	ldr	r2, [pc, #104]	; (189c <usb_isr+0x5d8>)
		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
		USB0_ISTAT = 0xFF;
    1832:	702b      	strb	r3, [r5, #0]

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    1834:	7011      	strb	r1, [r2, #0]

		// enable other interrupts
		USB0_ERREN = 0xFF;
    1836:	4a28      	ldr	r2, [pc, #160]	; (18d8 <usb_isr+0x614>)
    1838:	7013      	strb	r3, [r2, #0]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    183a:	229f      	movs	r2, #159	; 0x9f
    183c:	4b27      	ldr	r3, [pc, #156]	; (18dc <usb_isr+0x618>)
    183e:	701a      	strb	r2, [r3, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    1840:	7006      	strb	r6, [r0, #0]
		return;
    1842:	e013      	b.n	186c <usb_isr+0x5a8>
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
    1844:	b263      	sxtb	r3, r4
    1846:	2b00      	cmp	r3, #0
    1848:	da04      	bge.n	1854 <usb_isr+0x590>
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    184a:	220d      	movs	r2, #13
    184c:	4b20      	ldr	r3, [pc, #128]	; (18d0 <usb_isr+0x60c>)
    184e:	701a      	strb	r2, [r3, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    1850:	2380      	movs	r3, #128	; 0x80
    1852:	702b      	strb	r3, [r5, #0]
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    1854:	2202      	movs	r2, #2
    1856:	4214      	tst	r4, r2
    1858:	d004      	beq.n	1864 <usb_isr+0x5a0>
		uint8_t err = USB0_ERRSTAT;
    185a:	491e      	ldr	r1, [pc, #120]	; (18d4 <usb_isr+0x610>)
    185c:	780b      	ldrb	r3, [r1, #0]
    185e:	b2db      	uxtb	r3, r3
		USB0_ERRSTAT = err;
    1860:	700b      	strb	r3, [r1, #0]
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    1862:	702a      	strb	r2, [r5, #0]
	}

	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
    1864:	2310      	movs	r3, #16
    1866:	421c      	tst	r4, r3
    1868:	d000      	beq.n	186c <usb_isr+0x5a8>
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
    186a:	702b      	strb	r3, [r5, #0]
	}

}
    186c:	b003      	add	sp, #12
    186e:	bc3c      	pop	{r2, r3, r4, r5}
    1870:	4690      	mov	r8, r2
    1872:	4699      	mov	r9, r3
    1874:	46a2      	mov	sl, r4
    1876:	46ab      	mov	fp, r5
    1878:	bdf0      	pop	{r4, r5, r6, r7, pc}
    187a:	46c0      	nop			; (mov r8, r8)
    187c:	2000078c 	.word	0x2000078c
    1880:	40072094 	.word	0x40072094
    1884:	20000784 	.word	0x20000784
    1888:	00002021 	.word	0x00002021
    188c:	20000988 	.word	0x20000988
    1890:	20000721 	.word	0x20000721
    1894:	004000c8 	.word	0x004000c8
    1898:	200006b8 	.word	0x200006b8
    189c:	40072098 	.word	0x40072098
    18a0:	20000764 	.word	0x20000764
    18a4:	200006cc 	.word	0x200006cc
    18a8:	20000710 	.word	0x20000710
    18ac:	200006bc 	.word	0x200006bc
    18b0:	20000980 	.word	0x20000980
    18b4:	2000078e 	.word	0x2000078e
    18b8:	00400088 	.word	0x00400088
    18bc:	40072080 	.word	0x40072080
    18c0:	20000720 	.word	0x20000720
    18c4:	200006d0 	.word	0x200006d0
    18c8:	1ffff800 	.word	0x1ffff800
    18cc:	20000724 	.word	0x20000724
    18d0:	400720c0 	.word	0x400720c0
    18d4:	40072088 	.word	0x40072088
    18d8:	4007208c 	.word	0x4007208c
    18dc:	40072084 	.word	0x40072084

000018e0 <usb_init>:



void usb_init(void)
{
    18e0:	b510      	push	{r4, lr}
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    18e2:	f000 fe5f 	bl	25a4 <usb_init_serialnumber>
    18e6:	2200      	movs	r2, #0

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
		table[i].desc = 0;
    18e8:	0011      	movs	r1, r2
    18ea:	4b1b      	ldr	r3, [pc, #108]	; (1958 <usb_init+0x78>)
    18ec:	50d1      	str	r1, [r2, r3]
		table[i].addr = 0;
    18ee:	1898      	adds	r0, r3, r2
    18f0:	3208      	adds	r2, #8
    18f2:	6041      	str	r1, [r0, #4]
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
    18f4:	2a88      	cmp	r2, #136	; 0x88
    18f6:	d1f9      	bne.n	18ec <usb_init+0xc>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    18f8:	2080      	movs	r0, #128	; 0x80
    18fa:	4918      	ldr	r1, [pc, #96]	; (195c <usb_init+0x7c>)
    18fc:	02c0      	lsls	r0, r0, #11
    18fe:	680a      	ldr	r2, [r1, #0]
    1900:	4302      	orrs	r2, r0
    1902:	600a      	str	r2, [r1, #0]
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    1904:	0a1a      	lsrs	r2, r3, #8
    1906:	4916      	ldr	r1, [pc, #88]	; (1960 <usb_init+0x80>)
    1908:	b2d2      	uxtb	r2, r2
    190a:	700a      	strb	r2, [r1, #0]
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    190c:	0c1a      	lsrs	r2, r3, #16
    190e:	4915      	ldr	r1, [pc, #84]	; (1964 <usb_init+0x84>)
    1910:	b2d2      	uxtb	r2, r2
    1912:	700a      	strb	r2, [r1, #0]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    1914:	4a14      	ldr	r2, [pc, #80]	; (1968 <usb_init+0x88>)
    1916:	0e1b      	lsrs	r3, r3, #24
    1918:	7013      	strb	r3, [r2, #0]

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    191a:	23ff      	movs	r3, #255	; 0xff
    191c:	4a13      	ldr	r2, [pc, #76]	; (196c <usb_init+0x8c>)

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
    191e:	2000      	movs	r0, #0
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    1920:	7013      	strb	r3, [r2, #0]
	USB0_ERRSTAT = 0xFF;
    1922:	4a13      	ldr	r2, [pc, #76]	; (1970 <usb_init+0x90>)
	USB0_OTGISTAT = 0xFF;

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    1924:	4913      	ldr	r1, [pc, #76]	; (1974 <usb_init+0x94>)
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
    1926:	7013      	strb	r3, [r2, #0]
	USB0_OTGISTAT = 0xFF;
    1928:	4a13      	ldr	r2, [pc, #76]	; (1978 <usb_init+0x98>)
    192a:	7013      	strb	r3, [r2, #0]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    192c:	2201      	movs	r2, #1
    192e:	700a      	strb	r2, [r1, #0]
	USB0_USBCTRL = 0;
    1930:	4912      	ldr	r1, [pc, #72]	; (197c <usb_init+0x9c>)
    1932:	7008      	strb	r0, [r1, #0]

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;
    1934:	4912      	ldr	r1, [pc, #72]	; (1980 <usb_init+0xa0>)
    1936:	700a      	strb	r2, [r1, #0]

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    1938:	4a12      	ldr	r2, [pc, #72]	; (1984 <usb_init+0xa4>)
    193a:	6811      	ldr	r1, [r2, #0]
    193c:	4399      	bics	r1, r3
    193e:	000b      	movs	r3, r1
    1940:	2170      	movs	r1, #112	; 0x70
    1942:	430b      	orrs	r3, r1
    1944:	6013      	str	r3, [r2, #0]
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    1946:	2280      	movs	r2, #128	; 0x80
    1948:	4b0f      	ldr	r3, [pc, #60]	; (1988 <usb_init+0xa8>)
    194a:	0452      	lsls	r2, r2, #17
    194c:	601a      	str	r2, [r3, #0]

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    194e:	2210      	movs	r2, #16
    1950:	4b0e      	ldr	r3, [pc, #56]	; (198c <usb_init+0xac>)
    1952:	701a      	strb	r2, [r3, #0]
}
    1954:	bd10      	pop	{r4, pc}
    1956:	46c0      	nop			; (mov r8, r8)
    1958:	1ffff800 	.word	0x1ffff800
    195c:	40048034 	.word	0x40048034
    1960:	4007209c 	.word	0x4007209c
    1964:	400720b0 	.word	0x400720b0
    1968:	400720b4 	.word	0x400720b4
    196c:	40072080 	.word	0x40072080
    1970:	40072088 	.word	0x40072088
    1974:	40072094 	.word	0x40072094
    1978:	40072010 	.word	0x40072010
    197c:	40072100 	.word	0x40072100
    1980:	40072084 	.word	0x40072084
    1984:	e000e418 	.word	0xe000e418
    1988:	e000e100 	.word	0xe000e100
    198c:	40072108 	.word	0x40072108

00001990 <usb_serial_class::clear()>:
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
    1990:	b510      	push	{r4, lr}
    1992:	f000 f8bb 	bl	1b0c <usb_serial_flush_input>
    1996:	bd10      	pop	{r4, pc}

00001998 <usb_serial_class::peek()>:
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
    1998:	b510      	push	{r4, lr}
    199a:	f000 f88d 	bl	1ab8 <usb_serial_peekchar>
    199e:	bd10      	pop	{r4, pc}

000019a0 <usb_serial_class::read()>:
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    19a0:	b510      	push	{r4, lr}
    19a2:	f000 f863 	bl	1a6c <usb_serial_getchar>
    19a6:	bd10      	pop	{r4, pc}

000019a8 <usb_serial_class::available()>:
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    19a8:	b510      	push	{r4, lr}
    19aa:	f000 f89f 	bl	1aec <usb_serial_available>
    19ae:	bd10      	pop	{r4, pc}

000019b0 <usb_serial_class::flush()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    19b0:	b510      	push	{r4, lr}
    19b2:	f000 f9e9 	bl	1d88 <usb_serial_flush_output>
    19b6:	bd10      	pop	{r4, pc}

000019b8 <usb_serial_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
	size_t write(unsigned long n) { return write((uint8_t)n); }
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    19b8:	b510      	push	{r4, lr}
    19ba:	f000 f9bd 	bl	1d38 <usb_serial_write_buffer_free>
    19be:	bd10      	pop	{r4, pc}

000019c0 <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    19c0:	b510      	push	{r4, lr}
    19c2:	0008      	movs	r0, r1
    19c4:	0011      	movs	r1, r2
    19c6:	f000 f8bf 	bl	1b48 <usb_serial_write>
    19ca:	bd10      	pop	{r4, pc}

000019cc <usb_serial_class::write(unsigned char)>:
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    19cc:	b510      	push	{r4, lr}
    19ce:	0008      	movs	r0, r1
    19d0:	f000 f9a6 	bl	1d20 <usb_serial_putchar>
    19d4:	bd10      	pop	{r4, pc}
    19d6:	46c0      	nop			; (mov r8, r8)

000019d8 <serialEvent()>:
#endif

#endif // F_CPU

void serialEvent() __attribute__((weak));
void serialEvent() {}
    19d8:	4770      	bx	lr
    19da:	46c0      	nop			; (mov r8, r8)

000019dc <usb_malloc>:
// http://www.archivum.info/gnu.gcc.help/2006-08/00148/Re-GCC-Inline-Assembly.html
// http://gcc.gnu.org/ml/gcc/2012-06/msg00015.html
// __builtin_clz()

usb_packet_t * usb_malloc(void)
{
    19dc:	b570      	push	{r4, r5, r6, lr}
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    19de:	b672      	cpsid	i
	avail = usb_buffer_available;
    19e0:	4d0c      	ldr	r5, [pc, #48]	; (1a14 <usb_malloc+0x38>)
    19e2:	682c      	ldr	r4, [r5, #0]
	n = __builtin_clz(avail); // clz = count leading zeros
    19e4:	0020      	movs	r0, r4
    19e6:	f000 feed 	bl	27c4 <__clzsi2>
	if (n >= NUM_USB_BUFFERS) {
    19ea:	280b      	cmp	r0, #11
    19ec:	dc0e      	bgt.n	1a0c <usb_malloc+0x30>
	}
	//serial_print("malloc:");
	//serial_phex(n);
	//serial_print("\n");

	usb_buffer_available = avail & ~(0x80000000 >> n);
    19ee:	2380      	movs	r3, #128	; 0x80
    19f0:	061b      	lsls	r3, r3, #24
    19f2:	40c3      	lsrs	r3, r0
    19f4:	439c      	bics	r4, r3
    19f6:	602c      	str	r4, [r5, #0]
	__enable_irq();
    19f8:	b662      	cpsie	i
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
    19fa:	00c3      	lsls	r3, r0, #3
    19fc:	1818      	adds	r0, r3, r0
    19fe:	4b06      	ldr	r3, [pc, #24]	; (1a18 <usb_malloc+0x3c>)
    1a00:	00c0      	lsls	r0, r0, #3
    1a02:	1818      	adds	r0, r3, r0
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
    1a04:	2300      	movs	r3, #0
    1a06:	6003      	str	r3, [r0, #0]
	*(uint32_t *)(p + 4) = 0;
    1a08:	6043      	str	r3, [r0, #4]
	return (usb_packet_t *)p;
}
    1a0a:	bd70      	pop	{r4, r5, r6, pc}

	__disable_irq();
	avail = usb_buffer_available;
	n = __builtin_clz(avail); // clz = count leading zeros
	if (n >= NUM_USB_BUFFERS) {
		__enable_irq();
    1a0c:	b662      	cpsie	i
		return NULL;
    1a0e:	2000      	movs	r0, #0
    1a10:	e7fb      	b.n	1a0a <usb_malloc+0x2e>
    1a12:	46c0      	nop			; (mov r8, r8)
    1a14:	1ffffda0 	.word	0x1ffffda0
    1a18:	1ffff9c0 	.word	0x1ffff9c0

00001a1c <usb_free>:
// for the receive endpoints to request memory
extern uint8_t usb_rx_memory_needed;
extern void usb_rx_memory(usb_packet_t *packet);

void usb_free(usb_packet_t *p)
{
    1a1c:	b510      	push	{r4, lr}
    1a1e:	0004      	movs	r4, r0
	unsigned int n, mask;

	//serial_print("free:");
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    1a20:	480e      	ldr	r0, [pc, #56]	; (1a5c <usb_free+0x40>)
    1a22:	2148      	movs	r1, #72	; 0x48
    1a24:	1a20      	subs	r0, r4, r0
    1a26:	f000 fe41 	bl	26ac <__aeabi_uidiv>
	if (n >= NUM_USB_BUFFERS) return;
    1a2a:	280b      	cmp	r0, #11
    1a2c:	d80c      	bhi.n	1a48 <usb_free+0x2c>
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    1a2e:	4b0c      	ldr	r3, [pc, #48]	; (1a60 <usb_free+0x44>)
    1a30:	781b      	ldrb	r3, [r3, #0]
    1a32:	2b00      	cmp	r3, #0
    1a34:	d109      	bne.n	1a4a <usb_free+0x2e>
		usb_rx_memory(p);
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
    1a36:	b672      	cpsid	i
	usb_buffer_available |= mask;
    1a38:	2380      	movs	r3, #128	; 0x80
    1a3a:	061b      	lsls	r3, r3, #24
    1a3c:	40c3      	lsrs	r3, r0
    1a3e:	4a09      	ldr	r2, [pc, #36]	; (1a64 <usb_free+0x48>)
    1a40:	6811      	ldr	r1, [r2, #0]
    1a42:	430b      	orrs	r3, r1
    1a44:	6013      	str	r3, [r2, #0]
	__enable_irq();
    1a46:	b662      	cpsie	i

	//serial_print("free:");
	//serial_phex32((int)p);
	//serial_print("\n");
}
    1a48:	bd10      	pop	{r4, pc}
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    1a4a:	4b07      	ldr	r3, [pc, #28]	; (1a68 <usb_free+0x4c>)
    1a4c:	781b      	ldrb	r3, [r3, #0]
    1a4e:	2b00      	cmp	r3, #0
    1a50:	d0f1      	beq.n	1a36 <usb_free+0x1a>
		//serial_print("give to rx:");
		//serial_phex32((int)p);
		//serial_print("\n");
		usb_rx_memory(p);
    1a52:	0020      	movs	r0, r4
    1a54:	f7ff fbbc 	bl	11d0 <usb_rx_memory>
		return;
    1a58:	e7f6      	b.n	1a48 <usb_free+0x2c>
    1a5a:	46c0      	nop			; (mov r8, r8)
    1a5c:	1ffff9c0 	.word	0x1ffff9c0
    1a60:	2000078e 	.word	0x2000078e
    1a64:	1ffffda0 	.word	0x1ffffda0
    1a68:	20000798 	.word	0x20000798

00001a6c <usb_serial_getchar>:

#define TRANSMIT_FLUSH_TIMEOUT	5   /* in milliseconds */

// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    1a6c:	b570      	push	{r4, r5, r6, lr}
	unsigned int i;
	int c;

	if (!rx_packet) {
    1a6e:	4d10      	ldr	r5, [pc, #64]	; (1ab0 <usb_serial_getchar+0x44>)
    1a70:	6828      	ldr	r0, [r5, #0]
    1a72:	2800      	cmp	r0, #0
    1a74:	d00f      	beq.n	1a96 <usb_serial_getchar+0x2a>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
    1a76:	8843      	ldrh	r3, [r0, #2]
	c = rx_packet->buf[i++];
    1a78:	1c5a      	adds	r2, r3, #1
    1a7a:	18c3      	adds	r3, r0, r3
    1a7c:	7a1c      	ldrb	r4, [r3, #8]
	if (i >= rx_packet->len) {
    1a7e:	8803      	ldrh	r3, [r0, #0]
    1a80:	429a      	cmp	r2, r3
    1a82:	d202      	bcs.n	1a8a <usb_serial_getchar+0x1e>
		usb_free(rx_packet);
		rx_packet = NULL;
	} else {
		rx_packet->index = i;
    1a84:	8042      	strh	r2, [r0, #2]
	}
	return c;
    1a86:	0020      	movs	r0, r4
}
    1a88:	bd70      	pop	{r4, r5, r6, pc}
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
    1a8a:	f7ff ffc7 	bl	1a1c <usb_free>
		rx_packet = NULL;
    1a8e:	2300      	movs	r3, #0
	} else {
		rx_packet->index = i;
	}
	return c;
    1a90:	0020      	movs	r0, r4
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
		rx_packet = NULL;
    1a92:	602b      	str	r3, [r5, #0]
    1a94:	e7f8      	b.n	1a88 <usb_serial_getchar+0x1c>
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    1a96:	4b07      	ldr	r3, [pc, #28]	; (1ab4 <usb_serial_getchar+0x48>)
    1a98:	781b      	ldrb	r3, [r3, #0]
    1a9a:	2b00      	cmp	r3, #0
    1a9c:	d005      	beq.n	1aaa <usb_serial_getchar+0x3e>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    1a9e:	2003      	movs	r0, #3
    1aa0:	f7ff fb6a 	bl	1178 <usb_rx>
    1aa4:	6028      	str	r0, [r5, #0]
		if (!rx_packet) return -1;
    1aa6:	2800      	cmp	r0, #0
    1aa8:	d1e5      	bne.n	1a76 <usb_serial_getchar+0xa>
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    1aaa:	2001      	movs	r0, #1
    1aac:	4240      	negs	r0, r0
    1aae:	e7eb      	b.n	1a88 <usb_serial_getchar+0x1c>
    1ab0:	200007a4 	.word	0x200007a4
    1ab4:	20000798 	.word	0x20000798

00001ab8 <usb_serial_peekchar>:
	return c;
}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
    1ab8:	b510      	push	{r4, lr}
	if (!rx_packet) {
    1aba:	4c0a      	ldr	r4, [pc, #40]	; (1ae4 <usb_serial_peekchar+0x2c>)
    1abc:	6820      	ldr	r0, [r4, #0]
    1abe:	2800      	cmp	r0, #0
    1ac0:	d003      	beq.n	1aca <usb_serial_peekchar+0x12>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	if (!rx_packet) return -1;
	return rx_packet->buf[rx_packet->index];
    1ac2:	8843      	ldrh	r3, [r0, #2]
    1ac4:	18c0      	adds	r0, r0, r3
    1ac6:	7a00      	ldrb	r0, [r0, #8]
}
    1ac8:	bd10      	pop	{r4, pc}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    1aca:	4b07      	ldr	r3, [pc, #28]	; (1ae8 <usb_serial_peekchar+0x30>)
    1acc:	781b      	ldrb	r3, [r3, #0]
    1ace:	2b00      	cmp	r3, #0
    1ad0:	d005      	beq.n	1ade <usb_serial_peekchar+0x26>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    1ad2:	2003      	movs	r0, #3
    1ad4:	f7ff fb50 	bl	1178 <usb_rx>
    1ad8:	6020      	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    1ada:	2800      	cmp	r0, #0
    1adc:	d1f1      	bne.n	1ac2 <usb_serial_peekchar+0xa>

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    1ade:	2001      	movs	r0, #1
    1ae0:	4240      	negs	r0, r0
    1ae2:	e7f1      	b.n	1ac8 <usb_serial_peekchar+0x10>
    1ae4:	200007a4 	.word	0x200007a4
    1ae8:	20000798 	.word	0x20000798

00001aec <usb_serial_available>:
static inline uint32_t usb_rx_byte_count(uint32_t endpoint) __attribute__((always_inline));
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
        endpoint--;
        if (endpoint >= NUM_ENDPOINTS) return 0;
        return usb_rx_byte_count_data[endpoint];
    1aec:	4b05      	ldr	r3, [pc, #20]	; (1b04 <usb_serial_available+0x18>)

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
    1aee:	8898      	ldrh	r0, [r3, #4]
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    1af0:	4b05      	ldr	r3, [pc, #20]	; (1b08 <usb_serial_available+0x1c>)
    1af2:	681b      	ldr	r3, [r3, #0]
    1af4:	2b00      	cmp	r3, #0
    1af6:	d003      	beq.n	1b00 <usb_serial_available+0x14>
    1af8:	881a      	ldrh	r2, [r3, #0]
    1afa:	885b      	ldrh	r3, [r3, #2]
    1afc:	1ad3      	subs	r3, r2, r3
    1afe:	18c0      	adds	r0, r0, r3
	return count;
}
    1b00:	4770      	bx	lr
    1b02:	46c0      	nop			; (mov r8, r8)
    1b04:	20000980 	.word	0x20000980
    1b08:	200007a4 	.word	0x200007a4

00001b0c <usb_serial_flush_input>:
	return count;
}

// discard any buffered input
void usb_serial_flush_input(void)
{
    1b0c:	b510      	push	{r4, lr}
	usb_packet_t *rx;

	if (!usb_configuration) return;
    1b0e:	4b0c      	ldr	r3, [pc, #48]	; (1b40 <usb_serial_flush_input+0x34>)
    1b10:	781b      	ldrb	r3, [r3, #0]
    1b12:	2b00      	cmp	r3, #0
    1b14:	d013      	beq.n	1b3e <usb_serial_flush_input+0x32>
	if (rx_packet) {
    1b16:	4c0b      	ldr	r4, [pc, #44]	; (1b44 <usb_serial_flush_input+0x38>)
    1b18:	6820      	ldr	r0, [r4, #0]
    1b1a:	2800      	cmp	r0, #0
    1b1c:	d00a      	beq.n	1b34 <usb_serial_flush_input+0x28>
		usb_free(rx_packet);
    1b1e:	f7ff ff7d 	bl	1a1c <usb_free>
		rx_packet = NULL;
    1b22:	2300      	movs	r3, #0
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    1b24:	2003      	movs	r0, #3
	usb_packet_t *rx;

	if (!usb_configuration) return;
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
    1b26:	6023      	str	r3, [r4, #0]
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    1b28:	f7ff fb26 	bl	1178 <usb_rx>
		if (!rx) break;
    1b2c:	2800      	cmp	r0, #0
    1b2e:	d006      	beq.n	1b3e <usb_serial_flush_input+0x32>
		usb_free(rx);
    1b30:	f7ff ff74 	bl	1a1c <usb_free>
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    1b34:	2003      	movs	r0, #3
    1b36:	f7ff fb1f 	bl	1178 <usb_rx>
		if (!rx) break;
    1b3a:	2800      	cmp	r0, #0
    1b3c:	d1f8      	bne.n	1b30 <usb_serial_flush_input+0x24>
		usb_free(rx);
	}
}
    1b3e:	bd10      	pop	{r4, pc}
    1b40:	20000798 	.word	0x20000798
    1b44:	200007a4 	.word	0x200007a4

00001b48 <usb_serial_write>:
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    1b48:	b5f0      	push	{r4, r5, r6, r7, lr}
    1b4a:	464d      	mov	r5, r9
    1b4c:	465f      	mov	r7, fp
    1b4e:	4656      	mov	r6, sl
    1b50:	4644      	mov	r4, r8
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    1b52:	2301      	movs	r3, #1
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    1b54:	b4f0      	push	{r4, r5, r6, r7}
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    1b56:	4a6c      	ldr	r2, [pc, #432]	; (1d08 <usb_serial_write+0x1c0>)
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    1b58:	b085      	sub	sp, #20
    1b5a:	0005      	movs	r5, r0
    1b5c:	9103      	str	r1, [sp, #12]
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    1b5e:	7013      	strb	r3, [r2, #0]
	while (size > 0) {
    1b60:	2900      	cmp	r1, #0
    1b62:	d100      	bne.n	1b66 <usb_serial_write+0x1e>
    1b64:	e085      	b.n	1c72 <usb_serial_write+0x12a>
    1b66:	4b69      	ldr	r3, [pc, #420]	; (1d0c <usb_serial_write+0x1c4>)
    1b68:	000e      	movs	r6, r1
    1b6a:	469b      	mov	fp, r3
    1b6c:	6818      	ldr	r0, [r3, #0]
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    1b6e:	4b68      	ldr	r3, [pc, #416]	; (1d10 <usb_serial_write+0x1c8>)
    1b70:	4698      	mov	r8, r3
    1b72:	e004      	b.n	1b7e <usb_serial_write+0x36>
		if (tx_packet->index >= CDC_TX_SIZE) {
			tx_packet->len = CDC_TX_SIZE;
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    1b74:	2205      	movs	r2, #5
    1b76:	4b67      	ldr	r3, [pc, #412]	; (1d14 <usb_serial_write+0x1cc>)
    1b78:	701a      	strb	r2, [r3, #0]
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    1b7a:	2e00      	cmp	r6, #0
    1b7c:	d078      	beq.n	1c70 <usb_serial_write+0x128>
    1b7e:	4b66      	ldr	r3, [pc, #408]	; (1d18 <usb_serial_write+0x1d0>)
    1b80:	4699      	mov	r9, r3
		if (!tx_packet) {
    1b82:	2800      	cmp	r0, #0
    1b84:	d100      	bne.n	1b88 <usb_serial_write+0x40>
    1b86:	e082      	b.n	1c8e <usb_serial_write+0x146>
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    1b88:	2300      	movs	r3, #0
    1b8a:	464a      	mov	r2, r9
    1b8c:	7013      	strb	r3, [r2, #0]
		len = CDC_TX_SIZE - tx_packet->index;
    1b8e:	8844      	ldrh	r4, [r0, #2]
    1b90:	3340      	adds	r3, #64	; 0x40
    1b92:	1b1b      	subs	r3, r3, r4
    1b94:	42b3      	cmp	r3, r6
    1b96:	d900      	bls.n	1b9a <usb_serial_write+0x52>
    1b98:	0033      	movs	r3, r6
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
    1b9a:	0002      	movs	r2, r0
		tx_packet->index += len;
    1b9c:	18e1      	adds	r1, r4, r3
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
    1b9e:	3208      	adds	r2, #8
    1ba0:	1912      	adds	r2, r2, r4
		tx_packet->index += len;
    1ba2:	b289      	uxth	r1, r1
		size -= len;
		while (len-- > 0) *dest++ = *src++;
    1ba4:	1e5f      	subs	r7, r3, #1
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
    1ba6:	9201      	str	r2, [sp, #4]
		tx_packet->index += len;
    1ba8:	8041      	strh	r1, [r0, #2]
		size -= len;
    1baa:	1af6      	subs	r6, r6, r3
		while (len-- > 0) *dest++ = *src++;
    1bac:	46ba      	mov	sl, r7
    1bae:	2b00      	cmp	r3, #0
    1bb0:	d04d      	beq.n	1c4e <usb_serial_write+0x106>
    1bb2:	0021      	movs	r1, r4
    1bb4:	2700      	movs	r7, #0
    1bb6:	340c      	adds	r4, #12
    1bb8:	3108      	adds	r1, #8
    1bba:	1904      	adds	r4, r0, r4
    1bbc:	46bc      	mov	ip, r7
    1bbe:	1842      	adds	r2, r0, r1
    1bc0:	0039      	movs	r1, r7
    1bc2:	42a5      	cmp	r5, r4
    1bc4:	417f      	adcs	r7, r7
    1bc6:	46b9      	mov	r9, r7
    1bc8:	4667      	mov	r7, ip
    1bca:	1d2c      	adds	r4, r5, #4
    1bcc:	42a2      	cmp	r2, r4
    1bce:	414f      	adcs	r7, r1
    1bd0:	4649      	mov	r1, r9
    1bd2:	003c      	movs	r4, r7
    1bd4:	430c      	orrs	r4, r1
    1bd6:	2109      	movs	r1, #9
    1bd8:	468c      	mov	ip, r1
    1bda:	459c      	cmp	ip, r3
    1bdc:	4189      	sbcs	r1, r1
    1bde:	4249      	negs	r1, r1
    1be0:	4221      	tst	r1, r4
    1be2:	d04c      	beq.n	1c7e <usb_serial_write+0x136>
    1be4:	002c      	movs	r4, r5
    1be6:	4314      	orrs	r4, r2
    1be8:	0017      	movs	r7, r2
    1bea:	07a1      	lsls	r1, r4, #30
    1bec:	d147      	bne.n	1c7e <usb_serial_write+0x136>
    1bee:	1f1c      	subs	r4, r3, #4
    1bf0:	08a4      	lsrs	r4, r4, #2
    1bf2:	1c61      	adds	r1, r4, #1
    1bf4:	468c      	mov	ip, r1
    1bf6:	0089      	lsls	r1, r1, #2
    1bf8:	9102      	str	r1, [sp, #8]
    1bfa:	4651      	mov	r1, sl
    1bfc:	2902      	cmp	r1, #2
    1bfe:	d93c      	bls.n	1c7a <usb_serial_write+0x132>
    1c00:	4699      	mov	r9, r3
    1c02:	2400      	movs	r4, #0
    1c04:	2100      	movs	r1, #0
    1c06:	003b      	movs	r3, r7
    1c08:	9a01      	ldr	r2, [sp, #4]
    1c0a:	592f      	ldr	r7, [r5, r4]
    1c0c:	3101      	adds	r1, #1
    1c0e:	511f      	str	r7, [r3, r4]
    1c10:	3404      	adds	r4, #4
    1c12:	458c      	cmp	ip, r1
    1c14:	d8f9      	bhi.n	1c0a <usb_serial_write+0xc2>
    1c16:	9201      	str	r2, [sp, #4]
    1c18:	9a02      	ldr	r2, [sp, #8]
    1c1a:	4657      	mov	r7, sl
    1c1c:	4694      	mov	ip, r2
    1c1e:	464b      	mov	r3, r9
    1c20:	9c01      	ldr	r4, [sp, #4]
    1c22:	1abf      	subs	r7, r7, r2
    1c24:	4464      	add	r4, ip
    1c26:	18a9      	adds	r1, r5, r2
    1c28:	9401      	str	r4, [sp, #4]
    1c2a:	46ba      	mov	sl, r7
    1c2c:	4293      	cmp	r3, r2
    1c2e:	d00c      	beq.n	1c4a <usb_serial_write+0x102>
    1c30:	780c      	ldrb	r4, [r1, #0]
    1c32:	9a01      	ldr	r2, [sp, #4]
    1c34:	7014      	strb	r4, [r2, #0]
    1c36:	4654      	mov	r4, sl
    1c38:	2c00      	cmp	r4, #0
    1c3a:	d006      	beq.n	1c4a <usb_serial_write+0x102>
    1c3c:	784c      	ldrb	r4, [r1, #1]
    1c3e:	7054      	strb	r4, [r2, #1]
    1c40:	4654      	mov	r4, sl
    1c42:	2c01      	cmp	r4, #1
    1c44:	d001      	beq.n	1c4a <usb_serial_write+0x102>
    1c46:	7889      	ldrb	r1, [r1, #2]
    1c48:	7091      	strb	r1, [r2, #2]
    1c4a:	8841      	ldrh	r1, [r0, #2]
    1c4c:	18ed      	adds	r5, r5, r3
		if (tx_packet->index >= CDC_TX_SIZE) {
    1c4e:	293f      	cmp	r1, #63	; 0x3f
    1c50:	d990      	bls.n	1b74 <usb_serial_write+0x2c>
			tx_packet->len = CDC_TX_SIZE;
    1c52:	2340      	movs	r3, #64	; 0x40
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
    1c54:	0001      	movs	r1, r0
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
		if (tx_packet->index >= CDC_TX_SIZE) {
			tx_packet->len = CDC_TX_SIZE;
    1c56:	8003      	strh	r3, [r0, #0]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
    1c58:	2004      	movs	r0, #4
    1c5a:	f7ff faf5 	bl	1248 <usb_tx>
			tx_packet = NULL;
    1c5e:	2300      	movs	r3, #0
    1c60:	465a      	mov	r2, fp
    1c62:	6013      	str	r3, [r2, #0]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    1c64:	2205      	movs	r2, #5
    1c66:	4b2b      	ldr	r3, [pc, #172]	; (1d14 <usb_serial_write+0x1cc>)
		size -= len;
		while (len-- > 0) *dest++ = *src++;
		if (tx_packet->index >= CDC_TX_SIZE) {
			tx_packet->len = CDC_TX_SIZE;
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
    1c68:	2000      	movs	r0, #0
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    1c6a:	701a      	strb	r2, [r3, #0]
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    1c6c:	2e00      	cmp	r6, #0
    1c6e:	d186      	bne.n	1b7e <usb_serial_write+0x36>
    1c70:	4a25      	ldr	r2, [pc, #148]	; (1d08 <usb_serial_write+0x1c0>)
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
    1c72:	2300      	movs	r3, #0
	return ret;
    1c74:	9803      	ldr	r0, [sp, #12]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
    1c76:	7013      	strb	r3, [r2, #0]
	return ret;
    1c78:	e039      	b.n	1cee <usb_serial_write+0x1a6>
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
    1c7a:	0029      	movs	r1, r5
    1c7c:	e7d8      	b.n	1c30 <usb_serial_write+0xe8>
    1c7e:	2100      	movs	r1, #0
    1c80:	9a01      	ldr	r2, [sp, #4]
    1c82:	5c6c      	ldrb	r4, [r5, r1]
    1c84:	5454      	strb	r4, [r2, r1]
    1c86:	3101      	adds	r1, #1
    1c88:	428b      	cmp	r3, r1
    1c8a:	d1fa      	bne.n	1c82 <usb_serial_write+0x13a>
    1c8c:	e7dd      	b.n	1c4a <usb_serial_write+0x102>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    1c8e:	4643      	mov	r3, r8
    1c90:	781b      	ldrb	r3, [r3, #0]
    1c92:	2b00      	cmp	r3, #0
    1c94:	d032      	beq.n	1cfc <usb_serial_write+0x1b4>
    1c96:	4b20      	ldr	r3, [pc, #128]	; (1d18 <usb_serial_write+0x1d0>)
    1c98:	4c20      	ldr	r4, [pc, #128]	; (1d1c <usb_serial_write+0x1d4>)
    1c9a:	4699      	mov	r9, r3
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
    1c9c:	2301      	movs	r3, #1
    1c9e:	469a      	mov	sl, r3
    1ca0:	e00c      	b.n	1cbc <usb_serial_write+0x174>
    1ca2:	3c01      	subs	r4, #1
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    1ca4:	2c00      	cmp	r4, #0
    1ca6:	d01d      	beq.n	1ce4 <usb_serial_write+0x19c>
    1ca8:	4b1b      	ldr	r3, [pc, #108]	; (1d18 <usb_serial_write+0x1d0>)
    1caa:	781b      	ldrb	r3, [r3, #0]
    1cac:	2b00      	cmp	r3, #0
    1cae:	d119      	bne.n	1ce4 <usb_serial_write+0x19c>
					transmit_previous_timeout = 1;
					return -1;
				}
				yield();
    1cb0:	f000 f8bc 	bl	1e2c <yield>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    1cb4:	4643      	mov	r3, r8
    1cb6:	781b      	ldrb	r3, [r3, #0]
    1cb8:	2b00      	cmp	r3, #0
    1cba:	d01f      	beq.n	1cfc <usb_serial_write+0x1b4>
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
    1cbc:	2004      	movs	r0, #4
    1cbe:	f7ff fa75 	bl	11ac <usb_tx_packet_count>
    1cc2:	2807      	cmp	r0, #7
    1cc4:	d8ed      	bhi.n	1ca2 <usb_serial_write+0x15a>
					tx_noautoflush = 1;
    1cc6:	4652      	mov	r2, sl
    1cc8:	4b0f      	ldr	r3, [pc, #60]	; (1d08 <usb_serial_write+0x1c0>)
    1cca:	701a      	strb	r2, [r3, #0]
					tx_packet = usb_malloc();
    1ccc:	f7ff fe86 	bl	19dc <usb_malloc>
    1cd0:	465b      	mov	r3, fp
    1cd2:	6018      	str	r0, [r3, #0]
					if (tx_packet) break;
    1cd4:	2800      	cmp	r0, #0
    1cd6:	d000      	beq.n	1cda <usb_serial_write+0x192>
    1cd8:	e756      	b.n	1b88 <usb_serial_write+0x40>
					tx_noautoflush = 0;
    1cda:	4b0b      	ldr	r3, [pc, #44]	; (1d08 <usb_serial_write+0x1c0>)
    1cdc:	3c01      	subs	r4, #1
    1cde:	7018      	strb	r0, [r3, #0]
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    1ce0:	2c00      	cmp	r4, #0
    1ce2:	d1e1      	bne.n	1ca8 <usb_serial_write+0x160>
					transmit_previous_timeout = 1;
    1ce4:	2301      	movs	r3, #1
					return -1;
    1ce6:	2001      	movs	r0, #1
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
					transmit_previous_timeout = 1;
    1ce8:	4a0b      	ldr	r2, [pc, #44]	; (1d18 <usb_serial_write+0x1d0>)
					return -1;
    1cea:	4240      	negs	r0, r0
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
					transmit_previous_timeout = 1;
    1cec:	7013      	strb	r3, [r2, #0]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    1cee:	b005      	add	sp, #20
    1cf0:	bc3c      	pop	{r2, r3, r4, r5}
    1cf2:	4690      	mov	r8, r2
    1cf4:	4699      	mov	r9, r3
    1cf6:	46a2      	mov	sl, r4
    1cf8:	46ab      	mov	fp, r5
    1cfa:	bdf0      	pop	{r4, r5, r6, r7, pc}
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    1cfc:	2300      	movs	r3, #0
					return -1;
    1cfe:	2001      	movs	r0, #1
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    1d00:	4a01      	ldr	r2, [pc, #4]	; (1d08 <usb_serial_write+0x1c0>)
					return -1;
    1d02:	4240      	negs	r0, r0
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    1d04:	7013      	strb	r3, [r2, #0]
					return -1;
    1d06:	e7f2      	b.n	1cee <usb_serial_write+0x1a6>
    1d08:	2000079b 	.word	0x2000079b
    1d0c:	2000079c 	.word	0x2000079c
    1d10:	20000798 	.word	0x20000798
    1d14:	2000079a 	.word	0x2000079a
    1d18:	200007a0 	.word	0x200007a0
    1d1c:	00007509 	.word	0x00007509

00001d20 <usb_serial_putchar>:
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    1d20:	b500      	push	{lr}
    1d22:	b083      	sub	sp, #12
    1d24:	466b      	mov	r3, sp
    1d26:	71d8      	strb	r0, [r3, #7]
    1d28:	3307      	adds	r3, #7
	return usb_serial_write(&c, 1);
    1d2a:	2101      	movs	r1, #1
    1d2c:	0018      	movs	r0, r3
    1d2e:	f7ff ff0b 	bl	1b48 <usb_serial_write>
}
    1d32:	b003      	add	sp, #12
    1d34:	bd00      	pop	{pc}
    1d36:	46c0      	nop			; (mov r8, r8)

00001d38 <usb_serial_write_buffer_free>:

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    1d38:	2301      	movs	r3, #1
	tx_noautoflush = 0;
	return ret;
}

int usb_serial_write_buffer_free(void)
{
    1d3a:	b570      	push	{r4, r5, r6, lr}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
    1d3c:	4d0f      	ldr	r5, [pc, #60]	; (1d7c <usb_serial_write_buffer_free+0x44>)

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    1d3e:	4c10      	ldr	r4, [pc, #64]	; (1d80 <usb_serial_write_buffer_free+0x48>)
	if (!tx_packet) {
    1d40:	6828      	ldr	r0, [r5, #0]

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    1d42:	7023      	strb	r3, [r4, #0]
	if (!tx_packet) {
    1d44:	2800      	cmp	r0, #0
    1d46:	d005      	beq.n	1d54 <usb_serial_write_buffer_free+0x1c>
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    1d48:	2340      	movs	r3, #64	; 0x40
    1d4a:	8840      	ldrh	r0, [r0, #2]
    1d4c:	1a18      	subs	r0, r3, r0
	// space we just promised the user could write without blocking?
	// But does this come with other performance downsides?  Could it lead to
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
    1d4e:	2300      	movs	r3, #0
    1d50:	7023      	strb	r3, [r4, #0]
	return len;
}
    1d52:	bd70      	pop	{r4, r5, r6, pc}
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    1d54:	4b0b      	ldr	r3, [pc, #44]	; (1d84 <usb_serial_write_buffer_free+0x4c>)
    1d56:	781b      	ldrb	r3, [r3, #0]
    1d58:	2b00      	cmp	r3, #0
    1d5a:	d103      	bne.n	1d64 <usb_serial_write_buffer_free+0x2c>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
    1d5c:	2300      	movs	r3, #0
			return 0;
    1d5e:	2000      	movs	r0, #0
	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
    1d60:	7023      	strb	r3, [r4, #0]
			return 0;
    1d62:	e7f6      	b.n	1d52 <usb_serial_write_buffer_free+0x1a>
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    1d64:	2004      	movs	r0, #4
    1d66:	f7ff fa21 	bl	11ac <usb_tx_packet_count>
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    1d6a:	2807      	cmp	r0, #7
    1d6c:	d8f6      	bhi.n	1d5c <usb_serial_write_buffer_free+0x24>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
    1d6e:	f7ff fe35 	bl	19dc <usb_malloc>
    1d72:	6028      	str	r0, [r5, #0]
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    1d74:	2800      	cmp	r0, #0
    1d76:	d1e7      	bne.n	1d48 <usb_serial_write_buffer_free+0x10>
    1d78:	e7f0      	b.n	1d5c <usb_serial_write_buffer_free+0x24>
    1d7a:	46c0      	nop			; (mov r8, r8)
    1d7c:	2000079c 	.word	0x2000079c
    1d80:	2000079b 	.word	0x2000079b
    1d84:	20000798 	.word	0x20000798

00001d88 <usb_serial_flush_output>:
	tx_noautoflush = 0;
	return len;
}

void usb_serial_flush_output(void)
{
    1d88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!usb_configuration) return;
    1d8a:	4b12      	ldr	r3, [pc, #72]	; (1dd4 <usb_serial_flush_output+0x4c>)
    1d8c:	781b      	ldrb	r3, [r3, #0]
    1d8e:	2b00      	cmp	r3, #0
    1d90:	d012      	beq.n	1db8 <usb_serial_flush_output+0x30>
	tx_noautoflush = 1;
    1d92:	2701      	movs	r7, #1
	if (tx_packet) {
    1d94:	4e10      	ldr	r6, [pc, #64]	; (1dd8 <usb_serial_flush_output+0x50>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    1d96:	4d11      	ldr	r5, [pc, #68]	; (1ddc <usb_serial_flush_output+0x54>)
	if (tx_packet) {
    1d98:	6834      	ldr	r4, [r6, #0]
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    1d9a:	702f      	strb	r7, [r5, #0]
	if (tx_packet) {
    1d9c:	2c00      	cmp	r4, #0
    1d9e:	d00c      	beq.n	1dba <usb_serial_flush_output+0x32>
		usb_cdc_transmit_flush_timer = 0;
    1da0:	2700      	movs	r7, #0
    1da2:	4b0f      	ldr	r3, [pc, #60]	; (1de0 <usb_serial_flush_output+0x58>)
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    1da4:	0021      	movs	r1, r4
void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
    1da6:	701f      	strb	r7, [r3, #0]
		tx_packet->len = tx_packet->index;
    1da8:	8863      	ldrh	r3, [r4, #2]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    1daa:	2004      	movs	r0, #4
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
    1dac:	8023      	strh	r3, [r4, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    1dae:	f7ff fa4b 	bl	1248 <usb_tx>
		tx_packet = NULL;
    1db2:	6037      	str	r7, [r6, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
	tx_noautoflush = 0;
    1db4:	2300      	movs	r3, #0
    1db6:	702b      	strb	r3, [r5, #0]
}
    1db8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    1dba:	f7ff fe0f 	bl	19dc <usb_malloc>
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    1dbe:	4b08      	ldr	r3, [pc, #32]	; (1de0 <usb_serial_flush_output+0x58>)
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
    1dc0:	2800      	cmp	r0, #0
    1dc2:	d005      	beq.n	1dd0 <usb_serial_flush_output+0x48>
			usb_cdc_transmit_flush_timer = 0;
			usb_tx(CDC_TX_ENDPOINT, tx);
    1dc4:	0001      	movs	r1, r0
    1dc6:	2004      	movs	r0, #4
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    1dc8:	701c      	strb	r4, [r3, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
    1dca:	f7ff fa3d 	bl	1248 <usb_tx>
    1dce:	e7f1      	b.n	1db4 <usb_serial_flush_output+0x2c>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    1dd0:	701f      	strb	r7, [r3, #0]
    1dd2:	e7ef      	b.n	1db4 <usb_serial_flush_output+0x2c>
    1dd4:	20000798 	.word	0x20000798
    1dd8:	2000079c 	.word	0x2000079c
    1ddc:	2000079b 	.word	0x2000079b
    1de0:	2000079a 	.word	0x2000079a

00001de4 <usb_serial_flush_callback>:
	}
	tx_noautoflush = 0;
}

void usb_serial_flush_callback(void)
{
    1de4:	b570      	push	{r4, r5, r6, lr}
	if (tx_noautoflush) return;
    1de6:	4b0e      	ldr	r3, [pc, #56]	; (1e20 <usb_serial_flush_callback+0x3c>)
    1de8:	781c      	ldrb	r4, [r3, #0]
    1dea:	b2e4      	uxtb	r4, r4
    1dec:	2c00      	cmp	r4, #0
    1dee:	d109      	bne.n	1e04 <usb_serial_flush_callback+0x20>
	if (tx_packet) {
    1df0:	4d0c      	ldr	r5, [pc, #48]	; (1e24 <usb_serial_flush_callback+0x40>)
    1df2:	6829      	ldr	r1, [r5, #0]
    1df4:	2900      	cmp	r1, #0
    1df6:	d006      	beq.n	1e06 <usb_serial_flush_callback+0x22>
		tx_packet->len = tx_packet->index;
    1df8:	884b      	ldrh	r3, [r1, #2]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    1dfa:	2004      	movs	r0, #4

void usb_serial_flush_callback(void)
{
	if (tx_noautoflush) return;
	if (tx_packet) {
		tx_packet->len = tx_packet->index;
    1dfc:	800b      	strh	r3, [r1, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    1dfe:	f7ff fa23 	bl	1248 <usb_tx>
		tx_packet = NULL;
    1e02:	602c      	str	r4, [r5, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    1e04:	bd70      	pop	{r4, r5, r6, pc}
	if (tx_packet) {
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    1e06:	f7ff fde9 	bl	19dc <usb_malloc>
		if (tx) {
    1e0a:	2800      	cmp	r0, #0
    1e0c:	d004      	beq.n	1e18 <usb_serial_flush_callback+0x34>
			usb_tx(CDC_TX_ENDPOINT, tx);
    1e0e:	0001      	movs	r1, r0
    1e10:	2004      	movs	r0, #4
    1e12:	f7ff fa19 	bl	1248 <usb_tx>
    1e16:	e7f5      	b.n	1e04 <usb_serial_flush_callback+0x20>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    1e18:	2201      	movs	r2, #1
    1e1a:	4b03      	ldr	r3, [pc, #12]	; (1e28 <usb_serial_flush_callback+0x44>)
    1e1c:	701a      	strb	r2, [r3, #0]
    1e1e:	e7f1      	b.n	1e04 <usb_serial_flush_callback+0x20>
    1e20:	2000079b 	.word	0x2000079b
    1e24:	2000079c 	.word	0x2000079c
    1e28:	2000079a 	.word	0x2000079a

00001e2c <yield>:
#include <Arduino.h>
#include "EventResponder.h"

void yield(void) __attribute__ ((weak));
void yield(void)
{
    1e2c:	b570      	push	{r4, r5, r6, lr}
	static uint8_t running=0;

	if (running) return; // TODO: does this need to be atomic?
    1e2e:	4c25      	ldr	r4, [pc, #148]	; (1ec4 <yield+0x98>)
    1e30:	7823      	ldrb	r3, [r4, #0]
    1e32:	2b00      	cmp	r3, #0
    1e34:	d000      	beq.n	1e38 <yield+0xc>
#if defined(HAS_KINETISK_UART5) || defined (HAS_KINETISK_LPUART0)
	if (Serial6.available()) serialEvent6();
#endif
	running = 0;
	EventResponder::runFromYield();
};
    1e36:	bd70      	pop	{r4, r5, r6, pc}
void yield(void)
{
	static uint8_t running=0;

	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    1e38:	3301      	adds	r3, #1
    1e3a:	7023      	strb	r3, [r4, #0]
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    1e3c:	f7ff fe56 	bl	1aec <usb_serial_available>
	if (Serial.available()) serialEvent();
    1e40:	2800      	cmp	r0, #0
    1e42:	d135      	bne.n	1eb0 <yield+0x84>
	virtual void transmitterEnable(uint8_t pin) { serial_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial_set_rts(pin); }
	virtual bool attachCts(uint8_t pin) { return serial_set_cts(pin); }
	virtual int available(void)     { return serial_available(); }
    1e44:	f000 fa36 	bl	22b4 <serial_available>
	if (Serial1.available()) serialEvent1();
    1e48:	2800      	cmp	r0, #0
    1e4a:	d12e      	bne.n	1eaa <yield+0x7e>
	virtual void transmitterEnable(uint8_t pin) { serial2_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial2_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial2_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial2_set_rts(pin); }
	virtual bool attachCts(uint8_t pin) { return serial2_set_cts(pin); }
	virtual int available(void)     { return serial2_available(); }
    1e4c:	f000 faa8 	bl	23a0 <serial2_available>
	if (Serial2.available()) serialEvent2();
    1e50:	2800      	cmp	r0, #0
    1e52:	d127      	bne.n	1ea4 <yield+0x78>
	virtual void transmitterEnable(uint8_t pin) { serial3_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial3_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial3_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial3_set_rts(pin); }
	virtual bool attachCts(uint8_t pin) { return serial3_set_cts(pin); }
	virtual int available(void)     { return serial3_available(); }
    1e54:	f000 fb1a 	bl	248c <serial3_available>
	if (Serial3.available()) serialEvent3();
    1e58:	2800      	cmp	r0, #0
    1e5a:	d120      	bne.n	1e9e <yield+0x72>
	if (Serial5.available()) serialEvent5();
#endif
#if defined(HAS_KINETISK_UART5) || defined (HAS_KINETISK_LPUART0)
	if (Serial6.available()) serialEvent6();
#endif
	running = 0;
    1e5c:	2300      	movs	r3, #0
    1e5e:	7023      	strb	r3, [r4, #0]

	static void runFromYield() {
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    1e60:	f3ef 8305 	mrs	r3, IPSR
		if (ipsr != 0) return;
    1e64:	2b00      	cmp	r3, #0
    1e66:	d1e6      	bne.n	1e36 <yield+0xa>
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    1e68:	f3ef 8110 	mrs	r1, PRIMASK
		__disable_irq();
    1e6c:	b672      	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    1e6e:	4b16      	ldr	r3, [pc, #88]	; (1ec8 <yield+0x9c>)
    1e70:	6818      	ldr	r0, [r3, #0]
		if (first == nullptr) {
    1e72:	2800      	cmp	r0, #0
    1e74:	d01f      	beq.n	1eb6 <yield+0x8a>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    1e76:	4c15      	ldr	r4, [pc, #84]	; (1ecc <yield+0xa0>)
    1e78:	7822      	ldrb	r2, [r4, #0]
    1e7a:	2a00      	cmp	r2, #0
    1e7c:	d11b      	bne.n	1eb6 <yield+0x8a>
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    1e7e:	2501      	movs	r5, #1
    1e80:	7025      	strb	r5, [r4, #0]
		firstYield = first->_next;
    1e82:	6945      	ldr	r5, [r0, #20]
    1e84:	601d      	str	r5, [r3, #0]
		if (firstYield) {
    1e86:	2d00      	cmp	r5, #0
    1e88:	d019      	beq.n	1ebe <yield+0x92>
			firstYield->_prev = nullptr;
    1e8a:	61aa      	str	r2, [r5, #24]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    1e8c:	2900      	cmp	r1, #0
    1e8e:	d100      	bne.n	1e92 <yield+0x66>
    1e90:	b662      	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    1e92:	2500      	movs	r5, #0
		(*(first->_function))(*first);
    1e94:	6883      	ldr	r3, [r0, #8]
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    1e96:	7745      	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    1e98:	4798      	blx	r3
		runningFromYield = false;
    1e9a:	7025      	strb	r5, [r4, #0]
    1e9c:	e7cb      	b.n	1e36 <yield+0xa>
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
	if (Serial.available()) serialEvent();
	if (Serial1.available()) serialEvent1();
	if (Serial2.available()) serialEvent2();
	if (Serial3.available()) serialEvent3();
    1e9e:	f000 f9a5 	bl	21ec <serialEvent3()>
    1ea2:	e7db      	b.n	1e5c <yield+0x30>

	if (running) return; // TODO: does this need to be atomic?
	running = 1;
	if (Serial.available()) serialEvent();
	if (Serial1.available()) serialEvent1();
	if (Serial2.available()) serialEvent2();
    1ea4:	f000 f9a0 	bl	21e8 <serialEvent2()>
    1ea8:	e7d4      	b.n	1e54 <yield+0x28>
	static uint8_t running=0;

	if (running) return; // TODO: does this need to be atomic?
	running = 1;
	if (Serial.available()) serialEvent();
	if (Serial1.available()) serialEvent1();
    1eaa:	f000 f99b 	bl	21e4 <serialEvent1()>
    1eae:	e7cd      	b.n	1e4c <yield+0x20>
{
	static uint8_t running=0;

	if (running) return; // TODO: does this need to be atomic?
	running = 1;
	if (Serial.available()) serialEvent();
    1eb0:	f7ff fd92 	bl	19d8 <serialEvent()>
    1eb4:	e7c6      	b.n	1e44 <yield+0x18>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    1eb6:	2900      	cmp	r1, #0
    1eb8:	d1bd      	bne.n	1e36 <yield+0xa>
    1eba:	b662      	cpsie	i
    1ebc:	e7bb      	b.n	1e36 <yield+0xa>
		runningFromYield = true;
		firstYield = first->_next;
		if (firstYield) {
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
    1ebe:	4b04      	ldr	r3, [pc, #16]	; (1ed0 <yield+0xa4>)
    1ec0:	601d      	str	r5, [r3, #0]
    1ec2:	e7e3      	b.n	1e8c <yield+0x60>
    1ec4:	200007a9 	.word	0x200007a9
    1ec8:	200007bc 	.word	0x200007bc
    1ecc:	200007c0 	.word	0x200007c0
    1ed0:	200007b8 	.word	0x200007b8

00001ed4 <EventResponder::triggerEvent(int, void*)>:
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
    1ed4:	7f03      	ldrb	r3, [r0, #28]
	}

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
    1ed6:	b510      	push	{r4, lr}
		_status = status;
    1ed8:	6041      	str	r1, [r0, #4]
		_data = data;
    1eda:	60c2      	str	r2, [r0, #12]
		if (_type == EventTypeImmediate) {
    1edc:	2b02      	cmp	r3, #2
    1ede:	d010      	beq.n	1f02 <EventResponder::triggerEvent(int, void*)+0x2e>
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    1ee0:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    1ee4:	b672      	cpsid	i
// TODO: interrupt disable/enable needed in many places!!!

void EventResponder::triggerEventNotImmediate()
{
	bool irq = disableInterrupts();
	if (_triggered == false) {
    1ee6:	7f43      	ldrb	r3, [r0, #29]
    1ee8:	2b00      	cmp	r3, #0
    1eea:	d106      	bne.n	1efa <EventResponder::triggerEvent(int, void*)+0x26>
		// not already triggered
		if (_type == EventTypeYield) {
    1eec:	7f01      	ldrb	r1, [r0, #28]
    1eee:	2901      	cmp	r1, #1
    1ef0:	d00a      	beq.n	1f08 <EventResponder::triggerEvent(int, void*)+0x34>
				_next = nullptr;
				_prev = lastYield;
				_prev->_next = this;
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
    1ef2:	2903      	cmp	r1, #3
    1ef4:	d013      	beq.n	1f1e <EventResponder::triggerEvent(int, void*)+0x4a>
			}
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
		} else {
			// detached, easy :-)
		}
		_triggered = true;
    1ef6:	2301      	movs	r3, #1
    1ef8:	7743      	strb	r3, [r0, #29]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    1efa:	2a00      	cmp	r2, #0
    1efc:	d100      	bne.n	1f00 <EventResponder::triggerEvent(int, void*)+0x2c>
    1efe:	b662      	cpsie	i
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
		}
	}
    1f00:	bd10      	pop	{r4, pc}
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    1f02:	6883      	ldr	r3, [r0, #8]
    1f04:	4798      	blx	r3
    1f06:	e7fb      	b.n	1f00 <EventResponder::triggerEvent(int, void*)+0x2c>
	bool irq = disableInterrupts();
	if (_triggered == false) {
		// not already triggered
		if (_type == EventTypeYield) {
			// normal type, called from yield()
			if (firstYield == nullptr) {
    1f08:	4c12      	ldr	r4, [pc, #72]	; (1f54 <EventResponder::triggerEvent(int, void*)+0x80>)
    1f0a:	6821      	ldr	r1, [r4, #0]
    1f0c:	2900      	cmp	r1, #0
    1f0e:	d015      	beq.n	1f3c <EventResponder::triggerEvent(int, void*)+0x68>
				_next = nullptr;
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
    1f10:	6143      	str	r3, [r0, #20]
				_prev = lastYield;
    1f12:	4b11      	ldr	r3, [pc, #68]	; (1f58 <EventResponder::triggerEvent(int, void*)+0x84>)
    1f14:	6819      	ldr	r1, [r3, #0]
				_prev->_next = this;
				lastYield = this;
    1f16:	6018      	str	r0, [r3, #0]
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
				_prev = lastYield;
    1f18:	6181      	str	r1, [r0, #24]
				_prev->_next = this;
    1f1a:	6148      	str	r0, [r1, #20]
    1f1c:	e7eb      	b.n	1ef6 <EventResponder::triggerEvent(int, void*)+0x22>
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
    1f1e:	4c0f      	ldr	r4, [pc, #60]	; (1f5c <EventResponder::triggerEvent(int, void*)+0x88>)
    1f20:	6821      	ldr	r1, [r4, #0]
    1f22:	2900      	cmp	r1, #0
    1f24:	d010      	beq.n	1f48 <EventResponder::triggerEvent(int, void*)+0x74>
				_next = nullptr;
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
    1f26:	6143      	str	r3, [r0, #20]
				_prev = lastInterrupt;
    1f28:	4b0d      	ldr	r3, [pc, #52]	; (1f60 <EventResponder::triggerEvent(int, void*)+0x8c>)
    1f2a:	6819      	ldr	r1, [r3, #0]
				_prev->_next = this;
				lastInterrupt = this;
    1f2c:	6018      	str	r0, [r3, #0]
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
				_prev = lastInterrupt;
    1f2e:	6181      	str	r1, [r0, #24]
				_prev->_next = this;
    1f30:	6148      	str	r0, [r1, #20]
				lastInterrupt = this;
			}
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
    1f32:	2180      	movs	r1, #128	; 0x80
    1f34:	4b0b      	ldr	r3, [pc, #44]	; (1f64 <EventResponder::triggerEvent(int, void*)+0x90>)
    1f36:	0549      	lsls	r1, r1, #21
    1f38:	6019      	str	r1, [r3, #0]
    1f3a:	e7dc      	b.n	1ef6 <EventResponder::triggerEvent(int, void*)+0x22>
			// normal type, called from yield()
			if (firstYield == nullptr) {
				_next = nullptr;
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
    1f3c:	4b06      	ldr	r3, [pc, #24]	; (1f58 <EventResponder::triggerEvent(int, void*)+0x84>)
	if (_triggered == false) {
		// not already triggered
		if (_type == EventTypeYield) {
			// normal type, called from yield()
			if (firstYield == nullptr) {
				_next = nullptr;
    1f3e:	6141      	str	r1, [r0, #20]
				_prev = nullptr;
    1f40:	6181      	str	r1, [r0, #24]
				firstYield = this;
    1f42:	6020      	str	r0, [r4, #0]
				lastYield = this;
    1f44:	6018      	str	r0, [r3, #0]
    1f46:	e7d6      	b.n	1ef6 <EventResponder::triggerEvent(int, void*)+0x22>
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
				_next = nullptr;
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
    1f48:	4b05      	ldr	r3, [pc, #20]	; (1f60 <EventResponder::triggerEvent(int, void*)+0x8c>)
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
				_next = nullptr;
    1f4a:	6141      	str	r1, [r0, #20]
				_prev = nullptr;
    1f4c:	6181      	str	r1, [r0, #24]
				firstInterrupt = this;
    1f4e:	6020      	str	r0, [r4, #0]
				lastInterrupt = this;
    1f50:	6018      	str	r0, [r3, #0]
    1f52:	e7ee      	b.n	1f32 <EventResponder::triggerEvent(int, void*)+0x5e>
    1f54:	200007bc 	.word	0x200007bc
    1f58:	200007b8 	.word	0x200007b8
    1f5c:	200007ac 	.word	0x200007ac
    1f60:	200007b0 	.word	0x200007b0
    1f64:	e000ed04 	.word	0xe000ed04

00001f68 <pendablesrvreq_isr>:
	}
	enableInterrupts(irq);
}

void pendablesrvreq_isr(void)
{
    1f68:	b570      	push	{r4, r5, r6, lr}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    1f6a:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    1f6e:	b672      	cpsid	i

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    1f70:	4c0e      	ldr	r4, [pc, #56]	; (1fac <pendablesrvreq_isr+0x44>)
    1f72:	6820      	ldr	r0, [r4, #0]
		if (first) {
    1f74:	2800      	cmp	r0, #0
    1f76:	d015      	beq.n	1fa4 <pendablesrvreq_isr+0x3c>
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    1f78:	4e0d      	ldr	r6, [pc, #52]	; (1fb0 <pendablesrvreq_isr+0x48>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    1f7a:	2500      	movs	r5, #0
    1f7c:	e00c      	b.n	1f98 <pendablesrvreq_isr+0x30>
    1f7e:	619d      	str	r5, [r3, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    1f80:	2a00      	cmp	r2, #0
    1f82:	d100      	bne.n	1f86 <pendablesrvreq_isr+0x1e>
    1f84:	b662      	cpsie	i
			} else {
				lastInterrupt = nullptr;
			}
			enableInterrupts(irq);
			first->_triggered = false;
    1f86:	7745      	strb	r5, [r0, #29]
			(*(first->_function))(*first);
    1f88:	6883      	ldr	r3, [r0, #8]
    1f8a:	4798      	blx	r3
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    1f8c:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    1f90:	b672      	cpsid	i

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    1f92:	6820      	ldr	r0, [r4, #0]
		if (first) {
    1f94:	2800      	cmp	r0, #0
    1f96:	d005      	beq.n	1fa4 <pendablesrvreq_isr+0x3c>
			firstInterrupt = first->_next;
    1f98:	6943      	ldr	r3, [r0, #20]
    1f9a:	6023      	str	r3, [r4, #0]
			if (firstInterrupt) {
    1f9c:	2b00      	cmp	r3, #0
    1f9e:	d1ee      	bne.n	1f7e <pendablesrvreq_isr+0x16>
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    1fa0:	6033      	str	r3, [r6, #0]
    1fa2:	e7ed      	b.n	1f80 <pendablesrvreq_isr+0x18>
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    1fa4:	2a00      	cmp	r2, #0
    1fa6:	d100      	bne.n	1faa <pendablesrvreq_isr+0x42>
    1fa8:	b662      	cpsie	i
}

void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
}
    1faa:	bd70      	pop	{r4, r5, r6, pc}
    1fac:	200007ac 	.word	0x200007ac
    1fb0:	200007b0 	.word	0x200007b0

00001fb4 <MillisTimer::runFromTimer()>:
	}
	enableTimerInterrupt(irq);
}

void MillisTimer::runFromTimer()
{
    1fb4:	b5f0      	push	{r4, r5, r6, r7, lr}
    1fb6:	4645      	mov	r5, r8
    1fb8:	4657      	mov	r7, sl
    1fba:	464e      	mov	r6, r9
    1fbc:	b4e0      	push	{r5, r6, r7}
	MillisTimer *timer = listActive;
    1fbe:	4d7c      	ldr	r5, [pc, #496]	; (21b0 <MillisTimer::runFromTimer()+0x1fc>)
    1fc0:	682c      	ldr	r4, [r5, #0]
	while (timer) {
    1fc2:	2c00      	cmp	r4, #0
    1fc4:	d04c      	beq.n	2060 <MillisTimer::runFromTimer()+0xac>
		if (timer->_ms > 0) {
    1fc6:	6823      	ldr	r3, [r4, #0]
    1fc8:	2b00      	cmp	r3, #0
    1fca:	d147      	bne.n	205c <MillisTimer::runFromTimer()+0xa8>
    1fcc:	4b79      	ldr	r3, [pc, #484]	; (21b4 <MillisTimer::runFromTimer()+0x200>)
			timer->_ms--;
			break;
		} else {
			MillisTimer *next = timer->_next;
			if (next) next->_prev = nullptr;
    1fce:	2600      	movs	r6, #0
    1fd0:	469a      	mov	sl, r3
				_prev->_next = this;
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
    1fd2:	4b79      	ldr	r3, [pc, #484]	; (21b8 <MillisTimer::runFromTimer()+0x204>)
    1fd4:	4699      	mov	r9, r3
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
				_prev = lastInterrupt;
    1fd6:	4b79      	ldr	r3, [pc, #484]	; (21bc <MillisTimer::runFromTimer()+0x208>)
    1fd8:	4698      	mov	r8, r3
    1fda:	e005      	b.n	1fe8 <MillisTimer::runFromTimer()+0x34>
    1fdc:	682c      	ldr	r4, [r5, #0]
}

void MillisTimer::runFromTimer()
{
	MillisTimer *timer = listActive;
	while (timer) {
    1fde:	2c00      	cmp	r4, #0
    1fe0:	d03e      	beq.n	2060 <MillisTimer::runFromTimer()+0xac>
		if (timer->_ms > 0) {
    1fe2:	6823      	ldr	r3, [r4, #0]
    1fe4:	2b00      	cmp	r3, #0
    1fe6:	d139      	bne.n	205c <MillisTimer::runFromTimer()+0xa8>
			timer->_ms--;
			break;
		} else {
			MillisTimer *next = timer->_next;
    1fe8:	68a3      	ldr	r3, [r4, #8]
			if (next) next->_prev = nullptr;
    1fea:	2b00      	cmp	r3, #0
    1fec:	d000      	beq.n	1ff0 <MillisTimer::runFromTimer()+0x3c>
    1fee:	60de      	str	r6, [r3, #12]
			listActive = next;
			timer->_state = TimerOff;
			EventResponderRef event = *(timer->_event);
    1ff0:	6920      	ldr	r0, [r4, #16]
			timer->_ms--;
			break;
		} else {
			MillisTimer *next = timer->_next;
			if (next) next->_prev = nullptr;
			listActive = next;
    1ff2:	602b      	str	r3, [r5, #0]
			timer->_state = TimerOff;
			EventResponderRef event = *(timer->_event);
			event.triggerEvent(0, timer);
    1ff4:	6803      	ldr	r3, [r0, #0]
			break;
		} else {
			MillisTimer *next = timer->_next;
			if (next) next->_prev = nullptr;
			listActive = next;
			timer->_state = TimerOff;
    1ff6:	7526      	strb	r6, [r4, #20]
			EventResponderRef event = *(timer->_event);
			event.triggerEvent(0, timer);
    1ff8:	681b      	ldr	r3, [r3, #0]
    1ffa:	4553      	cmp	r3, sl
    1ffc:	d169      	bne.n	20d2 <MillisTimer::runFromTimer()+0x11e>
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
    1ffe:	7f03      	ldrb	r3, [r0, #28]

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
    2000:	6046      	str	r6, [r0, #4]
		_data = data;
    2002:	60c4      	str	r4, [r0, #12]
		if (_type == EventTypeImmediate) {
    2004:	2b02      	cmp	r3, #2
    2006:	d068      	beq.n	20da <MillisTimer::runFromTimer()+0x126>
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    2008:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    200c:	b672      	cpsid	i
// TODO: interrupt disable/enable needed in many places!!!

void EventResponder::triggerEventNotImmediate()
{
	bool irq = disableInterrupts();
	if (_triggered == false) {
    200e:	7f43      	ldrb	r3, [r0, #29]
    2010:	2b00      	cmp	r3, #0
    2012:	d108      	bne.n	2026 <MillisTimer::runFromTimer()+0x72>
		// not already triggered
		if (_type == EventTypeYield) {
    2014:	7f01      	ldrb	r1, [r0, #28]
    2016:	2901      	cmp	r1, #1
    2018:	d100      	bne.n	201c <MillisTimer::runFromTimer()+0x68>
    201a:	e08d      	b.n	2138 <MillisTimer::runFromTimer()+0x184>
				_next = nullptr;
				_prev = lastYield;
				_prev->_next = this;
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
    201c:	2903      	cmp	r1, #3
    201e:	d100      	bne.n	2022 <MillisTimer::runFromTimer()+0x6e>
    2020:	e095      	b.n	214e <MillisTimer::runFromTimer()+0x19a>
			}
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
		} else {
			// detached, easy :-)
		}
		_triggered = true;
    2022:	2301      	movs	r3, #1
    2024:	7743      	strb	r3, [r0, #29]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    2026:	2a00      	cmp	r2, #0
    2028:	d100      	bne.n	202c <MillisTimer::runFromTimer()+0x78>
    202a:	b662      	cpsie	i
			if (next) next->_prev = nullptr;
			listActive = next;
			timer->_state = TimerOff;
			EventResponderRef event = *(timer->_event);
			event.triggerEvent(0, timer);
			if (timer->_reload) {
    202c:	6863      	ldr	r3, [r4, #4]
    202e:	2b00      	cmp	r3, #0
    2030:	d0d4      	beq.n	1fdc <MillisTimer::runFromTimer()+0x28>
	enableTimerInterrupt(irq);
}

void MillisTimer::addToActiveList() // only called by runFromTimer()
{
	if (listActive == nullptr) {
    2032:	6828      	ldr	r0, [r5, #0]
			listActive = next;
			timer->_state = TimerOff;
			EventResponderRef event = *(timer->_event);
			event.triggerEvent(0, timer);
			if (timer->_reload) {
				timer->_ms = timer->_reload;
    2034:	6023      	str	r3, [r4, #0]
	enableTimerInterrupt(irq);
}

void MillisTimer::addToActiveList() // only called by runFromTimer()
{
	if (listActive == nullptr) {
    2036:	2800      	cmp	r0, #0
    2038:	d100      	bne.n	203c <MillisTimer::runFromTimer()+0x88>
    203a:	e0a4      	b.n	2186 <MillisTimer::runFromTimer()+0x1d2>
		// list is empty, easy case
		_next = nullptr;
		_prev = nullptr;
		listActive = this;
	} else if (_ms < listActive->_ms) {
    203c:	6801      	ldr	r1, [r0, #0]
    203e:	428b      	cmp	r3, r1
    2040:	d24e      	bcs.n	20e0 <MillisTimer::runFromTimer()+0x12c>
		// this timer triggers before any on the list
		_next = listActive;
		_prev = nullptr;
		listActive->_prev = this;
		// Decrement the next items wait time be our wait time as to properly handle waits for all other items...
		listActive->_ms -= _ms;	
    2042:	1acb      	subs	r3, r1, r3
		_next = nullptr;
		_prev = nullptr;
		listActive = this;
	} else if (_ms < listActive->_ms) {
		// this timer triggers before any on the list
		_next = listActive;
    2044:	60a0      	str	r0, [r4, #8]
		_prev = nullptr;
    2046:	60e6      	str	r6, [r4, #12]
		listActive->_prev = this;
		// Decrement the next items wait time be our wait time as to properly handle waits for all other items...
		listActive->_ms -= _ms;	
    2048:	6003      	str	r3, [r0, #0]
		listActive = this;
	} else if (_ms < listActive->_ms) {
		// this timer triggers before any on the list
		_next = listActive;
		_prev = nullptr;
		listActive->_prev = this;
    204a:	60c4      	str	r4, [r0, #12]
		// Decrement the next items wait time be our wait time as to properly handle waits for all other items...
		listActive->_ms -= _ms;	
		listActive = this;
    204c:	0020      	movs	r0, r4
    204e:	602c      	str	r4, [r5, #0]
		_ms -= timer->_ms;
		_next = nullptr;
		_prev = timer;
		timer->_next = this;
	}
	_state = TimerActive;
    2050:	2302      	movs	r3, #2
    2052:	7523      	strb	r3, [r4, #20]
    2054:	0004      	movs	r4, r0

void MillisTimer::runFromTimer()
{
	MillisTimer *timer = listActive;
	while (timer) {
		if (timer->_ms > 0) {
    2056:	6823      	ldr	r3, [r4, #0]
    2058:	2b00      	cmp	r3, #0
    205a:	d0c5      	beq.n	1fe8 <MillisTimer::runFromTimer()+0x34>
			timer->_ms--;
    205c:	3b01      	subs	r3, #1
    205e:	6023      	str	r3, [r4, #0]
	volatile TimerStateType _state = TimerOff;
	static MillisTimer *listWaiting; // single linked list of waiting to start timers
	static MillisTimer *listActive;  // double linked list of running timers
	static bool disableTimerInterrupt() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    2060:	f3ef 8310 	mrs	r3, PRIMASK
		__disable_irq();
    2064:	b672      	cpsid	i
			timer = listActive;
		}
	}
	bool irq = disableTimerInterrupt();
	MillisTimer *waiting = listWaiting;
	listWaiting = nullptr; // TODO: use STREX to avoid interrupt disable
    2066:	2100      	movs	r1, #0
			}
			timer = listActive;
		}
	}
	bool irq = disableTimerInterrupt();
	MillisTimer *waiting = listWaiting;
    2068:	4a55      	ldr	r2, [pc, #340]	; (21c0 <MillisTimer::runFromTimer()+0x20c>)
    206a:	6810      	ldr	r0, [r2, #0]
	listWaiting = nullptr; // TODO: use STREX to avoid interrupt disable
    206c:	6011      	str	r1, [r2, #0]
		return (primask == 0) ? true : false;
	}
	static void enableTimerInterrupt(bool doit) {
		if (doit) __enable_irq();
    206e:	2b00      	cmp	r3, #0
    2070:	d100      	bne.n	2074 <MillisTimer::runFromTimer()+0xc0>
    2072:	b662      	cpsie	i
	enableTimerInterrupt(irq);
	while (waiting) {
    2074:	2800      	cmp	r0, #0
    2076:	d054      	beq.n	2122 <MillisTimer::runFromTimer()+0x16e>
    2078:	2300      	movs	r3, #0
    207a:	4699      	mov	r9, r3
		_ms -= timer->_ms;
		_next = nullptr;
		_prev = timer;
		timer->_next = this;
	}
	_state = TimerActive;
    207c:	3302      	adds	r3, #2
    207e:	469c      	mov	ip, r3
		_prev = nullptr;
		listActive = this;
	} else if (_ms < listActive->_ms) {
		// this timer triggers before any on the list
		_next = listActive;
		_prev = nullptr;
    2080:	2300      	movs	r3, #0
    2082:	682e      	ldr	r6, [r5, #0]
    2084:	4698      	mov	r8, r3
    2086:	e00d      	b.n	20a4 <MillisTimer::runFromTimer()+0xf0>
    2088:	4642      	mov	r2, r8
    208a:	60c2      	str	r2, [r0, #12]
		listActive->_prev = this;
		// Decrement the next items wait time be our wait time as to properly handle waits for all other items...
		listActive->_ms -= _ms;	
    208c:	2201      	movs	r2, #1
    208e:	1acb      	subs	r3, r1, r3
		_next = nullptr;
		_prev = nullptr;
		listActive = this;
	} else if (_ms < listActive->_ms) {
		// this timer triggers before any on the list
		_next = listActive;
    2090:	6086      	str	r6, [r0, #8]
		_prev = nullptr;
		listActive->_prev = this;
		// Decrement the next items wait time be our wait time as to properly handle waits for all other items...
		listActive->_ms -= _ms;	
    2092:	4691      	mov	r9, r2
    2094:	6033      	str	r3, [r6, #0]
    2096:	0003      	movs	r3, r0
		listActive = this;
	} else if (_ms < listActive->_ms) {
		// this timer triggers before any on the list
		_next = listActive;
		_prev = nullptr;
		listActive->_prev = this;
    2098:	60f0      	str	r0, [r6, #12]
		_ms -= timer->_ms;
		_next = nullptr;
		_prev = timer;
		timer->_next = this;
	}
	_state = TimerActive;
    209a:	4662      	mov	r2, ip
    209c:	001e      	movs	r6, r3
    209e:	7502      	strb	r2, [r0, #20]
    20a0:	1e38      	subs	r0, r7, #0
	}
	bool irq = disableTimerInterrupt();
	MillisTimer *waiting = listWaiting;
	listWaiting = nullptr; // TODO: use STREX to avoid interrupt disable
	enableTimerInterrupt(irq);
	while (waiting) {
    20a2:	d03b      	beq.n	211c <MillisTimer::runFromTimer()+0x168>
		MillisTimer *next = waiting->_next;
    20a4:	6887      	ldr	r7, [r0, #8]
	enableTimerInterrupt(irq);
}

void MillisTimer::addToActiveList() // only called by runFromTimer()
{
	if (listActive == nullptr) {
    20a6:	2e00      	cmp	r6, #0
    20a8:	d040      	beq.n	212c <MillisTimer::runFromTimer()+0x178>
		// list is empty, easy case
		_next = nullptr;
		_prev = nullptr;
		listActive = this;
	} else if (_ms < listActive->_ms) {
    20aa:	6803      	ldr	r3, [r0, #0]
    20ac:	6831      	ldr	r1, [r6, #0]
    20ae:	428b      	cmp	r3, r1
    20b0:	d3ea      	bcc.n	2088 <MillisTimer::runFromTimer()+0xd4>
    20b2:	0034      	movs	r4, r6
    20b4:	e003      	b.n	20be <MillisTimer::runFromTimer()+0x10a>
		// add this timer somewhere after the first already on the list
		MillisTimer *timer = listActive;
		while (timer->_next) {
			_ms -= timer->_ms;
			timer = timer->_next;
			if (_ms < timer->_ms) {
    20b6:	6811      	ldr	r1, [r2, #0]
    20b8:	0014      	movs	r4, r2
    20ba:	428b      	cmp	r3, r1
    20bc:	d31f      	bcc.n	20fe <MillisTimer::runFromTimer()+0x14a>
		listActive->_ms -= _ms;	
		listActive = this;
	} else {
		// add this timer somewhere after the first already on the list
		MillisTimer *timer = listActive;
		while (timer->_next) {
    20be:	68a2      	ldr	r2, [r4, #8]
				_state = TimerActive;
				return;
			}
		}
		// add this time at the end of the list
		_ms -= timer->_ms;
    20c0:	1a5b      	subs	r3, r3, r1
    20c2:	6003      	str	r3, [r0, #0]
		listActive->_ms -= _ms;	
		listActive = this;
	} else {
		// add this timer somewhere after the first already on the list
		MillisTimer *timer = listActive;
		while (timer->_next) {
    20c4:	2a00      	cmp	r2, #0
    20c6:	d1f6      	bne.n	20b6 <MillisTimer::runFromTimer()+0x102>
				return;
			}
		}
		// add this time at the end of the list
		_ms -= timer->_ms;
		_next = nullptr;
    20c8:	6082      	str	r2, [r0, #8]
		_prev = timer;
    20ca:	60c4      	str	r4, [r0, #12]
		timer->_next = this;
    20cc:	0033      	movs	r3, r6
    20ce:	60a0      	str	r0, [r4, #8]
    20d0:	e7e3      	b.n	209a <MillisTimer::runFromTimer()+0xe6>
			MillisTimer *next = timer->_next;
			if (next) next->_prev = nullptr;
			listActive = next;
			timer->_state = TimerOff;
			EventResponderRef event = *(timer->_event);
			event.triggerEvent(0, timer);
    20d2:	0022      	movs	r2, r4
    20d4:	2100      	movs	r1, #0
    20d6:	4798      	blx	r3
    20d8:	e7a8      	b.n	202c <MillisTimer::runFromTimer()+0x78>
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    20da:	6883      	ldr	r3, [r0, #8]
    20dc:	4798      	blx	r3
    20de:	e7a5      	b.n	202c <MillisTimer::runFromTimer()+0x78>
	if (listActive == nullptr) {
		// list is empty, easy case
		_next = nullptr;
		_prev = nullptr;
		listActive = this;
	} else if (_ms < listActive->_ms) {
    20e0:	0007      	movs	r7, r0
    20e2:	e003      	b.n	20ec <MillisTimer::runFromTimer()+0x138>
		// add this timer somewhere after the first already on the list
		MillisTimer *timer = listActive;
		while (timer->_next) {
			_ms -= timer->_ms;
			timer = timer->_next;
			if (_ms < timer->_ms) {
    20e4:	6811      	ldr	r1, [r2, #0]
    20e6:	0017      	movs	r7, r2
    20e8:	428b      	cmp	r3, r1
    20ea:	d340      	bcc.n	216e <MillisTimer::runFromTimer()+0x1ba>
		listActive->_ms -= _ms;	
		listActive = this;
	} else {
		// add this timer somewhere after the first already on the list
		MillisTimer *timer = listActive;
		while (timer->_next) {
    20ec:	68ba      	ldr	r2, [r7, #8]
				_state = TimerActive;
				return;
			}
		}
		// add this time at the end of the list
		_ms -= timer->_ms;
    20ee:	1a5b      	subs	r3, r3, r1
    20f0:	6023      	str	r3, [r4, #0]
		listActive->_ms -= _ms;	
		listActive = this;
	} else {
		// add this timer somewhere after the first already on the list
		MillisTimer *timer = listActive;
		while (timer->_next) {
    20f2:	2a00      	cmp	r2, #0
    20f4:	d1f6      	bne.n	20e4 <MillisTimer::runFromTimer()+0x130>
				return;
			}
		}
		// add this time at the end of the list
		_ms -= timer->_ms;
		_next = nullptr;
    20f6:	60a2      	str	r2, [r4, #8]
		_prev = timer;
    20f8:	60e7      	str	r7, [r4, #12]
		timer->_next = this;
    20fa:	60bc      	str	r4, [r7, #8]
    20fc:	e7a8      	b.n	2050 <MillisTimer::runFromTimer()+0x9c>
		while (timer->_next) {
			_ms -= timer->_ms;
			timer = timer->_next;
			if (_ms < timer->_ms) {
				// found the right place in the middle of list
				_next = timer;
    20fe:	6082      	str	r2, [r0, #8]
				_prev = timer->_prev;
    2100:	68d2      	ldr	r2, [r2, #12]
				timer->_prev = this;
				_prev->_next = this;
				timer->_ms -= _ms;
    2102:	1acb      	subs	r3, r1, r3
			_ms -= timer->_ms;
			timer = timer->_next;
			if (_ms < timer->_ms) {
				// found the right place in the middle of list
				_next = timer;
				_prev = timer->_prev;
    2104:	60c2      	str	r2, [r0, #12]
				timer->_prev = this;
    2106:	60e0      	str	r0, [r4, #12]
				_prev->_next = this;
    2108:	68c2      	ldr	r2, [r0, #12]
    210a:	6090      	str	r0, [r2, #8]
				timer->_ms -= _ms;
    210c:	6023      	str	r3, [r4, #0]
				_state = TimerActive;
    210e:	4663      	mov	r3, ip
    2110:	7503      	strb	r3, [r0, #20]
    2112:	0033      	movs	r3, r6
    2114:	0038      	movs	r0, r7
    2116:	001e      	movs	r6, r3
	}
	bool irq = disableTimerInterrupt();
	MillisTimer *waiting = listWaiting;
	listWaiting = nullptr; // TODO: use STREX to avoid interrupt disable
	enableTimerInterrupt(irq);
	while (waiting) {
    2118:	2f00      	cmp	r7, #0
    211a:	d1c3      	bne.n	20a4 <MillisTimer::runFromTimer()+0xf0>
    211c:	464a      	mov	r2, r9
    211e:	2a00      	cmp	r2, #0
    2120:	d143      	bne.n	21aa <MillisTimer::runFromTimer()+0x1f6>
		MillisTimer *next = waiting->_next;
		waiting->addToActiveList();
		waiting = next;
	}
}
    2122:	bc1c      	pop	{r2, r3, r4}
    2124:	4690      	mov	r8, r2
    2126:	4699      	mov	r9, r3
    2128:	46a2      	mov	sl, r4
    212a:	bdf0      	pop	{r4, r5, r6, r7, pc}
void MillisTimer::addToActiveList() // only called by runFromTimer()
{
	if (listActive == nullptr) {
		// list is empty, easy case
		_next = nullptr;
		_prev = nullptr;
    212c:	2201      	movs	r2, #1

void MillisTimer::addToActiveList() // only called by runFromTimer()
{
	if (listActive == nullptr) {
		// list is empty, easy case
		_next = nullptr;
    212e:	6086      	str	r6, [r0, #8]
		_prev = nullptr;
    2130:	60c6      	str	r6, [r0, #12]
    2132:	0003      	movs	r3, r0
    2134:	4691      	mov	r9, r2
    2136:	e7b0      	b.n	209a <MillisTimer::runFromTimer()+0xe6>
	bool irq = disableInterrupts();
	if (_triggered == false) {
		// not already triggered
		if (_type == EventTypeYield) {
			// normal type, called from yield()
			if (firstYield == nullptr) {
    2138:	4f22      	ldr	r7, [pc, #136]	; (21c4 <MillisTimer::runFromTimer()+0x210>)
    213a:	6839      	ldr	r1, [r7, #0]
    213c:	2900      	cmp	r1, #0
    213e:	d027      	beq.n	2190 <MillisTimer::runFromTimer()+0x1dc>
				_next = nullptr;
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
    2140:	6143      	str	r3, [r0, #20]
				_prev = lastYield;
    2142:	4b21      	ldr	r3, [pc, #132]	; (21c8 <MillisTimer::runFromTimer()+0x214>)
    2144:	6819      	ldr	r1, [r3, #0]
				_prev->_next = this;
				lastYield = this;
    2146:	6018      	str	r0, [r3, #0]
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
				_prev = lastYield;
    2148:	6181      	str	r1, [r0, #24]
				_prev->_next = this;
    214a:	6148      	str	r0, [r1, #20]
    214c:	e769      	b.n	2022 <MillisTimer::runFromTimer()+0x6e>
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
    214e:	4649      	mov	r1, r9
    2150:	6809      	ldr	r1, [r1, #0]
    2152:	2900      	cmp	r1, #0
    2154:	d022      	beq.n	219c <MillisTimer::runFromTimer()+0x1e8>
				_next = nullptr;
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
    2156:	6143      	str	r3, [r0, #20]
				_prev = lastInterrupt;
    2158:	4643      	mov	r3, r8
    215a:	681b      	ldr	r3, [r3, #0]
    215c:	6183      	str	r3, [r0, #24]
				_prev->_next = this;
    215e:	6158      	str	r0, [r3, #20]
				lastInterrupt = this;
    2160:	4643      	mov	r3, r8
    2162:	6018      	str	r0, [r3, #0]
			}
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
    2164:	2180      	movs	r1, #128	; 0x80
    2166:	4b19      	ldr	r3, [pc, #100]	; (21cc <MillisTimer::runFromTimer()+0x218>)
    2168:	0549      	lsls	r1, r1, #21
    216a:	6019      	str	r1, [r3, #0]
    216c:	e759      	b.n	2022 <MillisTimer::runFromTimer()+0x6e>
		while (timer->_next) {
			_ms -= timer->_ms;
			timer = timer->_next;
			if (_ms < timer->_ms) {
				// found the right place in the middle of list
				_next = timer;
    216e:	60a2      	str	r2, [r4, #8]
				_prev = timer->_prev;
    2170:	68d2      	ldr	r2, [r2, #12]
				timer->_prev = this;
				_prev->_next = this;
				timer->_ms -= _ms;
    2172:	1acb      	subs	r3, r1, r3
			_ms -= timer->_ms;
			timer = timer->_next;
			if (_ms < timer->_ms) {
				// found the right place in the middle of list
				_next = timer;
				_prev = timer->_prev;
    2174:	60e2      	str	r2, [r4, #12]
				timer->_prev = this;
    2176:	60fc      	str	r4, [r7, #12]
				_prev->_next = this;
    2178:	68e2      	ldr	r2, [r4, #12]
    217a:	6094      	str	r4, [r2, #8]
				timer->_ms -= _ms;
    217c:	603b      	str	r3, [r7, #0]
				_state = TimerActive;
    217e:	2302      	movs	r3, #2
    2180:	7523      	strb	r3, [r4, #20]
    2182:	0004      	movs	r4, r0
    2184:	e72d      	b.n	1fe2 <MillisTimer::runFromTimer()+0x2e>

void MillisTimer::addToActiveList() // only called by runFromTimer()
{
	if (listActive == nullptr) {
		// list is empty, easy case
		_next = nullptr;
    2186:	60a0      	str	r0, [r4, #8]
		_prev = nullptr;
    2188:	60e0      	str	r0, [r4, #12]
		listActive = this;
    218a:	602c      	str	r4, [r5, #0]
    218c:	0020      	movs	r0, r4
    218e:	e75f      	b.n	2050 <MillisTimer::runFromTimer()+0x9c>
			// normal type, called from yield()
			if (firstYield == nullptr) {
				_next = nullptr;
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
    2190:	4b0d      	ldr	r3, [pc, #52]	; (21c8 <MillisTimer::runFromTimer()+0x214>)
	if (_triggered == false) {
		// not already triggered
		if (_type == EventTypeYield) {
			// normal type, called from yield()
			if (firstYield == nullptr) {
				_next = nullptr;
    2192:	6141      	str	r1, [r0, #20]
				_prev = nullptr;
    2194:	6181      	str	r1, [r0, #24]
				firstYield = this;
    2196:	6038      	str	r0, [r7, #0]
				lastYield = this;
    2198:	6018      	str	r0, [r3, #0]
    219a:	e742      	b.n	2022 <MillisTimer::runFromTimer()+0x6e>
		} else if (_type == EventTypeInterrupt) {
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
				_next = nullptr;
				_prev = nullptr;
				firstInterrupt = this;
    219c:	464b      	mov	r3, r9
    219e:	6018      	str	r0, [r3, #0]
				lastInterrupt = this;
    21a0:	4b06      	ldr	r3, [pc, #24]	; (21bc <MillisTimer::runFromTimer()+0x208>)
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
				_next = nullptr;
    21a2:	6141      	str	r1, [r0, #20]
				_prev = nullptr;
    21a4:	6181      	str	r1, [r0, #24]
				firstInterrupt = this;
				lastInterrupt = this;
    21a6:	6018      	str	r0, [r3, #0]
    21a8:	e7dc      	b.n	2164 <MillisTimer::runFromTimer()+0x1b0>
    21aa:	602b      	str	r3, [r5, #0]
    21ac:	e7b9      	b.n	2122 <MillisTimer::runFromTimer()+0x16e>
    21ae:	46c0      	nop			; (mov r8, r8)
    21b0:	200007b4 	.word	0x200007b4
    21b4:	00001ed5 	.word	0x00001ed5
    21b8:	200007ac 	.word	0x200007ac
    21bc:	200007b0 	.word	0x200007b0
    21c0:	200007c4 	.word	0x200007c4
    21c4:	200007bc 	.word	0x200007bc
    21c8:	200007b8 	.word	0x200007b8
    21cc:	e000ed04 	.word	0xe000ed04

000021d0 <systick_isr>:
// code will run at lower interrupt priority for better compatibility
// with libraries using mid-to-high priority interrupts.

extern "C" volatile uint32_t systick_millis_count;
void systick_isr(void)
{
    21d0:	b510      	push	{r4, lr}
	systick_millis_count++;
    21d2:	4a03      	ldr	r2, [pc, #12]	; (21e0 <systick_isr+0x10>)
    21d4:	6813      	ldr	r3, [r2, #0]
    21d6:	3301      	adds	r3, #1
    21d8:	6013      	str	r3, [r2, #0]
	MillisTimer::runFromTimer();
    21da:	f7ff feeb 	bl	1fb4 <MillisTimer::runFromTimer()>
}
    21de:	bd10      	pop	{r4, pc}
    21e0:	200006b4 	.word	0x200006b4

000021e4 <serialEvent1()>:
#include "HardwareSerial.h"

HardwareSerial Serial1;

void serialEvent1() __attribute__((weak));
void serialEvent1() {}
    21e4:	4770      	bx	lr
    21e6:	46c0      	nop			; (mov r8, r8)

000021e8 <serialEvent2()>:
#include "HardwareSerial.h"

HardwareSerial2 Serial2;

void serialEvent2() __attribute__((weak));
void serialEvent2() {}
    21e8:	4770      	bx	lr
    21ea:	46c0      	nop			; (mov r8, r8)

000021ec <serialEvent3()>:
#include "HardwareSerial.h"

HardwareSerial3 Serial3;

void serialEvent3() __attribute__((weak));
void serialEvent3() {}
    21ec:	4770      	bx	lr
    21ee:	46c0      	nop			; (mov r8, r8)

000021f0 <analog_init>:
	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
    21f0:	4b28      	ldr	r3, [pc, #160]	; (2294 <analog_init+0xa4>)
    21f2:	781b      	ldrb	r3, [r3, #0]
    21f4:	2b08      	cmp	r3, #8
    21f6:	d030      	beq.n	225a <analog_init+0x6a>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    21f8:	2b0a      	cmp	r3, #10
    21fa:	d035      	beq.n	2268 <analog_init+0x78>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 12) {
    21fc:	2b0c      	cmp	r3, #12
    21fe:	d03a      	beq.n	2276 <analog_init+0x86>
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    2200:	223c      	movs	r2, #60	; 0x3c
    2202:	4b25      	ldr	r3, [pc, #148]	; (2298 <analog_init+0xa8>)
    2204:	601a      	str	r2, [r3, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    2206:	4b25      	ldr	r3, [pc, #148]	; (229c <analog_init+0xac>)
    2208:	3a2a      	subs	r2, #42	; 0x2a
    220a:	601a      	str	r2, [r3, #0]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
		ADC1_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MKL26Z64__)
	if (analog_reference_internal) {
    220c:	4b24      	ldr	r3, [pc, #144]	; (22a0 <analog_init+0xb0>)
    220e:	781b      	ldrb	r3, [r3, #0]
    2210:	2b00      	cmp	r3, #0
    2212:	d010      	beq.n	2236 <analog_init+0x46>
		ADC0_SC2 = ADC_SC2_REFSEL(0); // external AREF
    2214:	2200      	movs	r2, #0
    2216:	4b23      	ldr	r3, [pc, #140]	; (22a4 <analog_init+0xb4>)
    2218:	601a      	str	r2, [r3, #0]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    221a:	4b23      	ldr	r3, [pc, #140]	; (22a8 <analog_init+0xb8>)
    221c:	781b      	ldrb	r3, [r3, #0]
	if (num <= 1) {
    221e:	2b01      	cmp	r3, #1
    2220:	d910      	bls.n	2244 <analog_init+0x54>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
    2222:	2b04      	cmp	r3, #4
    2224:	d912      	bls.n	224c <analog_init+0x5c>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
    2226:	2b08      	cmp	r3, #8
    2228:	d930      	bls.n	228c <analog_init+0x9c>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#endif
	} else if (num <= 16) {
    222a:	2b10      	cmp	r3, #16
    222c:	d92a      	bls.n	2284 <analog_init+0x94>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
		#endif
	} else {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    222e:	2287      	movs	r2, #135	; 0x87
    2230:	4b1e      	ldr	r3, [pc, #120]	; (22ac <analog_init+0xbc>)
    2232:	601a      	str	r2, [r3, #0]
    2234:	e00d      	b.n	2252 <analog_init+0x62>
	}
	#elif defined(__MKL26Z64__)
	if (analog_reference_internal) {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // external AREF
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
    2236:	2201      	movs	r2, #1
    2238:	4b1a      	ldr	r3, [pc, #104]	; (22a4 <analog_init+0xb4>)
    223a:	601a      	str	r2, [r3, #0]
	}
	#endif

	num = analog_num_average;
    223c:	4b1a      	ldr	r3, [pc, #104]	; (22a8 <analog_init+0xb8>)
    223e:	781b      	ldrb	r3, [r3, #0]
	if (num <= 1) {
    2240:	2b01      	cmp	r3, #1
    2242:	d8ee      	bhi.n	2222 <analog_init+0x32>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    2244:	2280      	movs	r2, #128	; 0x80
    2246:	4b19      	ldr	r3, [pc, #100]	; (22ac <analog_init+0xbc>)
    2248:	601a      	str	r2, [r3, #0]
    224a:	e002      	b.n	2252 <analog_init+0x62>
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    224c:	2284      	movs	r2, #132	; 0x84
    224e:	4b17      	ldr	r3, [pc, #92]	; (22ac <analog_init+0xbc>)
    2250:	601a      	str	r2, [r3, #0]
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
		#endif
	}
	calibrating = 1;
    2252:	2201      	movs	r2, #1
    2254:	4b16      	ldr	r3, [pc, #88]	; (22b0 <analog_init+0xc0>)
    2256:	701a      	strb	r2, [r3, #0]
}
    2258:	4770      	bx	lr
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    225a:	2200      	movs	r2, #0
    225c:	4b0e      	ldr	r3, [pc, #56]	; (2298 <analog_init+0xa8>)
    225e:	601a      	str	r2, [r3, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    2260:	4b0e      	ldr	r3, [pc, #56]	; (229c <analog_init+0xac>)
    2262:	3213      	adds	r2, #19
    2264:	601a      	str	r2, [r3, #0]
    2266:	e7d1      	b.n	220c <analog_init+0x1c>
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    2268:	2238      	movs	r2, #56	; 0x38
    226a:	4b0b      	ldr	r3, [pc, #44]	; (2298 <analog_init+0xa8>)
    226c:	601a      	str	r2, [r3, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    226e:	4b0b      	ldr	r3, [pc, #44]	; (229c <analog_init+0xac>)
    2270:	3a25      	subs	r2, #37	; 0x25
    2272:	601a      	str	r2, [r3, #0]
    2274:	e7ca      	b.n	220c <analog_init+0x1c>
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 12) {
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    2276:	2234      	movs	r2, #52	; 0x34
    2278:	4b07      	ldr	r3, [pc, #28]	; (2298 <analog_init+0xa8>)
    227a:	601a      	str	r2, [r3, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    227c:	4b07      	ldr	r3, [pc, #28]	; (229c <analog_init+0xac>)
    227e:	3a22      	subs	r2, #34	; 0x22
    2280:	601a      	str	r2, [r3, #0]
    2282:	e7c3      	b.n	220c <analog_init+0x1c>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#endif
	} else if (num <= 16) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    2284:	2286      	movs	r2, #134	; 0x86
    2286:	4b09      	ldr	r3, [pc, #36]	; (22ac <analog_init+0xbc>)
    2288:	601a      	str	r2, [r3, #0]
    228a:	e7e2      	b.n	2252 <analog_init+0x62>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    228c:	2285      	movs	r2, #133	; 0x85
    228e:	4b07      	ldr	r3, [pc, #28]	; (22ac <analog_init+0xbc>)
    2290:	601a      	str	r2, [r3, #0]
    2292:	e7de      	b.n	2252 <analog_init+0x62>
    2294:	1ffffda4 	.word	0x1ffffda4
    2298:	4003b008 	.word	0x4003b008
    229c:	4003b00c 	.word	0x4003b00c
    22a0:	200007c9 	.word	0x200007c9
    22a4:	4003b020 	.word	0x4003b020
    22a8:	1ffffda5 	.word	0x1ffffda5
    22ac:	4003b024 	.word	0x4003b024
    22b0:	200007c8 	.word	0x200007c8

000022b4 <serial_available>:

int serial_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    22b4:	4b05      	ldr	r3, [pc, #20]	; (22cc <serial_available+0x18>)
    22b6:	7818      	ldrb	r0, [r3, #0]
	tail = rx_buffer_tail;
    22b8:	4b05      	ldr	r3, [pc, #20]	; (22d0 <serial_available+0x1c>)

int serial_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    22ba:	b2c0      	uxtb	r0, r0
	tail = rx_buffer_tail;
    22bc:	781b      	ldrb	r3, [r3, #0]
    22be:	b2db      	uxtb	r3, r3
	if (head >= tail) return head - tail;
    22c0:	4298      	cmp	r0, r3
    22c2:	d200      	bcs.n	22c6 <serial_available+0x12>
	return SERIAL1_RX_BUFFER_SIZE + head - tail;
    22c4:	3040      	adds	r0, #64	; 0x40
    22c6:	1ac0      	subs	r0, r0, r3
}
    22c8:	4770      	bx	lr
    22ca:	46c0      	nop			; (mov r8, r8)
    22cc:	2000084d 	.word	0x2000084d
    22d0:	200007cb 	.word	0x200007cb

000022d4 <uart0_status_isr>:
//   Receive data above watermark   UART_S1_RDRF
//   LIN break detect		    UART_S2_LBKDIF
//   RxD pin active edge	    UART_S2_RXEDGIF

void uart0_status_isr(void)
{
    22d4:	b510      	push	{r4, lr}
		} while (UART0_TCFIFO < 8);
		tx_buffer_tail = tail;
		if (UART0_S1 & UART_S1_TDRE) UART0_C2 = C2_TX_COMPLETING;
	}
#else
	if (UART0_S1 & UART_S1_RDRF) {
    22d6:	4b28      	ldr	r3, [pc, #160]	; (2378 <uart0_status_isr+0xa4>)
    22d8:	791a      	ldrb	r2, [r3, #4]
    22da:	0692      	lsls	r2, r2, #26
    22dc:	d50f      	bpl.n	22fe <uart0_status_isr+0x2a>
		if (use9Bits && (UART0_C3 & 0x80)) {
			n = UART0_D | 0x100;
		} else {
			n = UART0_D;
		}
		head = rx_buffer_head + 1;
    22de:	4827      	ldr	r0, [pc, #156]	; (237c <uart0_status_isr+0xa8>)
#else
	if (UART0_S1 & UART_S1_RDRF) {
		if (use9Bits && (UART0_C3 & 0x80)) {
			n = UART0_D | 0x100;
		} else {
			n = UART0_D;
    22e0:	79db      	ldrb	r3, [r3, #7]
		}
		head = rx_buffer_head + 1;
    22e2:	7802      	ldrb	r2, [r0, #0]
#else
	if (UART0_S1 & UART_S1_RDRF) {
		if (use9Bits && (UART0_C3 & 0x80)) {
			n = UART0_D | 0x100;
		} else {
			n = UART0_D;
    22e4:	b2d9      	uxtb	r1, r3
		}
		head = rx_buffer_head + 1;
    22e6:	3201      	adds	r2, #1
		if (head >= SERIAL1_RX_BUFFER_SIZE) head = 0;
    22e8:	2300      	movs	r3, #0
    22ea:	2a3f      	cmp	r2, #63	; 0x3f
    22ec:	dd22      	ble.n	2334 <uart0_status_isr+0x60>
		if (head != rx_buffer_tail) {
    22ee:	4a24      	ldr	r2, [pc, #144]	; (2380 <uart0_status_isr+0xac>)
    22f0:	7812      	ldrb	r2, [r2, #0]
    22f2:	4293      	cmp	r3, r2
    22f4:	d003      	beq.n	22fe <uart0_status_isr+0x2a>
			rx_buffer[head] = n;
    22f6:	4a23      	ldr	r2, [pc, #140]	; (2384 <uart0_status_isr+0xb0>)
    22f8:	54d1      	strb	r1, [r2, r3]
			rx_buffer_head = head;
    22fa:	b2db      	uxtb	r3, r3
    22fc:	7003      	strb	r3, [r0, #0]
		}
	}
	c = UART0_C2;
    22fe:	4a1e      	ldr	r2, [pc, #120]	; (2378 <uart0_status_isr+0xa4>)
    2300:	78d3      	ldrb	r3, [r2, #3]
    2302:	b2db      	uxtb	r3, r3
	if ((c & UART_C2_TIE) && (UART0_S1 & UART_S1_TDRE)) {
    2304:	b259      	sxtb	r1, r3
    2306:	2900      	cmp	r1, #0
    2308:	db1a      	blt.n	2340 <uart0_status_isr+0x6c>
			UART0_D = n;
			tx_buffer_tail = tail;
		}
	}
#endif
	if ((c & UART_C2_TCIE) && (UART0_S1 & UART_S1_TC)) {
    230a:	2240      	movs	r2, #64	; 0x40
    230c:	421a      	tst	r2, r3
    230e:	d010      	beq.n	2332 <uart0_status_isr+0x5e>
    2310:	4b19      	ldr	r3, [pc, #100]	; (2378 <uart0_status_isr+0xa4>)
    2312:	791b      	ldrb	r3, [r3, #4]
    2314:	421a      	tst	r2, r3
    2316:	d00c      	beq.n	2332 <uart0_status_isr+0x5e>
		transmitting = 0;
    2318:	2200      	movs	r2, #0
    231a:	4b1b      	ldr	r3, [pc, #108]	; (2388 <uart0_status_isr+0xb4>)
    231c:	701a      	strb	r2, [r3, #0]
		if (transmit_pin) transmit_deassert();
    231e:	4b1b      	ldr	r3, [pc, #108]	; (238c <uart0_status_isr+0xb8>)
    2320:	681b      	ldr	r3, [r3, #0]
    2322:	2b00      	cmp	r3, #0
    2324:	d002      	beq.n	232c <uart0_status_isr+0x58>
    2326:	4a1a      	ldr	r2, [pc, #104]	; (2390 <uart0_status_isr+0xbc>)
    2328:	7812      	ldrb	r2, [r2, #0]
    232a:	721a      	strb	r2, [r3, #8]
		UART0_C2 = C2_TX_INACTIVE;
    232c:	222c      	movs	r2, #44	; 0x2c
    232e:	4b12      	ldr	r3, [pc, #72]	; (2378 <uart0_status_isr+0xa4>)
    2330:	70da      	strb	r2, [r3, #3]
	}
}
    2332:	bd10      	pop	{r4, pc}
		if (use9Bits && (UART0_C3 & 0x80)) {
			n = UART0_D | 0x100;
		} else {
			n = UART0_D;
		}
		head = rx_buffer_head + 1;
    2334:	0013      	movs	r3, r2
		if (head >= SERIAL1_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    2336:	4a12      	ldr	r2, [pc, #72]	; (2380 <uart0_status_isr+0xac>)
    2338:	7812      	ldrb	r2, [r2, #0]
    233a:	4293      	cmp	r3, r2
    233c:	d1db      	bne.n	22f6 <uart0_status_isr+0x22>
    233e:	e7de      	b.n	22fe <uart0_status_isr+0x2a>
			rx_buffer[head] = n;
			rx_buffer_head = head;
		}
	}
	c = UART0_C2;
	if ((c & UART_C2_TIE) && (UART0_S1 & UART_S1_TDRE)) {
    2340:	7911      	ldrb	r1, [r2, #4]
    2342:	b249      	sxtb	r1, r1
    2344:	2900      	cmp	r1, #0
    2346:	dae0      	bge.n	230a <uart0_status_isr+0x36>
		head = tx_buffer_head;
    2348:	4912      	ldr	r1, [pc, #72]	; (2394 <uart0_status_isr+0xc0>)
		tail = tx_buffer_tail;
    234a:	4813      	ldr	r0, [pc, #76]	; (2398 <uart0_status_isr+0xc4>)
			rx_buffer_head = head;
		}
	}
	c = UART0_C2;
	if ((c & UART_C2_TIE) && (UART0_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
    234c:	780c      	ldrb	r4, [r1, #0]
		tail = tx_buffer_tail;
    234e:	7801      	ldrb	r1, [r0, #0]
    2350:	b2c9      	uxtb	r1, r1
		if (head == tail) {
    2352:	428c      	cmp	r4, r1
    2354:	d00d      	beq.n	2372 <uart0_status_isr+0x9e>
			UART0_C2 = C2_TX_COMPLETING;
		} else {
			if (++tail >= SERIAL1_TX_BUFFER_SIZE) tail = 0;
    2356:	1c4a      	adds	r2, r1, #1
    2358:	2a3f      	cmp	r2, #63	; 0x3f
    235a:	d807      	bhi.n	236c <uart0_status_isr+0x98>
    235c:	b2d1      	uxtb	r1, r2
			n = tx_buffer[tail];
    235e:	4c0f      	ldr	r4, [pc, #60]	; (239c <uart0_status_isr+0xc8>)
    2360:	5ca2      	ldrb	r2, [r4, r2]
			if (use9Bits) UART0_C3 = (UART0_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART0_D = n;
    2362:	4c05      	ldr	r4, [pc, #20]	; (2378 <uart0_status_isr+0xa4>)
		tail = tx_buffer_tail;
		if (head == tail) {
			UART0_C2 = C2_TX_COMPLETING;
		} else {
			if (++tail >= SERIAL1_TX_BUFFER_SIZE) tail = 0;
			n = tx_buffer[tail];
    2364:	b2d2      	uxtb	r2, r2
			if (use9Bits) UART0_C3 = (UART0_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART0_D = n;
    2366:	71e2      	strb	r2, [r4, #7]
			tx_buffer_tail = tail;
    2368:	7001      	strb	r1, [r0, #0]
    236a:	e7ce      	b.n	230a <uart0_status_isr+0x36>
    236c:	2100      	movs	r1, #0
		head = tx_buffer_head;
		tail = tx_buffer_tail;
		if (head == tail) {
			UART0_C2 = C2_TX_COMPLETING;
		} else {
			if (++tail >= SERIAL1_TX_BUFFER_SIZE) tail = 0;
    236e:	2200      	movs	r2, #0
    2370:	e7f5      	b.n	235e <uart0_status_isr+0x8a>
	c = UART0_C2;
	if ((c & UART_C2_TIE) && (UART0_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
		tail = tx_buffer_tail;
		if (head == tail) {
			UART0_C2 = C2_TX_COMPLETING;
    2372:	216c      	movs	r1, #108	; 0x6c
    2374:	70d1      	strb	r1, [r2, #3]
    2376:	e7c8      	b.n	230a <uart0_status_isr+0x36>
    2378:	4006a000 	.word	0x4006a000
    237c:	2000084d 	.word	0x2000084d
    2380:	200007cb 	.word	0x200007cb
    2384:	2000080c 	.word	0x2000080c
    2388:	200007ca 	.word	0x200007ca
    238c:	20000850 	.word	0x20000850
    2390:	2000084c 	.word	0x2000084c
    2394:	20000854 	.word	0x20000854
    2398:	2000084e 	.word	0x2000084e
    239c:	200007cc 	.word	0x200007cc

000023a0 <serial2_available>:

int serial2_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    23a0:	4b05      	ldr	r3, [pc, #20]	; (23b8 <serial2_available+0x18>)
    23a2:	7818      	ldrb	r0, [r3, #0]
	tail = rx_buffer_tail;
    23a4:	4b05      	ldr	r3, [pc, #20]	; (23bc <serial2_available+0x1c>)

int serial2_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    23a6:	b2c0      	uxtb	r0, r0
	tail = rx_buffer_tail;
    23a8:	781b      	ldrb	r3, [r3, #0]
    23aa:	b2db      	uxtb	r3, r3
	if (head >= tail) return head - tail;
    23ac:	4298      	cmp	r0, r3
    23ae:	d200      	bcs.n	23b2 <serial2_available+0x12>
	return SERIAL2_RX_BUFFER_SIZE + head - tail;
    23b0:	3040      	adds	r0, #64	; 0x40
    23b2:	1ac0      	subs	r0, r0, r3
}
    23b4:	4770      	bx	lr
    23b6:	46c0      	nop			; (mov r8, r8)
    23b8:	200008c1 	.word	0x200008c1
    23bc:	20000856 	.word	0x20000856

000023c0 <uart1_status_isr>:
//   Receive data above watermark   UART_S1_RDRF
//   LIN break detect		    UART_S2_LBKDIF
//   RxD pin active edge	    UART_S2_RXEDGIF

void uart1_status_isr(void)
{
    23c0:	b510      	push	{r4, lr}
		} while (UART1_TCFIFO < 8);
		tx_buffer_tail = tail;
		if (UART1_S1 & UART_S1_TDRE) UART1_C2 = C2_TX_COMPLETING;
	}
#else
	if (UART1_S1 & UART_S1_RDRF) {
    23c2:	4b28      	ldr	r3, [pc, #160]	; (2464 <uart1_status_isr+0xa4>)
    23c4:	791a      	ldrb	r2, [r3, #4]
    23c6:	0692      	lsls	r2, r2, #26
    23c8:	d50f      	bpl.n	23ea <uart1_status_isr+0x2a>
		if (use9Bits && (UART1_C3 & 0x80)) {
			n = UART1_D | 0x100;
		} else {
			n = UART1_D;
		}
		head = rx_buffer_head + 1;
    23ca:	4827      	ldr	r0, [pc, #156]	; (2468 <uart1_status_isr+0xa8>)
#else
	if (UART1_S1 & UART_S1_RDRF) {
		if (use9Bits && (UART1_C3 & 0x80)) {
			n = UART1_D | 0x100;
		} else {
			n = UART1_D;
    23cc:	79db      	ldrb	r3, [r3, #7]
		}
		head = rx_buffer_head + 1;
    23ce:	7802      	ldrb	r2, [r0, #0]
#else
	if (UART1_S1 & UART_S1_RDRF) {
		if (use9Bits && (UART1_C3 & 0x80)) {
			n = UART1_D | 0x100;
		} else {
			n = UART1_D;
    23d0:	b2d9      	uxtb	r1, r3
		}
		head = rx_buffer_head + 1;
    23d2:	3201      	adds	r2, #1
		if (head >= SERIAL2_RX_BUFFER_SIZE) head = 0;
    23d4:	2300      	movs	r3, #0
    23d6:	2a3f      	cmp	r2, #63	; 0x3f
    23d8:	dd22      	ble.n	2420 <uart1_status_isr+0x60>
		if (head != rx_buffer_tail) {
    23da:	4a24      	ldr	r2, [pc, #144]	; (246c <uart1_status_isr+0xac>)
    23dc:	7812      	ldrb	r2, [r2, #0]
    23de:	4293      	cmp	r3, r2
    23e0:	d003      	beq.n	23ea <uart1_status_isr+0x2a>
			rx_buffer[head] = n;
    23e2:	4a23      	ldr	r2, [pc, #140]	; (2470 <uart1_status_isr+0xb0>)
    23e4:	54d1      	strb	r1, [r2, r3]
			rx_buffer_head = head;
    23e6:	b2db      	uxtb	r3, r3
    23e8:	7003      	strb	r3, [r0, #0]
		}
	}
	c = UART1_C2;
    23ea:	4a1e      	ldr	r2, [pc, #120]	; (2464 <uart1_status_isr+0xa4>)
    23ec:	78d3      	ldrb	r3, [r2, #3]
    23ee:	b2db      	uxtb	r3, r3
	if ((c & UART_C2_TIE) && (UART1_S1 & UART_S1_TDRE)) {
    23f0:	b259      	sxtb	r1, r3
    23f2:	2900      	cmp	r1, #0
    23f4:	db1a      	blt.n	242c <uart1_status_isr+0x6c>
			UART1_D = n;
			tx_buffer_tail = tail;
		}
	}
#endif
	if ((c & UART_C2_TCIE) && (UART1_S1 & UART_S1_TC)) {
    23f6:	2240      	movs	r2, #64	; 0x40
    23f8:	421a      	tst	r2, r3
    23fa:	d010      	beq.n	241e <uart1_status_isr+0x5e>
    23fc:	4b19      	ldr	r3, [pc, #100]	; (2464 <uart1_status_isr+0xa4>)
    23fe:	791b      	ldrb	r3, [r3, #4]
    2400:	421a      	tst	r2, r3
    2402:	d00c      	beq.n	241e <uart1_status_isr+0x5e>
		transmitting = 0;
    2404:	2200      	movs	r2, #0
    2406:	4b1b      	ldr	r3, [pc, #108]	; (2474 <uart1_status_isr+0xb4>)
    2408:	701a      	strb	r2, [r3, #0]
		if (transmit_pin) transmit_deassert();
    240a:	4b1b      	ldr	r3, [pc, #108]	; (2478 <uart1_status_isr+0xb8>)
    240c:	681b      	ldr	r3, [r3, #0]
    240e:	2b00      	cmp	r3, #0
    2410:	d002      	beq.n	2418 <uart1_status_isr+0x58>
    2412:	4a1a      	ldr	r2, [pc, #104]	; (247c <uart1_status_isr+0xbc>)
    2414:	7812      	ldrb	r2, [r2, #0]
    2416:	721a      	strb	r2, [r3, #8]
		UART1_C2 = C2_TX_INACTIVE;
    2418:	222c      	movs	r2, #44	; 0x2c
    241a:	4b12      	ldr	r3, [pc, #72]	; (2464 <uart1_status_isr+0xa4>)
    241c:	70da      	strb	r2, [r3, #3]
	}
}
    241e:	bd10      	pop	{r4, pc}
		if (use9Bits && (UART1_C3 & 0x80)) {
			n = UART1_D | 0x100;
		} else {
			n = UART1_D;
		}
		head = rx_buffer_head + 1;
    2420:	0013      	movs	r3, r2
		if (head >= SERIAL2_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    2422:	4a12      	ldr	r2, [pc, #72]	; (246c <uart1_status_isr+0xac>)
    2424:	7812      	ldrb	r2, [r2, #0]
    2426:	4293      	cmp	r3, r2
    2428:	d1db      	bne.n	23e2 <uart1_status_isr+0x22>
    242a:	e7de      	b.n	23ea <uart1_status_isr+0x2a>
			rx_buffer[head] = n;
			rx_buffer_head = head;
		}
	}
	c = UART1_C2;
	if ((c & UART_C2_TIE) && (UART1_S1 & UART_S1_TDRE)) {
    242c:	7911      	ldrb	r1, [r2, #4]
    242e:	b249      	sxtb	r1, r1
    2430:	2900      	cmp	r1, #0
    2432:	dae0      	bge.n	23f6 <uart1_status_isr+0x36>
		head = tx_buffer_head;
    2434:	4912      	ldr	r1, [pc, #72]	; (2480 <uart1_status_isr+0xc0>)
		tail = tx_buffer_tail;
    2436:	4813      	ldr	r0, [pc, #76]	; (2484 <uart1_status_isr+0xc4>)
			rx_buffer_head = head;
		}
	}
	c = UART1_C2;
	if ((c & UART_C2_TIE) && (UART1_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
    2438:	780c      	ldrb	r4, [r1, #0]
		tail = tx_buffer_tail;
    243a:	7801      	ldrb	r1, [r0, #0]
    243c:	b2c9      	uxtb	r1, r1
		if (head == tail) {
    243e:	428c      	cmp	r4, r1
    2440:	d00d      	beq.n	245e <uart1_status_isr+0x9e>
			UART1_C2 = C2_TX_COMPLETING;
		} else {
			if (++tail >= SERIAL2_TX_BUFFER_SIZE) tail = 0;
    2442:	1c4a      	adds	r2, r1, #1
    2444:	2a27      	cmp	r2, #39	; 0x27
    2446:	d807      	bhi.n	2458 <uart1_status_isr+0x98>
    2448:	b2d1      	uxtb	r1, r2
			n = tx_buffer[tail];
    244a:	4c0f      	ldr	r4, [pc, #60]	; (2488 <uart1_status_isr+0xc8>)
    244c:	5ca2      	ldrb	r2, [r4, r2]
			if (use9Bits) UART1_C3 = (UART1_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART1_D = n;
    244e:	4c05      	ldr	r4, [pc, #20]	; (2464 <uart1_status_isr+0xa4>)
		tail = tx_buffer_tail;
		if (head == tail) {
			UART1_C2 = C2_TX_COMPLETING;
		} else {
			if (++tail >= SERIAL2_TX_BUFFER_SIZE) tail = 0;
			n = tx_buffer[tail];
    2450:	b2d2      	uxtb	r2, r2
			if (use9Bits) UART1_C3 = (UART1_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART1_D = n;
    2452:	71e2      	strb	r2, [r4, #7]
			tx_buffer_tail = tail;
    2454:	7001      	strb	r1, [r0, #0]
    2456:	e7ce      	b.n	23f6 <uart1_status_isr+0x36>
    2458:	2100      	movs	r1, #0
		head = tx_buffer_head;
		tail = tx_buffer_tail;
		if (head == tail) {
			UART1_C2 = C2_TX_COMPLETING;
		} else {
			if (++tail >= SERIAL2_TX_BUFFER_SIZE) tail = 0;
    245a:	2200      	movs	r2, #0
    245c:	e7f5      	b.n	244a <uart1_status_isr+0x8a>
	c = UART1_C2;
	if ((c & UART_C2_TIE) && (UART1_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
		tail = tx_buffer_tail;
		if (head == tail) {
			UART1_C2 = C2_TX_COMPLETING;
    245e:	216c      	movs	r1, #108	; 0x6c
    2460:	70d1      	strb	r1, [r2, #3]
    2462:	e7c8      	b.n	23f6 <uart1_status_isr+0x36>
    2464:	4006b000 	.word	0x4006b000
    2468:	200008c1 	.word	0x200008c1
    246c:	20000856 	.word	0x20000856
    2470:	20000880 	.word	0x20000880
    2474:	20000855 	.word	0x20000855
    2478:	200008c4 	.word	0x200008c4
    247c:	200008c0 	.word	0x200008c0
    2480:	200008c8 	.word	0x200008c8
    2484:	200008c2 	.word	0x200008c2
    2488:	20000858 	.word	0x20000858

0000248c <serial3_available>:

int serial3_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    248c:	4b05      	ldr	r3, [pc, #20]	; (24a4 <serial3_available+0x18>)
    248e:	7818      	ldrb	r0, [r3, #0]
	tail = rx_buffer_tail;
    2490:	4b05      	ldr	r3, [pc, #20]	; (24a8 <serial3_available+0x1c>)

int serial3_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    2492:	b2c0      	uxtb	r0, r0
	tail = rx_buffer_tail;
    2494:	781b      	ldrb	r3, [r3, #0]
    2496:	b2db      	uxtb	r3, r3
	if (head >= tail) return head - tail;
    2498:	4298      	cmp	r0, r3
    249a:	d200      	bcs.n	249e <serial3_available+0x12>
	return SERIAL3_RX_BUFFER_SIZE + head - tail;
    249c:	3040      	adds	r0, #64	; 0x40
    249e:	1ac0      	subs	r0, r0, r3
}
    24a0:	4770      	bx	lr
    24a2:	46c0      	nop			; (mov r8, r8)
    24a4:	20000941 	.word	0x20000941
    24a8:	200008d1 	.word	0x200008d1

000024ac <uart2_status_isr>:
//   Receive data above watermark   UART_S1_RDRF
//   LIN break detect		    UART_S2_LBKDIF
//   RxD pin active edge	    UART_S2_RXEDGIF

void uart2_status_isr(void)
{
    24ac:	b510      	push	{r4, lr}
	uint32_t head, tail, n;
	uint8_t c;

	if (UART2_S1 & UART_S1_RDRF) {
    24ae:	4b31      	ldr	r3, [pc, #196]	; (2574 <uart2_status_isr+0xc8>)
    24b0:	791a      	ldrb	r2, [r3, #4]
    24b2:	0692      	lsls	r2, r2, #26
    24b4:	d51e      	bpl.n	24f4 <uart2_status_isr+0x48>
		if (use9Bits && (UART2_C3 & 0x80)) {
			n = UART2_D | 0x100;
		} else {
			n = UART2_D;
		}
		head = rx_buffer_head + 1;
    24b6:	4830      	ldr	r0, [pc, #192]	; (2578 <uart2_status_isr+0xcc>)

	if (UART2_S1 & UART_S1_RDRF) {
		if (use9Bits && (UART2_C3 & 0x80)) {
			n = UART2_D | 0x100;
		} else {
			n = UART2_D;
    24b8:	79db      	ldrb	r3, [r3, #7]
		}
		head = rx_buffer_head + 1;
    24ba:	7802      	ldrb	r2, [r0, #0]

	if (UART2_S1 & UART_S1_RDRF) {
		if (use9Bits && (UART2_C3 & 0x80)) {
			n = UART2_D | 0x100;
		} else {
			n = UART2_D;
    24bc:	b2d9      	uxtb	r1, r3
		}
		head = rx_buffer_head + 1;
    24be:	3201      	adds	r2, #1
		if (head >= SERIAL3_RX_BUFFER_SIZE) head = 0;
    24c0:	2300      	movs	r3, #0
    24c2:	2a3f      	cmp	r2, #63	; 0x3f
    24c4:	dd31      	ble.n	252a <uart2_status_isr+0x7e>
		if (head != rx_buffer_tail) {
    24c6:	4a2d      	ldr	r2, [pc, #180]	; (257c <uart2_status_isr+0xd0>)
    24c8:	7812      	ldrb	r2, [r2, #0]
    24ca:	4293      	cmp	r3, r2
    24cc:	d003      	beq.n	24d6 <uart2_status_isr+0x2a>
			rx_buffer[head] = n;
    24ce:	4a2c      	ldr	r2, [pc, #176]	; (2580 <uart2_status_isr+0xd4>)
    24d0:	54d1      	strb	r1, [r2, r3]
			rx_buffer_head = head;
    24d2:	b2da      	uxtb	r2, r3
    24d4:	7002      	strb	r2, [r0, #0]
		}
		if (rts_pin) {
    24d6:	4a2b      	ldr	r2, [pc, #172]	; (2584 <uart2_status_isr+0xd8>)
    24d8:	6811      	ldr	r1, [r2, #0]
    24da:	2900      	cmp	r1, #0
    24dc:	d00a      	beq.n	24f4 <uart2_status_isr+0x48>
			int avail;
			tail = tx_buffer_tail;
    24de:	4a2a      	ldr	r2, [pc, #168]	; (2588 <uart2_status_isr+0xdc>)
    24e0:	7812      	ldrb	r2, [r2, #0]
    24e2:	b2d2      	uxtb	r2, r2
			if (head >= tail) avail = head - tail;
    24e4:	4293      	cmp	r3, r2
    24e6:	d33c      	bcc.n	2562 <uart2_status_isr+0xb6>
    24e8:	1a9b      	subs	r3, r3, r2
			else avail = SERIAL3_RX_BUFFER_SIZE + head - tail;
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
    24ea:	2b27      	cmp	r3, #39	; 0x27
    24ec:	dd02      	ble.n	24f4 <uart2_status_isr+0x48>
    24ee:	4b27      	ldr	r3, [pc, #156]	; (258c <uart2_status_isr+0xe0>)
    24f0:	781b      	ldrb	r3, [r3, #0]
    24f2:	710b      	strb	r3, [r1, #4]
		}
	}
	c = UART2_C2;
    24f4:	4a1f      	ldr	r2, [pc, #124]	; (2574 <uart2_status_isr+0xc8>)
    24f6:	78d3      	ldrb	r3, [r2, #3]
    24f8:	b2db      	uxtb	r3, r3
	if ((c & UART_C2_TIE) && (UART2_S1 & UART_S1_TDRE)) {
    24fa:	b259      	sxtb	r1, r3
    24fc:	2900      	cmp	r1, #0
    24fe:	db1a      	blt.n	2536 <uart2_status_isr+0x8a>
			if (use9Bits) UART2_C3 = (UART2_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART2_D = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & UART_C2_TCIE) && (UART2_S1 & UART_S1_TC)) {
    2500:	2240      	movs	r2, #64	; 0x40
    2502:	421a      	tst	r2, r3
    2504:	d010      	beq.n	2528 <uart2_status_isr+0x7c>
    2506:	4b1b      	ldr	r3, [pc, #108]	; (2574 <uart2_status_isr+0xc8>)
    2508:	791b      	ldrb	r3, [r3, #4]
    250a:	421a      	tst	r2, r3
    250c:	d00c      	beq.n	2528 <uart2_status_isr+0x7c>
		transmitting = 0;
    250e:	2200      	movs	r2, #0
    2510:	4b1f      	ldr	r3, [pc, #124]	; (2590 <uart2_status_isr+0xe4>)
    2512:	701a      	strb	r2, [r3, #0]
		if (transmit_pin) transmit_deassert();
    2514:	4b1f      	ldr	r3, [pc, #124]	; (2594 <uart2_status_isr+0xe8>)
    2516:	681b      	ldr	r3, [r3, #0]
    2518:	2b00      	cmp	r3, #0
    251a:	d002      	beq.n	2522 <uart2_status_isr+0x76>
    251c:	4a1e      	ldr	r2, [pc, #120]	; (2598 <uart2_status_isr+0xec>)
    251e:	7812      	ldrb	r2, [r2, #0]
    2520:	721a      	strb	r2, [r3, #8]
		UART2_C2 = C2_TX_INACTIVE;
    2522:	222c      	movs	r2, #44	; 0x2c
    2524:	4b13      	ldr	r3, [pc, #76]	; (2574 <uart2_status_isr+0xc8>)
    2526:	70da      	strb	r2, [r3, #3]
	}
}
    2528:	bd10      	pop	{r4, pc}
		if (use9Bits && (UART2_C3 & 0x80)) {
			n = UART2_D | 0x100;
		} else {
			n = UART2_D;
		}
		head = rx_buffer_head + 1;
    252a:	0013      	movs	r3, r2
		if (head >= SERIAL3_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    252c:	4a13      	ldr	r2, [pc, #76]	; (257c <uart2_status_isr+0xd0>)
    252e:	7812      	ldrb	r2, [r2, #0]
    2530:	4293      	cmp	r3, r2
    2532:	d1cc      	bne.n	24ce <uart2_status_isr+0x22>
    2534:	e7cf      	b.n	24d6 <uart2_status_isr+0x2a>
			else avail = SERIAL3_RX_BUFFER_SIZE + head - tail;
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
		}
	}
	c = UART2_C2;
	if ((c & UART_C2_TIE) && (UART2_S1 & UART_S1_TDRE)) {
    2536:	7911      	ldrb	r1, [r2, #4]
    2538:	b249      	sxtb	r1, r1
    253a:	2900      	cmp	r1, #0
    253c:	dae0      	bge.n	2500 <uart2_status_isr+0x54>
		head = tx_buffer_head;
    253e:	4917      	ldr	r1, [pc, #92]	; (259c <uart2_status_isr+0xf0>)
		tail = tx_buffer_tail;
    2540:	4811      	ldr	r0, [pc, #68]	; (2588 <uart2_status_isr+0xdc>)
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
		}
	}
	c = UART2_C2;
	if ((c & UART_C2_TIE) && (UART2_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
    2542:	780c      	ldrb	r4, [r1, #0]
		tail = tx_buffer_tail;
    2544:	7801      	ldrb	r1, [r0, #0]
    2546:	b2c9      	uxtb	r1, r1
		if (head == tail) {
    2548:	428c      	cmp	r4, r1
    254a:	d010      	beq.n	256e <uart2_status_isr+0xc2>
			UART2_C2 = C2_TX_COMPLETING;
		} else {
			if (++tail >= SERIAL3_TX_BUFFER_SIZE) tail = 0;
    254c:	1c4a      	adds	r2, r1, #1
    254e:	2a27      	cmp	r2, #39	; 0x27
    2550:	d80a      	bhi.n	2568 <uart2_status_isr+0xbc>
    2552:	b2d1      	uxtb	r1, r2
			n = tx_buffer[tail];
    2554:	4c12      	ldr	r4, [pc, #72]	; (25a0 <uart2_status_isr+0xf4>)
    2556:	5ca2      	ldrb	r2, [r4, r2]
			if (use9Bits) UART2_C3 = (UART2_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART2_D = n;
    2558:	4c06      	ldr	r4, [pc, #24]	; (2574 <uart2_status_isr+0xc8>)
		tail = tx_buffer_tail;
		if (head == tail) {
			UART2_C2 = C2_TX_COMPLETING;
		} else {
			if (++tail >= SERIAL3_TX_BUFFER_SIZE) tail = 0;
			n = tx_buffer[tail];
    255a:	b2d2      	uxtb	r2, r2
			if (use9Bits) UART2_C3 = (UART2_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART2_D = n;
    255c:	71e2      	strb	r2, [r4, #7]
			tx_buffer_tail = tail;
    255e:	7001      	strb	r1, [r0, #0]
    2560:	e7ce      	b.n	2500 <uart2_status_isr+0x54>
		}
		if (rts_pin) {
			int avail;
			tail = tx_buffer_tail;
			if (head >= tail) avail = head - tail;
			else avail = SERIAL3_RX_BUFFER_SIZE + head - tail;
    2562:	1a9b      	subs	r3, r3, r2
    2564:	3340      	adds	r3, #64	; 0x40
    2566:	e7c0      	b.n	24ea <uart2_status_isr+0x3e>
    2568:	2100      	movs	r1, #0
		head = tx_buffer_head;
		tail = tx_buffer_tail;
		if (head == tail) {
			UART2_C2 = C2_TX_COMPLETING;
		} else {
			if (++tail >= SERIAL3_TX_BUFFER_SIZE) tail = 0;
    256a:	2200      	movs	r2, #0
    256c:	e7f2      	b.n	2554 <uart2_status_isr+0xa8>
	c = UART2_C2;
	if ((c & UART_C2_TIE) && (UART2_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
		tail = tx_buffer_tail;
		if (head == tail) {
			UART2_C2 = C2_TX_COMPLETING;
    256e:	216c      	movs	r1, #108	; 0x6c
    2570:	70d1      	strb	r1, [r2, #3]
    2572:	e7c5      	b.n	2500 <uart2_status_isr+0x54>
    2574:	4006c000 	.word	0x4006c000
    2578:	20000941 	.word	0x20000941
    257c:	200008d1 	.word	0x200008d1
    2580:	20000900 	.word	0x20000900
    2584:	200008cc 	.word	0x200008cc
    2588:	20000942 	.word	0x20000942
    258c:	200008fc 	.word	0x200008fc
    2590:	200008d0 	.word	0x200008d0
    2594:	20000944 	.word	0x20000944
    2598:	20000940 	.word	0x20000940
    259c:	20000948 	.word	0x20000948
    25a0:	200008d4 	.word	0x200008d4

000025a4 <usb_init_serialnumber>:
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    25a4:	b510      	push	{r4, lr}
    25a6:	b084      	sub	sp, #16
	char buf[11];
	uint32_t i, num;

	__disable_irq();
    25a8:	b672      	cpsid	i
#if defined(HAS_KINETIS_FLASH_FTFA) || defined(HAS_KINETIS_FLASH_FTFL)
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    25aa:	2370      	movs	r3, #112	; 0x70
	FTFL_FCCOB0 = 0x41;
    25ac:	2141      	movs	r1, #65	; 0x41
	char buf[11];
	uint32_t i, num;

	__disable_irq();
#if defined(HAS_KINETIS_FLASH_FTFA) || defined(HAS_KINETIS_FLASH_FTFL)
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    25ae:	4a2f      	ldr	r2, [pc, #188]	; (266c <usb_init_serialnumber+0xc8>)
    25b0:	7013      	strb	r3, [r2, #0]
	FTFL_FCCOB0 = 0x41;
    25b2:	4b2f      	ldr	r3, [pc, #188]	; (2670 <usb_init_serialnumber+0xcc>)
    25b4:	7019      	strb	r1, [r3, #0]
	FTFL_FCCOB1 = 15;
    25b6:	4b2f      	ldr	r3, [pc, #188]	; (2674 <usb_init_serialnumber+0xd0>)
    25b8:	3932      	subs	r1, #50	; 0x32
    25ba:	7019      	strb	r1, [r3, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    25bc:	2380      	movs	r3, #128	; 0x80
    25be:	7013      	strb	r3, [r2, #0]
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    25c0:	7813      	ldrb	r3, [r2, #0]
    25c2:	b25b      	sxtb	r3, r3
    25c4:	2b00      	cmp	r3, #0
    25c6:	dafb      	bge.n	25c0 <usb_init_serialnumber+0x1c>
	num = *(uint32_t *)&FTFL_FCCOB7;
    25c8:	4b2b      	ldr	r3, [pc, #172]	; (2678 <usb_init_serialnumber+0xd4>)
    25ca:	6818      	ldr	r0, [r3, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOBB;
	kinetis_hsrun_enable();
#endif
	__enable_irq();
    25cc:	b662      	cpsie	i
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    25ce:	4b2b      	ldr	r3, [pc, #172]	; (267c <usb_init_serialnumber+0xd8>)
    25d0:	4298      	cmp	r0, r3
    25d2:	d802      	bhi.n	25da <usb_init_serialnumber+0x36>
    25d4:	0083      	lsls	r3, r0, #2
    25d6:	1818      	adds	r0, r3, r0
    25d8:	0040      	lsls	r0, r0, #1
	ultoa(num, buf, 10);
    25da:	ac01      	add	r4, sp, #4
    25dc:	220a      	movs	r2, #10
    25de:	0021      	movs	r1, r4
    25e0:	f7fe fbbc 	bl	d5c <ultoa>
	for (i=0; i<10; i++) {
		char c = buf[i];
    25e4:	7822      	ldrb	r2, [r4, #0]
		if (!c) break;
    25e6:	2a00      	cmp	r2, #0
    25e8:	d029      	beq.n	263e <usb_init_serialnumber+0x9a>
		usb_string_serial_number_default.wString[i] = c;
    25ea:	4b25      	ldr	r3, [pc, #148]	; (2680 <usb_init_serialnumber+0xdc>)
    25ec:	805a      	strh	r2, [r3, #2]
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
		char c = buf[i];
    25ee:	7862      	ldrb	r2, [r4, #1]
		if (!c) break;
    25f0:	2a00      	cmp	r2, #0
    25f2:	d029      	beq.n	2648 <usb_init_serialnumber+0xa4>
		usb_string_serial_number_default.wString[i] = c;
    25f4:	809a      	strh	r2, [r3, #4]
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
		char c = buf[i];
    25f6:	78a2      	ldrb	r2, [r4, #2]
		if (!c) break;
    25f8:	2a00      	cmp	r2, #0
    25fa:	d027      	beq.n	264c <usb_init_serialnumber+0xa8>
		usb_string_serial_number_default.wString[i] = c;
    25fc:	80da      	strh	r2, [r3, #6]
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
		char c = buf[i];
    25fe:	78e2      	ldrb	r2, [r4, #3]
		if (!c) break;
    2600:	2a00      	cmp	r2, #0
    2602:	d025      	beq.n	2650 <usb_init_serialnumber+0xac>
		usb_string_serial_number_default.wString[i] = c;
    2604:	811a      	strh	r2, [r3, #8]
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
		char c = buf[i];
    2606:	7922      	ldrb	r2, [r4, #4]
		if (!c) break;
    2608:	2a00      	cmp	r2, #0
    260a:	d023      	beq.n	2654 <usb_init_serialnumber+0xb0>
		usb_string_serial_number_default.wString[i] = c;
    260c:	815a      	strh	r2, [r3, #10]
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
		char c = buf[i];
    260e:	7962      	ldrb	r2, [r4, #5]
		if (!c) break;
    2610:	2a00      	cmp	r2, #0
    2612:	d021      	beq.n	2658 <usb_init_serialnumber+0xb4>
		usb_string_serial_number_default.wString[i] = c;
    2614:	819a      	strh	r2, [r3, #12]
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
		char c = buf[i];
    2616:	79a2      	ldrb	r2, [r4, #6]
		if (!c) break;
    2618:	2a00      	cmp	r2, #0
    261a:	d01f      	beq.n	265c <usb_init_serialnumber+0xb8>
		usb_string_serial_number_default.wString[i] = c;
    261c:	81da      	strh	r2, [r3, #14]
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
		char c = buf[i];
    261e:	79e2      	ldrb	r2, [r4, #7]
		if (!c) break;
    2620:	2a00      	cmp	r2, #0
    2622:	d01d      	beq.n	2660 <usb_init_serialnumber+0xbc>
		usb_string_serial_number_default.wString[i] = c;
    2624:	821a      	strh	r2, [r3, #16]
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
		char c = buf[i];
    2626:	7a22      	ldrb	r2, [r4, #8]
		if (!c) break;
    2628:	2a00      	cmp	r2, #0
    262a:	d01b      	beq.n	2664 <usb_init_serialnumber+0xc0>
		usb_string_serial_number_default.wString[i] = c;
    262c:	825a      	strh	r2, [r3, #18]
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
		char c = buf[i];
    262e:	7a62      	ldrb	r2, [r4, #9]
		if (!c) break;
    2630:	2a00      	cmp	r2, #0
    2632:	d019      	beq.n	2668 <usb_init_serialnumber+0xc4>
		usb_string_serial_number_default.wString[i] = c;
    2634:	829a      	strh	r2, [r3, #20]
    2636:	2216      	movs	r2, #22
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    2638:	701a      	strb	r2, [r3, #0]
}
    263a:	b004      	add	sp, #16
    263c:	bd10      	pop	{r4, pc}
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    263e:	2200      	movs	r2, #0
    2640:	4b0f      	ldr	r3, [pc, #60]	; (2680 <usb_init_serialnumber+0xdc>)
    2642:	0052      	lsls	r2, r2, #1
    2644:	3202      	adds	r2, #2
    2646:	e7f7      	b.n	2638 <usb_init_serialnumber+0x94>
    2648:	2201      	movs	r2, #1
    264a:	e7fa      	b.n	2642 <usb_init_serialnumber+0x9e>
    264c:	2202      	movs	r2, #2
    264e:	e7f8      	b.n	2642 <usb_init_serialnumber+0x9e>
    2650:	2203      	movs	r2, #3
    2652:	e7f6      	b.n	2642 <usb_init_serialnumber+0x9e>
    2654:	2204      	movs	r2, #4
    2656:	e7f4      	b.n	2642 <usb_init_serialnumber+0x9e>
    2658:	2205      	movs	r2, #5
    265a:	e7f2      	b.n	2642 <usb_init_serialnumber+0x9e>
    265c:	2206      	movs	r2, #6
    265e:	e7f0      	b.n	2642 <usb_init_serialnumber+0x9e>
    2660:	2207      	movs	r2, #7
    2662:	e7ee      	b.n	2642 <usb_init_serialnumber+0x9e>
    2664:	2208      	movs	r2, #8
    2666:	e7ec      	b.n	2642 <usb_init_serialnumber+0x9e>
    2668:	3209      	adds	r2, #9
    266a:	e7ea      	b.n	2642 <usb_init_serialnumber+0x9e>
    266c:	40020000 	.word	0x40020000
    2670:	40020007 	.word	0x40020007
    2674:	40020006 	.word	0x40020006
    2678:	40020008 	.word	0x40020008
    267c:	0098967f 	.word	0x0098967f
    2680:	1ffffe34 	.word	0x1ffffe34

00002684 <__gnu_thumb1_case_uqi>:
    2684:	b402      	push	{r1}
    2686:	4671      	mov	r1, lr
    2688:	0849      	lsrs	r1, r1, #1
    268a:	0049      	lsls	r1, r1, #1
    268c:	5c09      	ldrb	r1, [r1, r0]
    268e:	0049      	lsls	r1, r1, #1
    2690:	448e      	add	lr, r1
    2692:	bc02      	pop	{r1}
    2694:	4770      	bx	lr
    2696:	46c0      	nop			; (mov r8, r8)

00002698 <__gnu_thumb1_case_uhi>:
    2698:	b403      	push	{r0, r1}
    269a:	4671      	mov	r1, lr
    269c:	0849      	lsrs	r1, r1, #1
    269e:	0040      	lsls	r0, r0, #1
    26a0:	0049      	lsls	r1, r1, #1
    26a2:	5a09      	ldrh	r1, [r1, r0]
    26a4:	0049      	lsls	r1, r1, #1
    26a6:	448e      	add	lr, r1
    26a8:	bc03      	pop	{r0, r1}
    26aa:	4770      	bx	lr

000026ac <__aeabi_uidiv>:
    26ac:	2200      	movs	r2, #0
    26ae:	0843      	lsrs	r3, r0, #1
    26b0:	428b      	cmp	r3, r1
    26b2:	d374      	bcc.n	279e <__aeabi_uidiv+0xf2>
    26b4:	0903      	lsrs	r3, r0, #4
    26b6:	428b      	cmp	r3, r1
    26b8:	d35f      	bcc.n	277a <__aeabi_uidiv+0xce>
    26ba:	0a03      	lsrs	r3, r0, #8
    26bc:	428b      	cmp	r3, r1
    26be:	d344      	bcc.n	274a <__aeabi_uidiv+0x9e>
    26c0:	0b03      	lsrs	r3, r0, #12
    26c2:	428b      	cmp	r3, r1
    26c4:	d328      	bcc.n	2718 <__aeabi_uidiv+0x6c>
    26c6:	0c03      	lsrs	r3, r0, #16
    26c8:	428b      	cmp	r3, r1
    26ca:	d30d      	bcc.n	26e8 <__aeabi_uidiv+0x3c>
    26cc:	22ff      	movs	r2, #255	; 0xff
    26ce:	0209      	lsls	r1, r1, #8
    26d0:	ba12      	rev	r2, r2
    26d2:	0c03      	lsrs	r3, r0, #16
    26d4:	428b      	cmp	r3, r1
    26d6:	d302      	bcc.n	26de <__aeabi_uidiv+0x32>
    26d8:	1212      	asrs	r2, r2, #8
    26da:	0209      	lsls	r1, r1, #8
    26dc:	d065      	beq.n	27aa <__aeabi_uidiv+0xfe>
    26de:	0b03      	lsrs	r3, r0, #12
    26e0:	428b      	cmp	r3, r1
    26e2:	d319      	bcc.n	2718 <__aeabi_uidiv+0x6c>
    26e4:	e000      	b.n	26e8 <__aeabi_uidiv+0x3c>
    26e6:	0a09      	lsrs	r1, r1, #8
    26e8:	0bc3      	lsrs	r3, r0, #15
    26ea:	428b      	cmp	r3, r1
    26ec:	d301      	bcc.n	26f2 <__aeabi_uidiv+0x46>
    26ee:	03cb      	lsls	r3, r1, #15
    26f0:	1ac0      	subs	r0, r0, r3
    26f2:	4152      	adcs	r2, r2
    26f4:	0b83      	lsrs	r3, r0, #14
    26f6:	428b      	cmp	r3, r1
    26f8:	d301      	bcc.n	26fe <__aeabi_uidiv+0x52>
    26fa:	038b      	lsls	r3, r1, #14
    26fc:	1ac0      	subs	r0, r0, r3
    26fe:	4152      	adcs	r2, r2
    2700:	0b43      	lsrs	r3, r0, #13
    2702:	428b      	cmp	r3, r1
    2704:	d301      	bcc.n	270a <__aeabi_uidiv+0x5e>
    2706:	034b      	lsls	r3, r1, #13
    2708:	1ac0      	subs	r0, r0, r3
    270a:	4152      	adcs	r2, r2
    270c:	0b03      	lsrs	r3, r0, #12
    270e:	428b      	cmp	r3, r1
    2710:	d301      	bcc.n	2716 <__aeabi_uidiv+0x6a>
    2712:	030b      	lsls	r3, r1, #12
    2714:	1ac0      	subs	r0, r0, r3
    2716:	4152      	adcs	r2, r2
    2718:	0ac3      	lsrs	r3, r0, #11
    271a:	428b      	cmp	r3, r1
    271c:	d301      	bcc.n	2722 <__aeabi_uidiv+0x76>
    271e:	02cb      	lsls	r3, r1, #11
    2720:	1ac0      	subs	r0, r0, r3
    2722:	4152      	adcs	r2, r2
    2724:	0a83      	lsrs	r3, r0, #10
    2726:	428b      	cmp	r3, r1
    2728:	d301      	bcc.n	272e <__aeabi_uidiv+0x82>
    272a:	028b      	lsls	r3, r1, #10
    272c:	1ac0      	subs	r0, r0, r3
    272e:	4152      	adcs	r2, r2
    2730:	0a43      	lsrs	r3, r0, #9
    2732:	428b      	cmp	r3, r1
    2734:	d301      	bcc.n	273a <__aeabi_uidiv+0x8e>
    2736:	024b      	lsls	r3, r1, #9
    2738:	1ac0      	subs	r0, r0, r3
    273a:	4152      	adcs	r2, r2
    273c:	0a03      	lsrs	r3, r0, #8
    273e:	428b      	cmp	r3, r1
    2740:	d301      	bcc.n	2746 <__aeabi_uidiv+0x9a>
    2742:	020b      	lsls	r3, r1, #8
    2744:	1ac0      	subs	r0, r0, r3
    2746:	4152      	adcs	r2, r2
    2748:	d2cd      	bcs.n	26e6 <__aeabi_uidiv+0x3a>
    274a:	09c3      	lsrs	r3, r0, #7
    274c:	428b      	cmp	r3, r1
    274e:	d301      	bcc.n	2754 <__aeabi_uidiv+0xa8>
    2750:	01cb      	lsls	r3, r1, #7
    2752:	1ac0      	subs	r0, r0, r3
    2754:	4152      	adcs	r2, r2
    2756:	0983      	lsrs	r3, r0, #6
    2758:	428b      	cmp	r3, r1
    275a:	d301      	bcc.n	2760 <__aeabi_uidiv+0xb4>
    275c:	018b      	lsls	r3, r1, #6
    275e:	1ac0      	subs	r0, r0, r3
    2760:	4152      	adcs	r2, r2
    2762:	0943      	lsrs	r3, r0, #5
    2764:	428b      	cmp	r3, r1
    2766:	d301      	bcc.n	276c <__aeabi_uidiv+0xc0>
    2768:	014b      	lsls	r3, r1, #5
    276a:	1ac0      	subs	r0, r0, r3
    276c:	4152      	adcs	r2, r2
    276e:	0903      	lsrs	r3, r0, #4
    2770:	428b      	cmp	r3, r1
    2772:	d301      	bcc.n	2778 <__aeabi_uidiv+0xcc>
    2774:	010b      	lsls	r3, r1, #4
    2776:	1ac0      	subs	r0, r0, r3
    2778:	4152      	adcs	r2, r2
    277a:	08c3      	lsrs	r3, r0, #3
    277c:	428b      	cmp	r3, r1
    277e:	d301      	bcc.n	2784 <__aeabi_uidiv+0xd8>
    2780:	00cb      	lsls	r3, r1, #3
    2782:	1ac0      	subs	r0, r0, r3
    2784:	4152      	adcs	r2, r2
    2786:	0883      	lsrs	r3, r0, #2
    2788:	428b      	cmp	r3, r1
    278a:	d301      	bcc.n	2790 <__aeabi_uidiv+0xe4>
    278c:	008b      	lsls	r3, r1, #2
    278e:	1ac0      	subs	r0, r0, r3
    2790:	4152      	adcs	r2, r2
    2792:	0843      	lsrs	r3, r0, #1
    2794:	428b      	cmp	r3, r1
    2796:	d301      	bcc.n	279c <__aeabi_uidiv+0xf0>
    2798:	004b      	lsls	r3, r1, #1
    279a:	1ac0      	subs	r0, r0, r3
    279c:	4152      	adcs	r2, r2
    279e:	1a41      	subs	r1, r0, r1
    27a0:	d200      	bcs.n	27a4 <__aeabi_uidiv+0xf8>
    27a2:	4601      	mov	r1, r0
    27a4:	4152      	adcs	r2, r2
    27a6:	4610      	mov	r0, r2
    27a8:	4770      	bx	lr
    27aa:	e7ff      	b.n	27ac <__aeabi_uidiv+0x100>
    27ac:	b501      	push	{r0, lr}
    27ae:	2000      	movs	r0, #0
    27b0:	f000 f806 	bl	27c0 <__aeabi_idiv0>
    27b4:	bd02      	pop	{r1, pc}
    27b6:	46c0      	nop			; (mov r8, r8)

000027b8 <__aeabi_uidivmod>:
    27b8:	2900      	cmp	r1, #0
    27ba:	d0f7      	beq.n	27ac <__aeabi_uidiv+0x100>
    27bc:	e776      	b.n	26ac <__aeabi_uidiv>
    27be:	4770      	bx	lr

000027c0 <__aeabi_idiv0>:
    27c0:	4770      	bx	lr
    27c2:	46c0      	nop			; (mov r8, r8)

000027c4 <__clzsi2>:
    27c4:	211c      	movs	r1, #28
    27c6:	2301      	movs	r3, #1
    27c8:	041b      	lsls	r3, r3, #16
    27ca:	4298      	cmp	r0, r3
    27cc:	d301      	bcc.n	27d2 <__clzsi2+0xe>
    27ce:	0c00      	lsrs	r0, r0, #16
    27d0:	3910      	subs	r1, #16
    27d2:	0a1b      	lsrs	r3, r3, #8
    27d4:	4298      	cmp	r0, r3
    27d6:	d301      	bcc.n	27dc <__clzsi2+0x18>
    27d8:	0a00      	lsrs	r0, r0, #8
    27da:	3908      	subs	r1, #8
    27dc:	091b      	lsrs	r3, r3, #4
    27de:	4298      	cmp	r0, r3
    27e0:	d301      	bcc.n	27e6 <__clzsi2+0x22>
    27e2:	0900      	lsrs	r0, r0, #4
    27e4:	3904      	subs	r1, #4
    27e6:	a202      	add	r2, pc, #8	; (adr r2, 27f0 <__clzsi2+0x2c>)
    27e8:	5c10      	ldrb	r0, [r2, r0]
    27ea:	1840      	adds	r0, r0, r1
    27ec:	4770      	bx	lr
    27ee:	46c0      	nop			; (mov r8, r8)
    27f0:	02020304 	.word	0x02020304
    27f4:	01010101 	.word	0x01010101
	...

00002800 <__errno>:
    2800:	4b01      	ldr	r3, [pc, #4]	; (2808 <__errno+0x8>)
    2802:	6818      	ldr	r0, [r3, #0]
    2804:	4770      	bx	lr
    2806:	46c0      	nop			; (mov r8, r8)
    2808:	20000278 	.word	0x20000278

0000280c <__libc_init_array>:
    280c:	b570      	push	{r4, r5, r6, lr}
    280e:	4e0d      	ldr	r6, [pc, #52]	; (2844 <__libc_init_array+0x38>)
    2810:	4d0d      	ldr	r5, [pc, #52]	; (2848 <__libc_init_array+0x3c>)
    2812:	2400      	movs	r4, #0
    2814:	1bad      	subs	r5, r5, r6
    2816:	10ad      	asrs	r5, r5, #2
    2818:	d005      	beq.n	2826 <__libc_init_array+0x1a>
    281a:	00a3      	lsls	r3, r4, #2
    281c:	58f3      	ldr	r3, [r6, r3]
    281e:	3401      	adds	r4, #1
    2820:	4798      	blx	r3
    2822:	42a5      	cmp	r5, r4
    2824:	d1f9      	bne.n	281a <__libc_init_array+0xe>
    2826:	f000 fe15 	bl	3454 <_init>
    282a:	4e08      	ldr	r6, [pc, #32]	; (284c <__libc_init_array+0x40>)
    282c:	4d08      	ldr	r5, [pc, #32]	; (2850 <__libc_init_array+0x44>)
    282e:	2400      	movs	r4, #0
    2830:	1bad      	subs	r5, r5, r6
    2832:	10ad      	asrs	r5, r5, #2
    2834:	d005      	beq.n	2842 <__libc_init_array+0x36>
    2836:	00a3      	lsls	r3, r4, #2
    2838:	58f3      	ldr	r3, [r6, r3]
    283a:	3401      	adds	r4, #1
    283c:	4798      	blx	r3
    283e:	42a5      	cmp	r5, r4
    2840:	d1f9      	bne.n	2836 <__libc_init_array+0x2a>
    2842:	bd70      	pop	{r4, r5, r6, pc}
    2844:	00003460 	.word	0x00003460
    2848:	00003460 	.word	0x00003460
    284c:	00003460 	.word	0x00003460
    2850:	00003468 	.word	0x00003468

00002854 <malloc>:
    2854:	b510      	push	{r4, lr}
    2856:	4b03      	ldr	r3, [pc, #12]	; (2864 <malloc+0x10>)
    2858:	0001      	movs	r1, r0
    285a:	6818      	ldr	r0, [r3, #0]
    285c:	f000 f804 	bl	2868 <_malloc_r>
    2860:	bd10      	pop	{r4, pc}
    2862:	46c0      	nop			; (mov r8, r8)
    2864:	20000278 	.word	0x20000278

00002868 <_malloc_r>:
    2868:	b5f0      	push	{r4, r5, r6, r7, lr}
    286a:	465f      	mov	r7, fp
    286c:	464d      	mov	r5, r9
    286e:	4656      	mov	r6, sl
    2870:	4644      	mov	r4, r8
    2872:	b4f0      	push	{r4, r5, r6, r7}
    2874:	000d      	movs	r5, r1
    2876:	350b      	adds	r5, #11
    2878:	b083      	sub	sp, #12
    287a:	0007      	movs	r7, r0
    287c:	2d16      	cmp	r5, #22
    287e:	d800      	bhi.n	2882 <_malloc_r+0x1a>
    2880:	e0a8      	b.n	29d4 <_malloc_r+0x16c>
    2882:	2307      	movs	r3, #7
    2884:	439d      	bics	r5, r3
    2886:	d500      	bpl.n	288a <_malloc_r+0x22>
    2888:	e0ce      	b.n	2a28 <_malloc_r+0x1c0>
    288a:	42a9      	cmp	r1, r5
    288c:	d900      	bls.n	2890 <_malloc_r+0x28>
    288e:	e0cb      	b.n	2a28 <_malloc_r+0x1c0>
    2890:	f000 fad2 	bl	2e38 <__malloc_lock>
    2894:	23f8      	movs	r3, #248	; 0xf8
    2896:	33ff      	adds	r3, #255	; 0xff
    2898:	429d      	cmp	r5, r3
    289a:	d800      	bhi.n	289e <_malloc_r+0x36>
    289c:	e284      	b.n	2da8 <_malloc_r+0x540>
    289e:	0a6b      	lsrs	r3, r5, #9
    28a0:	d100      	bne.n	28a4 <_malloc_r+0x3c>
    28a2:	e0c5      	b.n	2a30 <_malloc_r+0x1c8>
    28a4:	2b04      	cmp	r3, #4
    28a6:	d900      	bls.n	28aa <_malloc_r+0x42>
    28a8:	e16c      	b.n	2b84 <_malloc_r+0x31c>
    28aa:	2338      	movs	r3, #56	; 0x38
    28ac:	09a9      	lsrs	r1, r5, #6
    28ae:	469c      	mov	ip, r3
    28b0:	3301      	adds	r3, #1
    28b2:	4698      	mov	r8, r3
    28b4:	4488      	add	r8, r1
    28b6:	4643      	mov	r3, r8
    28b8:	448c      	add	ip, r1
    28ba:	0059      	lsls	r1, r3, #1
    28bc:	4ec9      	ldr	r6, [pc, #804]	; (2be4 <_malloc_r+0x37c>)
    28be:	0089      	lsls	r1, r1, #2
    28c0:	1871      	adds	r1, r6, r1
    28c2:	3908      	subs	r1, #8
    28c4:	68cc      	ldr	r4, [r1, #12]
    28c6:	42a1      	cmp	r1, r4
    28c8:	d017      	beq.n	28fa <_malloc_r+0x92>
    28ca:	2303      	movs	r3, #3
    28cc:	6862      	ldr	r2, [r4, #4]
    28ce:	439a      	bics	r2, r3
    28d0:	0013      	movs	r3, r2
    28d2:	1b52      	subs	r2, r2, r5
    28d4:	2a0f      	cmp	r2, #15
    28d6:	dd00      	ble.n	28da <_malloc_r+0x72>
    28d8:	e0b0      	b.n	2a3c <_malloc_r+0x1d4>
    28da:	2003      	movs	r0, #3
    28dc:	2a00      	cmp	r2, #0
    28de:	db09      	blt.n	28f4 <_malloc_r+0x8c>
    28e0:	e08d      	b.n	29fe <_malloc_r+0x196>
    28e2:	6863      	ldr	r3, [r4, #4]
    28e4:	4383      	bics	r3, r0
    28e6:	1b5a      	subs	r2, r3, r5
    28e8:	2a0f      	cmp	r2, #15
    28ea:	dd00      	ble.n	28ee <_malloc_r+0x86>
    28ec:	e0a6      	b.n	2a3c <_malloc_r+0x1d4>
    28ee:	2a00      	cmp	r2, #0
    28f0:	db00      	blt.n	28f4 <_malloc_r+0x8c>
    28f2:	e084      	b.n	29fe <_malloc_r+0x196>
    28f4:	68e4      	ldr	r4, [r4, #12]
    28f6:	42a1      	cmp	r1, r4
    28f8:	d1f3      	bne.n	28e2 <_malloc_r+0x7a>
    28fa:	4643      	mov	r3, r8
    28fc:	9300      	str	r3, [sp, #0]
    28fe:	0032      	movs	r2, r6
    2900:	6934      	ldr	r4, [r6, #16]
    2902:	3208      	adds	r2, #8
    2904:	4294      	cmp	r4, r2
    2906:	d100      	bne.n	290a <_malloc_r+0xa2>
    2908:	e18f      	b.n	2c2a <_malloc_r+0x3c2>
    290a:	2303      	movs	r3, #3
    290c:	6861      	ldr	r1, [r4, #4]
    290e:	4399      	bics	r1, r3
    2910:	000b      	movs	r3, r1
    2912:	1b48      	subs	r0, r1, r5
    2914:	280f      	cmp	r0, #15
    2916:	dd00      	ble.n	291a <_malloc_r+0xb2>
    2918:	e176      	b.n	2c08 <_malloc_r+0x3a0>
    291a:	6172      	str	r2, [r6, #20]
    291c:	6132      	str	r2, [r6, #16]
    291e:	2800      	cmp	r0, #0
    2920:	da71      	bge.n	2a06 <_malloc_r+0x19e>
    2922:	4ab1      	ldr	r2, [pc, #708]	; (2be8 <_malloc_r+0x380>)
    2924:	4291      	cmp	r1, r2
    2926:	d900      	bls.n	292a <_malloc_r+0xc2>
    2928:	e134      	b.n	2b94 <_malloc_r+0x32c>
    292a:	2301      	movs	r3, #1
    292c:	08c8      	lsrs	r0, r1, #3
    292e:	1082      	asrs	r2, r0, #2
    2930:	4093      	lsls	r3, r2
    2932:	6872      	ldr	r2, [r6, #4]
    2934:	431a      	orrs	r2, r3
    2936:	00c3      	lsls	r3, r0, #3
    2938:	199b      	adds	r3, r3, r6
    293a:	6898      	ldr	r0, [r3, #8]
    293c:	6072      	str	r2, [r6, #4]
    293e:	60e3      	str	r3, [r4, #12]
    2940:	60a0      	str	r0, [r4, #8]
    2942:	609c      	str	r4, [r3, #8]
    2944:	0013      	movs	r3, r2
    2946:	60c4      	str	r4, [r0, #12]
    2948:	2001      	movs	r0, #1
    294a:	9900      	ldr	r1, [sp, #0]
    294c:	108a      	asrs	r2, r1, #2
    294e:	4090      	lsls	r0, r2
    2950:	4298      	cmp	r0, r3
    2952:	d900      	bls.n	2956 <_malloc_r+0xee>
    2954:	e075      	b.n	2a42 <_malloc_r+0x1da>
    2956:	4203      	tst	r3, r0
    2958:	d10c      	bne.n	2974 <_malloc_r+0x10c>
    295a:	2203      	movs	r2, #3
    295c:	4391      	bics	r1, r2
    295e:	1d0a      	adds	r2, r1, #4
    2960:	0040      	lsls	r0, r0, #1
    2962:	9200      	str	r2, [sp, #0]
    2964:	4203      	tst	r3, r0
    2966:	d105      	bne.n	2974 <_malloc_r+0x10c>
    2968:	9a00      	ldr	r2, [sp, #0]
    296a:	0040      	lsls	r0, r0, #1
    296c:	3204      	adds	r2, #4
    296e:	9200      	str	r2, [sp, #0]
    2970:	4203      	tst	r3, r0
    2972:	d0f9      	beq.n	2968 <_malloc_r+0x100>
    2974:	2303      	movs	r3, #3
    2976:	4698      	mov	r8, r3
    2978:	9a00      	ldr	r2, [sp, #0]
    297a:	00d3      	lsls	r3, r2, #3
    297c:	4699      	mov	r9, r3
    297e:	44b1      	add	r9, r6
    2980:	46cc      	mov	ip, r9
    2982:	4692      	mov	sl, r2
    2984:	4663      	mov	r3, ip
    2986:	68dc      	ldr	r4, [r3, #12]
    2988:	45a4      	cmp	ip, r4
    298a:	d107      	bne.n	299c <_malloc_r+0x134>
    298c:	e14f      	b.n	2c2e <_malloc_r+0x3c6>
    298e:	2a00      	cmp	r2, #0
    2990:	db00      	blt.n	2994 <_malloc_r+0x12c>
    2992:	e15f      	b.n	2c54 <_malloc_r+0x3ec>
    2994:	68e4      	ldr	r4, [r4, #12]
    2996:	45a4      	cmp	ip, r4
    2998:	d100      	bne.n	299c <_malloc_r+0x134>
    299a:	e148      	b.n	2c2e <_malloc_r+0x3c6>
    299c:	4642      	mov	r2, r8
    299e:	6863      	ldr	r3, [r4, #4]
    29a0:	4393      	bics	r3, r2
    29a2:	1b5a      	subs	r2, r3, r5
    29a4:	2a0f      	cmp	r2, #15
    29a6:	ddf2      	ble.n	298e <_malloc_r+0x126>
    29a8:	2101      	movs	r1, #1
    29aa:	1963      	adds	r3, r4, r5
    29ac:	430d      	orrs	r5, r1
    29ae:	6065      	str	r5, [r4, #4]
    29b0:	68e0      	ldr	r0, [r4, #12]
    29b2:	68a5      	ldr	r5, [r4, #8]
    29b4:	3608      	adds	r6, #8
    29b6:	60e8      	str	r0, [r5, #12]
    29b8:	4311      	orrs	r1, r2
    29ba:	6085      	str	r5, [r0, #8]
    29bc:	60f3      	str	r3, [r6, #12]
    29be:	60b3      	str	r3, [r6, #8]
    29c0:	0038      	movs	r0, r7
    29c2:	60de      	str	r6, [r3, #12]
    29c4:	609e      	str	r6, [r3, #8]
    29c6:	6059      	str	r1, [r3, #4]
    29c8:	509a      	str	r2, [r3, r2]
    29ca:	f000 fa37 	bl	2e3c <__malloc_unlock>
    29ce:	0020      	movs	r0, r4
    29d0:	3008      	adds	r0, #8
    29d2:	e022      	b.n	2a1a <_malloc_r+0x1b2>
    29d4:	2910      	cmp	r1, #16
    29d6:	d827      	bhi.n	2a28 <_malloc_r+0x1c0>
    29d8:	0038      	movs	r0, r7
    29da:	f000 fa2d 	bl	2e38 <__malloc_lock>
    29de:	2510      	movs	r5, #16
    29e0:	2306      	movs	r3, #6
    29e2:	2102      	movs	r1, #2
    29e4:	4e7f      	ldr	r6, [pc, #508]	; (2be4 <_malloc_r+0x37c>)
    29e6:	009b      	lsls	r3, r3, #2
    29e8:	18f3      	adds	r3, r6, r3
    29ea:	001a      	movs	r2, r3
    29ec:	685c      	ldr	r4, [r3, #4]
    29ee:	3a08      	subs	r2, #8
    29f0:	4294      	cmp	r4, r2
    29f2:	d100      	bne.n	29f6 <_malloc_r+0x18e>
    29f4:	e127      	b.n	2c46 <_malloc_r+0x3de>
    29f6:	2303      	movs	r3, #3
    29f8:	6862      	ldr	r2, [r4, #4]
    29fa:	439a      	bics	r2, r3
    29fc:	0013      	movs	r3, r2
    29fe:	68e2      	ldr	r2, [r4, #12]
    2a00:	68a1      	ldr	r1, [r4, #8]
    2a02:	60ca      	str	r2, [r1, #12]
    2a04:	6091      	str	r1, [r2, #8]
    2a06:	2201      	movs	r2, #1
    2a08:	18e3      	adds	r3, r4, r3
    2a0a:	6859      	ldr	r1, [r3, #4]
    2a0c:	0038      	movs	r0, r7
    2a0e:	430a      	orrs	r2, r1
    2a10:	605a      	str	r2, [r3, #4]
    2a12:	f000 fa13 	bl	2e3c <__malloc_unlock>
    2a16:	0020      	movs	r0, r4
    2a18:	3008      	adds	r0, #8
    2a1a:	b003      	add	sp, #12
    2a1c:	bc3c      	pop	{r2, r3, r4, r5}
    2a1e:	4690      	mov	r8, r2
    2a20:	4699      	mov	r9, r3
    2a22:	46a2      	mov	sl, r4
    2a24:	46ab      	mov	fp, r5
    2a26:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2a28:	230c      	movs	r3, #12
    2a2a:	2000      	movs	r0, #0
    2a2c:	603b      	str	r3, [r7, #0]
    2a2e:	e7f4      	b.n	2a1a <_malloc_r+0x1b2>
    2a30:	2340      	movs	r3, #64	; 0x40
    2a32:	4698      	mov	r8, r3
    2a34:	3b01      	subs	r3, #1
    2a36:	2180      	movs	r1, #128	; 0x80
    2a38:	469c      	mov	ip, r3
    2a3a:	e73f      	b.n	28bc <_malloc_r+0x54>
    2a3c:	4663      	mov	r3, ip
    2a3e:	9300      	str	r3, [sp, #0]
    2a40:	e75d      	b.n	28fe <_malloc_r+0x96>
    2a42:	2303      	movs	r3, #3
    2a44:	68b4      	ldr	r4, [r6, #8]
    2a46:	6862      	ldr	r2, [r4, #4]
    2a48:	439a      	bics	r2, r3
    2a4a:	4690      	mov	r8, r2
    2a4c:	42aa      	cmp	r2, r5
    2a4e:	d303      	bcc.n	2a58 <_malloc_r+0x1f0>
    2a50:	1b52      	subs	r2, r2, r5
    2a52:	2a0f      	cmp	r2, #15
    2a54:	dd00      	ble.n	2a58 <_malloc_r+0x1f0>
    2a56:	e087      	b.n	2b68 <_malloc_r+0x300>
    2a58:	0023      	movs	r3, r4
    2a5a:	4443      	add	r3, r8
    2a5c:	4a63      	ldr	r2, [pc, #396]	; (2bec <_malloc_r+0x384>)
    2a5e:	9301      	str	r3, [sp, #4]
    2a60:	4b63      	ldr	r3, [pc, #396]	; (2bf0 <_malloc_r+0x388>)
    2a62:	4693      	mov	fp, r2
    2a64:	681b      	ldr	r3, [r3, #0]
    2a66:	6812      	ldr	r2, [r2, #0]
    2a68:	18eb      	adds	r3, r5, r3
    2a6a:	3201      	adds	r2, #1
    2a6c:	d100      	bne.n	2a70 <_malloc_r+0x208>
    2a6e:	e157      	b.n	2d20 <_malloc_r+0x4b8>
    2a70:	4a60      	ldr	r2, [pc, #384]	; (2bf4 <_malloc_r+0x38c>)
    2a72:	4694      	mov	ip, r2
    2a74:	4463      	add	r3, ip
    2a76:	0b1b      	lsrs	r3, r3, #12
    2a78:	031b      	lsls	r3, r3, #12
    2a7a:	9300      	str	r3, [sp, #0]
    2a7c:	9900      	ldr	r1, [sp, #0]
    2a7e:	0038      	movs	r0, r7
    2a80:	f000 f9de 	bl	2e40 <_sbrk_r>
    2a84:	0003      	movs	r3, r0
    2a86:	4681      	mov	r9, r0
    2a88:	3301      	adds	r3, #1
    2a8a:	d061      	beq.n	2b50 <_malloc_r+0x2e8>
    2a8c:	9b01      	ldr	r3, [sp, #4]
    2a8e:	4283      	cmp	r3, r0
    2a90:	d900      	bls.n	2a94 <_malloc_r+0x22c>
    2a92:	e0fd      	b.n	2c90 <_malloc_r+0x428>
    2a94:	4b58      	ldr	r3, [pc, #352]	; (2bf8 <_malloc_r+0x390>)
    2a96:	9a00      	ldr	r2, [sp, #0]
    2a98:	469a      	mov	sl, r3
    2a9a:	681b      	ldr	r3, [r3, #0]
    2a9c:	469c      	mov	ip, r3
    2a9e:	4653      	mov	r3, sl
    2aa0:	4462      	add	r2, ip
    2aa2:	601a      	str	r2, [r3, #0]
    2aa4:	9b01      	ldr	r3, [sp, #4]
    2aa6:	0011      	movs	r1, r2
    2aa8:	454b      	cmp	r3, r9
    2aaa:	d100      	bne.n	2aae <_malloc_r+0x246>
    2aac:	e143      	b.n	2d36 <_malloc_r+0x4ce>
    2aae:	465b      	mov	r3, fp
    2ab0:	681b      	ldr	r3, [r3, #0]
    2ab2:	3301      	adds	r3, #1
    2ab4:	d100      	bne.n	2ab8 <_malloc_r+0x250>
    2ab6:	e14f      	b.n	2d58 <_malloc_r+0x4f0>
    2ab8:	464b      	mov	r3, r9
    2aba:	9a01      	ldr	r2, [sp, #4]
    2abc:	1a9b      	subs	r3, r3, r2
    2abe:	1859      	adds	r1, r3, r1
    2ac0:	4653      	mov	r3, sl
    2ac2:	6019      	str	r1, [r3, #0]
    2ac4:	2307      	movs	r3, #7
    2ac6:	464a      	mov	r2, r9
    2ac8:	4013      	ands	r3, r2
    2aca:	d100      	bne.n	2ace <_malloc_r+0x266>
    2acc:	e117      	b.n	2cfe <_malloc_r+0x496>
    2ace:	2108      	movs	r1, #8
    2ad0:	4689      	mov	r9, r1
    2ad2:	494a      	ldr	r1, [pc, #296]	; (2bfc <_malloc_r+0x394>)
    2ad4:	1ad2      	subs	r2, r2, r3
    2ad6:	4491      	add	r9, r2
    2ad8:	1ac9      	subs	r1, r1, r3
    2ada:	9b00      	ldr	r3, [sp, #0]
    2adc:	0038      	movs	r0, r7
    2ade:	444b      	add	r3, r9
    2ae0:	051b      	lsls	r3, r3, #20
    2ae2:	0d1b      	lsrs	r3, r3, #20
    2ae4:	1acb      	subs	r3, r1, r3
    2ae6:	0019      	movs	r1, r3
    2ae8:	469b      	mov	fp, r3
    2aea:	f000 f9a9 	bl	2e40 <_sbrk_r>
    2aee:	1c43      	adds	r3, r0, #1
    2af0:	d100      	bne.n	2af4 <_malloc_r+0x28c>
    2af2:	e135      	b.n	2d60 <_malloc_r+0x4f8>
    2af4:	464b      	mov	r3, r9
    2af6:	1ac0      	subs	r0, r0, r3
    2af8:	2301      	movs	r3, #1
    2afa:	4458      	add	r0, fp
    2afc:	4318      	orrs	r0, r3
    2afe:	4653      	mov	r3, sl
    2b00:	681b      	ldr	r3, [r3, #0]
    2b02:	445b      	add	r3, fp
    2b04:	0019      	movs	r1, r3
    2b06:	4653      	mov	r3, sl
    2b08:	6019      	str	r1, [r3, #0]
    2b0a:	464b      	mov	r3, r9
    2b0c:	60b3      	str	r3, [r6, #8]
    2b0e:	6058      	str	r0, [r3, #4]
    2b10:	42b4      	cmp	r4, r6
    2b12:	d013      	beq.n	2b3c <_malloc_r+0x2d4>
    2b14:	4643      	mov	r3, r8
    2b16:	2b0f      	cmp	r3, #15
    2b18:	d800      	bhi.n	2b1c <_malloc_r+0x2b4>
    2b1a:	e0e1      	b.n	2ce0 <_malloc_r+0x478>
    2b1c:	4643      	mov	r3, r8
    2b1e:	2207      	movs	r2, #7
    2b20:	6860      	ldr	r0, [r4, #4]
    2b22:	3b0c      	subs	r3, #12
    2b24:	4393      	bics	r3, r2
    2b26:	3a06      	subs	r2, #6
    2b28:	4002      	ands	r2, r0
    2b2a:	2005      	movs	r0, #5
    2b2c:	431a      	orrs	r2, r3
    2b2e:	6062      	str	r2, [r4, #4]
    2b30:	18e2      	adds	r2, r4, r3
    2b32:	6050      	str	r0, [r2, #4]
    2b34:	6090      	str	r0, [r2, #8]
    2b36:	2b0f      	cmp	r3, #15
    2b38:	d900      	bls.n	2b3c <_malloc_r+0x2d4>
    2b3a:	e115      	b.n	2d68 <_malloc_r+0x500>
    2b3c:	4b30      	ldr	r3, [pc, #192]	; (2c00 <_malloc_r+0x398>)
    2b3e:	681a      	ldr	r2, [r3, #0]
    2b40:	4291      	cmp	r1, r2
    2b42:	d900      	bls.n	2b46 <_malloc_r+0x2de>
    2b44:	6019      	str	r1, [r3, #0]
    2b46:	4b2f      	ldr	r3, [pc, #188]	; (2c04 <_malloc_r+0x39c>)
    2b48:	681a      	ldr	r2, [r3, #0]
    2b4a:	4291      	cmp	r1, r2
    2b4c:	d900      	bls.n	2b50 <_malloc_r+0x2e8>
    2b4e:	6019      	str	r1, [r3, #0]
    2b50:	2303      	movs	r3, #3
    2b52:	68b4      	ldr	r4, [r6, #8]
    2b54:	6862      	ldr	r2, [r4, #4]
    2b56:	439a      	bics	r2, r3
    2b58:	0013      	movs	r3, r2
    2b5a:	1b52      	subs	r2, r2, r5
    2b5c:	429d      	cmp	r5, r3
    2b5e:	d900      	bls.n	2b62 <_malloc_r+0x2fa>
    2b60:	e0c1      	b.n	2ce6 <_malloc_r+0x47e>
    2b62:	2a0f      	cmp	r2, #15
    2b64:	dc00      	bgt.n	2b68 <_malloc_r+0x300>
    2b66:	e0be      	b.n	2ce6 <_malloc_r+0x47e>
    2b68:	2301      	movs	r3, #1
    2b6a:	0029      	movs	r1, r5
    2b6c:	1965      	adds	r5, r4, r5
    2b6e:	4319      	orrs	r1, r3
    2b70:	4313      	orrs	r3, r2
    2b72:	6061      	str	r1, [r4, #4]
    2b74:	0038      	movs	r0, r7
    2b76:	60b5      	str	r5, [r6, #8]
    2b78:	606b      	str	r3, [r5, #4]
    2b7a:	f000 f95f 	bl	2e3c <__malloc_unlock>
    2b7e:	0020      	movs	r0, r4
    2b80:	3008      	adds	r0, #8
    2b82:	e74a      	b.n	2a1a <_malloc_r+0x1b2>
    2b84:	2b14      	cmp	r3, #20
    2b86:	d974      	bls.n	2c72 <_malloc_r+0x40a>
    2b88:	2b54      	cmp	r3, #84	; 0x54
    2b8a:	d900      	bls.n	2b8e <_malloc_r+0x326>
    2b8c:	e0b0      	b.n	2cf0 <_malloc_r+0x488>
    2b8e:	0b29      	lsrs	r1, r5, #12
    2b90:	236e      	movs	r3, #110	; 0x6e
    2b92:	e68c      	b.n	28ae <_malloc_r+0x46>
    2b94:	0a4a      	lsrs	r2, r1, #9
    2b96:	2a04      	cmp	r2, #4
    2b98:	d974      	bls.n	2c84 <_malloc_r+0x41c>
    2b9a:	2a14      	cmp	r2, #20
    2b9c:	d900      	bls.n	2ba0 <_malloc_r+0x338>
    2b9e:	e0c2      	b.n	2d26 <_malloc_r+0x4be>
    2ba0:	0010      	movs	r0, r2
    2ba2:	325c      	adds	r2, #92	; 0x5c
    2ba4:	305b      	adds	r0, #91	; 0x5b
    2ba6:	0052      	lsls	r2, r2, #1
    2ba8:	2108      	movs	r1, #8
    2baa:	4249      	negs	r1, r1
    2bac:	468c      	mov	ip, r1
    2bae:	0092      	lsls	r2, r2, #2
    2bb0:	18b2      	adds	r2, r6, r2
    2bb2:	4494      	add	ip, r2
    2bb4:	4662      	mov	r2, ip
    2bb6:	6892      	ldr	r2, [r2, #8]
    2bb8:	310b      	adds	r1, #11
    2bba:	4688      	mov	r8, r1
    2bbc:	4594      	cmp	ip, r2
    2bbe:	d100      	bne.n	2bc2 <_malloc_r+0x35a>
    2bc0:	e0a0      	b.n	2d04 <_malloc_r+0x49c>
    2bc2:	4641      	mov	r1, r8
    2bc4:	6850      	ldr	r0, [r2, #4]
    2bc6:	4388      	bics	r0, r1
    2bc8:	4283      	cmp	r3, r0
    2bca:	d202      	bcs.n	2bd2 <_malloc_r+0x36a>
    2bcc:	6892      	ldr	r2, [r2, #8]
    2bce:	4594      	cmp	ip, r2
    2bd0:	d1f7      	bne.n	2bc2 <_malloc_r+0x35a>
    2bd2:	68d3      	ldr	r3, [r2, #12]
    2bd4:	469c      	mov	ip, r3
    2bd6:	6873      	ldr	r3, [r6, #4]
    2bd8:	4661      	mov	r1, ip
    2bda:	60a2      	str	r2, [r4, #8]
    2bdc:	60e1      	str	r1, [r4, #12]
    2bde:	608c      	str	r4, [r1, #8]
    2be0:	60d4      	str	r4, [r2, #12]
    2be2:	e6b1      	b.n	2948 <_malloc_r+0xe0>
    2be4:	2000027c 	.word	0x2000027c
    2be8:	000001ff 	.word	0x000001ff
    2bec:	20000688 	.word	0x20000688
    2bf0:	20000954 	.word	0x20000954
    2bf4:	0000100f 	.word	0x0000100f
    2bf8:	20000958 	.word	0x20000958
    2bfc:	00001008 	.word	0x00001008
    2c00:	20000950 	.word	0x20000950
    2c04:	2000094c 	.word	0x2000094c
    2c08:	2101      	movs	r1, #1
    2c0a:	1963      	adds	r3, r4, r5
    2c0c:	430d      	orrs	r5, r1
    2c0e:	4301      	orrs	r1, r0
    2c10:	6065      	str	r5, [r4, #4]
    2c12:	6173      	str	r3, [r6, #20]
    2c14:	6133      	str	r3, [r6, #16]
    2c16:	60da      	str	r2, [r3, #12]
    2c18:	609a      	str	r2, [r3, #8]
    2c1a:	6059      	str	r1, [r3, #4]
    2c1c:	5018      	str	r0, [r3, r0]
    2c1e:	0038      	movs	r0, r7
    2c20:	f000 f90c 	bl	2e3c <__malloc_unlock>
    2c24:	0020      	movs	r0, r4
    2c26:	3008      	adds	r0, #8
    2c28:	e6f7      	b.n	2a1a <_malloc_r+0x1b2>
    2c2a:	6873      	ldr	r3, [r6, #4]
    2c2c:	e68c      	b.n	2948 <_malloc_r+0xe0>
    2c2e:	2308      	movs	r3, #8
    2c30:	469b      	mov	fp, r3
    2c32:	3b07      	subs	r3, #7
    2c34:	44dc      	add	ip, fp
    2c36:	469b      	mov	fp, r3
    2c38:	44da      	add	sl, fp
    2c3a:	4643      	mov	r3, r8
    2c3c:	4652      	mov	r2, sl
    2c3e:	4213      	tst	r3, r2
    2c40:	d000      	beq.n	2c44 <_malloc_r+0x3dc>
    2c42:	e69f      	b.n	2984 <_malloc_r+0x11c>
    2c44:	e033      	b.n	2cae <_malloc_r+0x446>
    2c46:	68dc      	ldr	r4, [r3, #12]
    2c48:	1c8a      	adds	r2, r1, #2
    2c4a:	9200      	str	r2, [sp, #0]
    2c4c:	42a3      	cmp	r3, r4
    2c4e:	d100      	bne.n	2c52 <_malloc_r+0x3ea>
    2c50:	e655      	b.n	28fe <_malloc_r+0x96>
    2c52:	e6d0      	b.n	29f6 <_malloc_r+0x18e>
    2c54:	2201      	movs	r2, #1
    2c56:	18e3      	adds	r3, r4, r3
    2c58:	6859      	ldr	r1, [r3, #4]
    2c5a:	0038      	movs	r0, r7
    2c5c:	430a      	orrs	r2, r1
    2c5e:	605a      	str	r2, [r3, #4]
    2c60:	68e3      	ldr	r3, [r4, #12]
    2c62:	68a2      	ldr	r2, [r4, #8]
    2c64:	60d3      	str	r3, [r2, #12]
    2c66:	609a      	str	r2, [r3, #8]
    2c68:	f000 f8e8 	bl	2e3c <__malloc_unlock>
    2c6c:	0020      	movs	r0, r4
    2c6e:	3008      	adds	r0, #8
    2c70:	e6d3      	b.n	2a1a <_malloc_r+0x1b2>
    2c72:	225b      	movs	r2, #91	; 0x5b
    2c74:	4694      	mov	ip, r2
    2c76:	3201      	adds	r2, #1
    2c78:	4690      	mov	r8, r2
    2c7a:	4498      	add	r8, r3
    2c7c:	449c      	add	ip, r3
    2c7e:	4643      	mov	r3, r8
    2c80:	0059      	lsls	r1, r3, #1
    2c82:	e61b      	b.n	28bc <_malloc_r+0x54>
    2c84:	098a      	lsrs	r2, r1, #6
    2c86:	0010      	movs	r0, r2
    2c88:	3239      	adds	r2, #57	; 0x39
    2c8a:	3038      	adds	r0, #56	; 0x38
    2c8c:	0052      	lsls	r2, r2, #1
    2c8e:	e78b      	b.n	2ba8 <_malloc_r+0x340>
    2c90:	42b4      	cmp	r4, r6
    2c92:	d000      	beq.n	2c96 <_malloc_r+0x42e>
    2c94:	e75c      	b.n	2b50 <_malloc_r+0x2e8>
    2c96:	e6fd      	b.n	2a94 <_malloc_r+0x22c>
    2c98:	9b00      	ldr	r3, [sp, #0]
    2c9a:	3b01      	subs	r3, #1
    2c9c:	9300      	str	r3, [sp, #0]
    2c9e:	2308      	movs	r3, #8
    2ca0:	425b      	negs	r3, r3
    2ca2:	469c      	mov	ip, r3
    2ca4:	44e1      	add	r9, ip
    2ca6:	464b      	mov	r3, r9
    2ca8:	689b      	ldr	r3, [r3, #8]
    2caa:	4599      	cmp	r9, r3
    2cac:	d17a      	bne.n	2da4 <_malloc_r+0x53c>
    2cae:	4643      	mov	r3, r8
    2cb0:	9a00      	ldr	r2, [sp, #0]
    2cb2:	4213      	tst	r3, r2
    2cb4:	d1f0      	bne.n	2c98 <_malloc_r+0x430>
    2cb6:	6873      	ldr	r3, [r6, #4]
    2cb8:	4383      	bics	r3, r0
    2cba:	6073      	str	r3, [r6, #4]
    2cbc:	0040      	lsls	r0, r0, #1
    2cbe:	4298      	cmp	r0, r3
    2cc0:	d900      	bls.n	2cc4 <_malloc_r+0x45c>
    2cc2:	e6be      	b.n	2a42 <_malloc_r+0x1da>
    2cc4:	2800      	cmp	r0, #0
    2cc6:	d100      	bne.n	2cca <_malloc_r+0x462>
    2cc8:	e6bb      	b.n	2a42 <_malloc_r+0x1da>
    2cca:	4203      	tst	r3, r0
    2ccc:	d170      	bne.n	2db0 <_malloc_r+0x548>
    2cce:	4652      	mov	r2, sl
    2cd0:	9200      	str	r2, [sp, #0]
    2cd2:	9a00      	ldr	r2, [sp, #0]
    2cd4:	0040      	lsls	r0, r0, #1
    2cd6:	3204      	adds	r2, #4
    2cd8:	9200      	str	r2, [sp, #0]
    2cda:	4203      	tst	r3, r0
    2cdc:	d0f9      	beq.n	2cd2 <_malloc_r+0x46a>
    2cde:	e64b      	b.n	2978 <_malloc_r+0x110>
    2ce0:	2301      	movs	r3, #1
    2ce2:	464a      	mov	r2, r9
    2ce4:	6053      	str	r3, [r2, #4]
    2ce6:	0038      	movs	r0, r7
    2ce8:	f000 f8a8 	bl	2e3c <__malloc_unlock>
    2cec:	2000      	movs	r0, #0
    2cee:	e694      	b.n	2a1a <_malloc_r+0x1b2>
    2cf0:	22aa      	movs	r2, #170	; 0xaa
    2cf2:	0052      	lsls	r2, r2, #1
    2cf4:	4293      	cmp	r3, r2
    2cf6:	d80d      	bhi.n	2d14 <_malloc_r+0x4ac>
    2cf8:	0be9      	lsrs	r1, r5, #15
    2cfa:	2377      	movs	r3, #119	; 0x77
    2cfc:	e5d7      	b.n	28ae <_malloc_r+0x46>
    2cfe:	2180      	movs	r1, #128	; 0x80
    2d00:	0149      	lsls	r1, r1, #5
    2d02:	e6ea      	b.n	2ada <_malloc_r+0x272>
    2d04:	2301      	movs	r3, #1
    2d06:	1080      	asrs	r0, r0, #2
    2d08:	4083      	lsls	r3, r0
    2d0a:	6872      	ldr	r2, [r6, #4]
    2d0c:	4313      	orrs	r3, r2
    2d0e:	6073      	str	r3, [r6, #4]
    2d10:	4662      	mov	r2, ip
    2d12:	e761      	b.n	2bd8 <_malloc_r+0x370>
    2d14:	4a28      	ldr	r2, [pc, #160]	; (2db8 <_malloc_r+0x550>)
    2d16:	4293      	cmp	r3, r2
    2d18:	d818      	bhi.n	2d4c <_malloc_r+0x4e4>
    2d1a:	0ca9      	lsrs	r1, r5, #18
    2d1c:	237c      	movs	r3, #124	; 0x7c
    2d1e:	e5c6      	b.n	28ae <_malloc_r+0x46>
    2d20:	3310      	adds	r3, #16
    2d22:	9300      	str	r3, [sp, #0]
    2d24:	e6aa      	b.n	2a7c <_malloc_r+0x214>
    2d26:	2a54      	cmp	r2, #84	; 0x54
    2d28:	d826      	bhi.n	2d78 <_malloc_r+0x510>
    2d2a:	0b0a      	lsrs	r2, r1, #12
    2d2c:	0010      	movs	r0, r2
    2d2e:	326f      	adds	r2, #111	; 0x6f
    2d30:	306e      	adds	r0, #110	; 0x6e
    2d32:	0052      	lsls	r2, r2, #1
    2d34:	e738      	b.n	2ba8 <_malloc_r+0x340>
    2d36:	051b      	lsls	r3, r3, #20
    2d38:	d000      	beq.n	2d3c <_malloc_r+0x4d4>
    2d3a:	e6b8      	b.n	2aae <_malloc_r+0x246>
    2d3c:	9b00      	ldr	r3, [sp, #0]
    2d3e:	68b2      	ldr	r2, [r6, #8]
    2d40:	4443      	add	r3, r8
    2d42:	0018      	movs	r0, r3
    2d44:	2301      	movs	r3, #1
    2d46:	4303      	orrs	r3, r0
    2d48:	6053      	str	r3, [r2, #4]
    2d4a:	e6f7      	b.n	2b3c <_malloc_r+0x2d4>
    2d4c:	237f      	movs	r3, #127	; 0x7f
    2d4e:	4698      	mov	r8, r3
    2d50:	3b01      	subs	r3, #1
    2d52:	21fe      	movs	r1, #254	; 0xfe
    2d54:	469c      	mov	ip, r3
    2d56:	e5b1      	b.n	28bc <_malloc_r+0x54>
    2d58:	465b      	mov	r3, fp
    2d5a:	464a      	mov	r2, r9
    2d5c:	601a      	str	r2, [r3, #0]
    2d5e:	e6b1      	b.n	2ac4 <_malloc_r+0x25c>
    2d60:	2300      	movs	r3, #0
    2d62:	2001      	movs	r0, #1
    2d64:	469b      	mov	fp, r3
    2d66:	e6ca      	b.n	2afe <_malloc_r+0x296>
    2d68:	0021      	movs	r1, r4
    2d6a:	0038      	movs	r0, r7
    2d6c:	3108      	adds	r1, #8
    2d6e:	f000 f8f7 	bl	2f60 <_free_r>
    2d72:	4653      	mov	r3, sl
    2d74:	6819      	ldr	r1, [r3, #0]
    2d76:	e6e1      	b.n	2b3c <_malloc_r+0x2d4>
    2d78:	20aa      	movs	r0, #170	; 0xaa
    2d7a:	0040      	lsls	r0, r0, #1
    2d7c:	4282      	cmp	r2, r0
    2d7e:	d805      	bhi.n	2d8c <_malloc_r+0x524>
    2d80:	0bca      	lsrs	r2, r1, #15
    2d82:	0010      	movs	r0, r2
    2d84:	3278      	adds	r2, #120	; 0x78
    2d86:	3077      	adds	r0, #119	; 0x77
    2d88:	0052      	lsls	r2, r2, #1
    2d8a:	e70d      	b.n	2ba8 <_malloc_r+0x340>
    2d8c:	480a      	ldr	r0, [pc, #40]	; (2db8 <_malloc_r+0x550>)
    2d8e:	4282      	cmp	r2, r0
    2d90:	d805      	bhi.n	2d9e <_malloc_r+0x536>
    2d92:	0c8a      	lsrs	r2, r1, #18
    2d94:	0010      	movs	r0, r2
    2d96:	327d      	adds	r2, #125	; 0x7d
    2d98:	307c      	adds	r0, #124	; 0x7c
    2d9a:	0052      	lsls	r2, r2, #1
    2d9c:	e704      	b.n	2ba8 <_malloc_r+0x340>
    2d9e:	22fe      	movs	r2, #254	; 0xfe
    2da0:	207e      	movs	r0, #126	; 0x7e
    2da2:	e701      	b.n	2ba8 <_malloc_r+0x340>
    2da4:	6873      	ldr	r3, [r6, #4]
    2da6:	e789      	b.n	2cbc <_malloc_r+0x454>
    2da8:	08e9      	lsrs	r1, r5, #3
    2daa:	1c4b      	adds	r3, r1, #1
    2dac:	005b      	lsls	r3, r3, #1
    2dae:	e619      	b.n	29e4 <_malloc_r+0x17c>
    2db0:	4653      	mov	r3, sl
    2db2:	9300      	str	r3, [sp, #0]
    2db4:	e5e0      	b.n	2978 <_malloc_r+0x110>
    2db6:	46c0      	nop			; (mov r8, r8)
    2db8:	00000554 	.word	0x00000554

00002dbc <memcpy>:
    2dbc:	b570      	push	{r4, r5, r6, lr}
    2dbe:	2a0f      	cmp	r2, #15
    2dc0:	d932      	bls.n	2e28 <memcpy+0x6c>
    2dc2:	000c      	movs	r4, r1
    2dc4:	4304      	orrs	r4, r0
    2dc6:	000b      	movs	r3, r1
    2dc8:	07a4      	lsls	r4, r4, #30
    2dca:	d131      	bne.n	2e30 <memcpy+0x74>
    2dcc:	0015      	movs	r5, r2
    2dce:	0004      	movs	r4, r0
    2dd0:	3d10      	subs	r5, #16
    2dd2:	092d      	lsrs	r5, r5, #4
    2dd4:	3501      	adds	r5, #1
    2dd6:	012d      	lsls	r5, r5, #4
    2dd8:	1949      	adds	r1, r1, r5
    2dda:	681e      	ldr	r6, [r3, #0]
    2ddc:	6026      	str	r6, [r4, #0]
    2dde:	685e      	ldr	r6, [r3, #4]
    2de0:	6066      	str	r6, [r4, #4]
    2de2:	689e      	ldr	r6, [r3, #8]
    2de4:	60a6      	str	r6, [r4, #8]
    2de6:	68de      	ldr	r6, [r3, #12]
    2de8:	3310      	adds	r3, #16
    2dea:	60e6      	str	r6, [r4, #12]
    2dec:	3410      	adds	r4, #16
    2dee:	4299      	cmp	r1, r3
    2df0:	d1f3      	bne.n	2dda <memcpy+0x1e>
    2df2:	230f      	movs	r3, #15
    2df4:	1945      	adds	r5, r0, r5
    2df6:	4013      	ands	r3, r2
    2df8:	2b03      	cmp	r3, #3
    2dfa:	d91b      	bls.n	2e34 <memcpy+0x78>
    2dfc:	1f1c      	subs	r4, r3, #4
    2dfe:	2300      	movs	r3, #0
    2e00:	08a4      	lsrs	r4, r4, #2
    2e02:	3401      	adds	r4, #1
    2e04:	00a4      	lsls	r4, r4, #2
    2e06:	58ce      	ldr	r6, [r1, r3]
    2e08:	50ee      	str	r6, [r5, r3]
    2e0a:	3304      	adds	r3, #4
    2e0c:	429c      	cmp	r4, r3
    2e0e:	d1fa      	bne.n	2e06 <memcpy+0x4a>
    2e10:	2303      	movs	r3, #3
    2e12:	192d      	adds	r5, r5, r4
    2e14:	1909      	adds	r1, r1, r4
    2e16:	401a      	ands	r2, r3
    2e18:	d005      	beq.n	2e26 <memcpy+0x6a>
    2e1a:	2300      	movs	r3, #0
    2e1c:	5ccc      	ldrb	r4, [r1, r3]
    2e1e:	54ec      	strb	r4, [r5, r3]
    2e20:	3301      	adds	r3, #1
    2e22:	429a      	cmp	r2, r3
    2e24:	d1fa      	bne.n	2e1c <memcpy+0x60>
    2e26:	bd70      	pop	{r4, r5, r6, pc}
    2e28:	0005      	movs	r5, r0
    2e2a:	2a00      	cmp	r2, #0
    2e2c:	d1f5      	bne.n	2e1a <memcpy+0x5e>
    2e2e:	e7fa      	b.n	2e26 <memcpy+0x6a>
    2e30:	0005      	movs	r5, r0
    2e32:	e7f2      	b.n	2e1a <memcpy+0x5e>
    2e34:	001a      	movs	r2, r3
    2e36:	e7f8      	b.n	2e2a <memcpy+0x6e>

00002e38 <__malloc_lock>:
    2e38:	4770      	bx	lr
    2e3a:	46c0      	nop			; (mov r8, r8)

00002e3c <__malloc_unlock>:
    2e3c:	4770      	bx	lr
    2e3e:	46c0      	nop			; (mov r8, r8)

00002e40 <_sbrk_r>:
    2e40:	2300      	movs	r3, #0
    2e42:	b570      	push	{r4, r5, r6, lr}
    2e44:	4c06      	ldr	r4, [pc, #24]	; (2e60 <_sbrk_r+0x20>)
    2e46:	0005      	movs	r5, r0
    2e48:	0008      	movs	r0, r1
    2e4a:	6023      	str	r3, [r4, #0]
    2e4c:	f7fd ff6c 	bl	d28 <_sbrk>
    2e50:	1c43      	adds	r3, r0, #1
    2e52:	d000      	beq.n	2e56 <_sbrk_r+0x16>
    2e54:	bd70      	pop	{r4, r5, r6, pc}
    2e56:	6823      	ldr	r3, [r4, #0]
    2e58:	2b00      	cmp	r3, #0
    2e5a:	d0fb      	beq.n	2e54 <_sbrk_r+0x14>
    2e5c:	602b      	str	r3, [r5, #0]
    2e5e:	e7f9      	b.n	2e54 <_sbrk_r+0x14>
    2e60:	20000994 	.word	0x20000994

00002e64 <register_fini>:
    2e64:	4b03      	ldr	r3, [pc, #12]	; (2e74 <register_fini+0x10>)
    2e66:	b510      	push	{r4, lr}
    2e68:	2b00      	cmp	r3, #0
    2e6a:	d002      	beq.n	2e72 <register_fini+0xe>
    2e6c:	4802      	ldr	r0, [pc, #8]	; (2e78 <register_fini+0x14>)
    2e6e:	f000 f805 	bl	2e7c <atexit>
    2e72:	bd10      	pop	{r4, pc}
    2e74:	00000000 	.word	0x00000000
    2e78:	00002e8d 	.word	0x00002e8d

00002e7c <atexit>:
    2e7c:	b510      	push	{r4, lr}
    2e7e:	0001      	movs	r1, r0
    2e80:	2300      	movs	r3, #0
    2e82:	2200      	movs	r2, #0
    2e84:	2000      	movs	r0, #0
    2e86:	f000 f94d 	bl	3124 <__register_exitproc>
    2e8a:	bd10      	pop	{r4, pc}

00002e8c <__libc_fini_array>:
    2e8c:	b570      	push	{r4, r5, r6, lr}
    2e8e:	4b09      	ldr	r3, [pc, #36]	; (2eb4 <__libc_fini_array+0x28>)
    2e90:	4c09      	ldr	r4, [pc, #36]	; (2eb8 <__libc_fini_array+0x2c>)
    2e92:	1ae4      	subs	r4, r4, r3
    2e94:	10a4      	asrs	r4, r4, #2
    2e96:	d009      	beq.n	2eac <__libc_fini_array+0x20>
    2e98:	4a08      	ldr	r2, [pc, #32]	; (2ebc <__libc_fini_array+0x30>)
    2e9a:	18a5      	adds	r5, r4, r2
    2e9c:	00ad      	lsls	r5, r5, #2
    2e9e:	18ed      	adds	r5, r5, r3
    2ea0:	682b      	ldr	r3, [r5, #0]
    2ea2:	3c01      	subs	r4, #1
    2ea4:	4798      	blx	r3
    2ea6:	3d04      	subs	r5, #4
    2ea8:	2c00      	cmp	r4, #0
    2eaa:	d1f9      	bne.n	2ea0 <__libc_fini_array+0x14>
    2eac:	f000 fadc 	bl	3468 <__init_array_end>
    2eb0:	bd70      	pop	{r4, r5, r6, pc}
    2eb2:	46c0      	nop			; (mov r8, r8)
	...
    2ebc:	3fffffff 	.word	0x3fffffff

00002ec0 <_malloc_trim_r>:
    2ec0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2ec2:	000c      	movs	r4, r1
    2ec4:	0006      	movs	r6, r0
    2ec6:	f7ff ffb7 	bl	2e38 <__malloc_lock>
    2eca:	4f20      	ldr	r7, [pc, #128]	; (2f4c <_malloc_trim_r+0x8c>)
    2ecc:	68bb      	ldr	r3, [r7, #8]
    2ece:	685d      	ldr	r5, [r3, #4]
    2ed0:	2303      	movs	r3, #3
    2ed2:	439d      	bics	r5, r3
    2ed4:	4b1e      	ldr	r3, [pc, #120]	; (2f50 <_malloc_trim_r+0x90>)
    2ed6:	1b2c      	subs	r4, r5, r4
    2ed8:	469c      	mov	ip, r3
    2eda:	4464      	add	r4, ip
    2edc:	0b24      	lsrs	r4, r4, #12
    2ede:	4b1d      	ldr	r3, [pc, #116]	; (2f54 <_malloc_trim_r+0x94>)
    2ee0:	3c01      	subs	r4, #1
    2ee2:	0324      	lsls	r4, r4, #12
    2ee4:	429c      	cmp	r4, r3
    2ee6:	dd07      	ble.n	2ef8 <_malloc_trim_r+0x38>
    2ee8:	2100      	movs	r1, #0
    2eea:	0030      	movs	r0, r6
    2eec:	f7ff ffa8 	bl	2e40 <_sbrk_r>
    2ef0:	68bb      	ldr	r3, [r7, #8]
    2ef2:	195b      	adds	r3, r3, r5
    2ef4:	4298      	cmp	r0, r3
    2ef6:	d004      	beq.n	2f02 <_malloc_trim_r+0x42>
    2ef8:	0030      	movs	r0, r6
    2efa:	f7ff ff9f 	bl	2e3c <__malloc_unlock>
    2efe:	2000      	movs	r0, #0
    2f00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2f02:	4261      	negs	r1, r4
    2f04:	0030      	movs	r0, r6
    2f06:	f7ff ff9b 	bl	2e40 <_sbrk_r>
    2f0a:	1c43      	adds	r3, r0, #1
    2f0c:	d00d      	beq.n	2f2a <_malloc_trim_r+0x6a>
    2f0e:	2301      	movs	r3, #1
    2f10:	1b2d      	subs	r5, r5, r4
    2f12:	68ba      	ldr	r2, [r7, #8]
    2f14:	431d      	orrs	r5, r3
    2f16:	4b10      	ldr	r3, [pc, #64]	; (2f58 <_malloc_trim_r+0x98>)
    2f18:	6055      	str	r5, [r2, #4]
    2f1a:	681a      	ldr	r2, [r3, #0]
    2f1c:	0030      	movs	r0, r6
    2f1e:	1b14      	subs	r4, r2, r4
    2f20:	601c      	str	r4, [r3, #0]
    2f22:	f7ff ff8b 	bl	2e3c <__malloc_unlock>
    2f26:	2001      	movs	r0, #1
    2f28:	e7ea      	b.n	2f00 <_malloc_trim_r+0x40>
    2f2a:	2100      	movs	r1, #0
    2f2c:	0030      	movs	r0, r6
    2f2e:	f7ff ff87 	bl	2e40 <_sbrk_r>
    2f32:	68bb      	ldr	r3, [r7, #8]
    2f34:	1ac2      	subs	r2, r0, r3
    2f36:	2a0f      	cmp	r2, #15
    2f38:	ddde      	ble.n	2ef8 <_malloc_trim_r+0x38>
    2f3a:	4908      	ldr	r1, [pc, #32]	; (2f5c <_malloc_trim_r+0x9c>)
    2f3c:	6809      	ldr	r1, [r1, #0]
    2f3e:	1a40      	subs	r0, r0, r1
    2f40:	4905      	ldr	r1, [pc, #20]	; (2f58 <_malloc_trim_r+0x98>)
    2f42:	6008      	str	r0, [r1, #0]
    2f44:	2101      	movs	r1, #1
    2f46:	430a      	orrs	r2, r1
    2f48:	605a      	str	r2, [r3, #4]
    2f4a:	e7d5      	b.n	2ef8 <_malloc_trim_r+0x38>
    2f4c:	2000027c 	.word	0x2000027c
    2f50:	00000fef 	.word	0x00000fef
    2f54:	00000fff 	.word	0x00000fff
    2f58:	20000958 	.word	0x20000958
    2f5c:	20000688 	.word	0x20000688

00002f60 <_free_r>:
    2f60:	b5f0      	push	{r4, r5, r6, r7, lr}
    2f62:	4647      	mov	r7, r8
    2f64:	0005      	movs	r5, r0
    2f66:	b480      	push	{r7}
    2f68:	1e0c      	subs	r4, r1, #0
    2f6a:	d03e      	beq.n	2fea <_free_r+0x8a>
    2f6c:	f7ff ff64 	bl	2e38 <__malloc_lock>
    2f70:	2301      	movs	r3, #1
    2f72:	0021      	movs	r1, r4
    2f74:	4698      	mov	r8, r3
    2f76:	3908      	subs	r1, #8
    2f78:	684e      	ldr	r6, [r1, #4]
    2f7a:	4642      	mov	r2, r8
    2f7c:	0033      	movs	r3, r6
    2f7e:	2003      	movs	r0, #3
    2f80:	4393      	bics	r3, r2
    2f82:	18cc      	adds	r4, r1, r3
    2f84:	6862      	ldr	r2, [r4, #4]
    2f86:	4382      	bics	r2, r0
    2f88:	4860      	ldr	r0, [pc, #384]	; (310c <_free_r+0x1ac>)
    2f8a:	6887      	ldr	r7, [r0, #8]
    2f8c:	42bc      	cmp	r4, r7
    2f8e:	d05a      	beq.n	3046 <_free_r+0xe6>
    2f90:	4647      	mov	r7, r8
    2f92:	6062      	str	r2, [r4, #4]
    2f94:	4237      	tst	r7, r6
    2f96:	d10b      	bne.n	2fb0 <_free_r+0x50>
    2f98:	2708      	movs	r7, #8
    2f9a:	46bc      	mov	ip, r7
    2f9c:	680e      	ldr	r6, [r1, #0]
    2f9e:	4484      	add	ip, r0
    2fa0:	1b89      	subs	r1, r1, r6
    2fa2:	199b      	adds	r3, r3, r6
    2fa4:	688e      	ldr	r6, [r1, #8]
    2fa6:	4566      	cmp	r6, ip
    2fa8:	d066      	beq.n	3078 <_free_r+0x118>
    2faa:	68cf      	ldr	r7, [r1, #12]
    2fac:	60f7      	str	r7, [r6, #12]
    2fae:	60be      	str	r6, [r7, #8]
    2fb0:	2601      	movs	r6, #1
    2fb2:	18a7      	adds	r7, r4, r2
    2fb4:	687f      	ldr	r7, [r7, #4]
    2fb6:	4237      	tst	r7, r6
    2fb8:	d036      	beq.n	3028 <_free_r+0xc8>
    2fba:	4a55      	ldr	r2, [pc, #340]	; (3110 <_free_r+0x1b0>)
    2fbc:	431e      	orrs	r6, r3
    2fbe:	604e      	str	r6, [r1, #4]
    2fc0:	50cb      	str	r3, [r1, r3]
    2fc2:	4293      	cmp	r3, r2
    2fc4:	d814      	bhi.n	2ff0 <_free_r+0x90>
    2fc6:	08db      	lsrs	r3, r3, #3
    2fc8:	3aff      	subs	r2, #255	; 0xff
    2fca:	109c      	asrs	r4, r3, #2
    2fcc:	3aff      	subs	r2, #255	; 0xff
    2fce:	40a2      	lsls	r2, r4
    2fd0:	6844      	ldr	r4, [r0, #4]
    2fd2:	00db      	lsls	r3, r3, #3
    2fd4:	4322      	orrs	r2, r4
    2fd6:	6042      	str	r2, [r0, #4]
    2fd8:	1818      	adds	r0, r3, r0
    2fda:	6883      	ldr	r3, [r0, #8]
    2fdc:	60c8      	str	r0, [r1, #12]
    2fde:	608b      	str	r3, [r1, #8]
    2fe0:	6081      	str	r1, [r0, #8]
    2fe2:	60d9      	str	r1, [r3, #12]
    2fe4:	0028      	movs	r0, r5
    2fe6:	f7ff ff29 	bl	2e3c <__malloc_unlock>
    2fea:	bc04      	pop	{r2}
    2fec:	4690      	mov	r8, r2
    2fee:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2ff0:	0a5a      	lsrs	r2, r3, #9
    2ff2:	2a04      	cmp	r2, #4
    2ff4:	d84f      	bhi.n	3096 <_free_r+0x136>
    2ff6:	099c      	lsrs	r4, r3, #6
    2ff8:	0026      	movs	r6, r4
    2ffa:	3439      	adds	r4, #57	; 0x39
    2ffc:	3638      	adds	r6, #56	; 0x38
    2ffe:	0064      	lsls	r4, r4, #1
    3000:	00a4      	lsls	r4, r4, #2
    3002:	1904      	adds	r4, r0, r4
    3004:	3c08      	subs	r4, #8
    3006:	68a2      	ldr	r2, [r4, #8]
    3008:	2703      	movs	r7, #3
    300a:	4294      	cmp	r4, r2
    300c:	d04a      	beq.n	30a4 <_free_r+0x144>
    300e:	6850      	ldr	r0, [r2, #4]
    3010:	43b8      	bics	r0, r7
    3012:	4283      	cmp	r3, r0
    3014:	d202      	bcs.n	301c <_free_r+0xbc>
    3016:	6892      	ldr	r2, [r2, #8]
    3018:	4294      	cmp	r4, r2
    301a:	d1f8      	bne.n	300e <_free_r+0xae>
    301c:	68d4      	ldr	r4, [r2, #12]
    301e:	60cc      	str	r4, [r1, #12]
    3020:	608a      	str	r2, [r1, #8]
    3022:	60a1      	str	r1, [r4, #8]
    3024:	60d1      	str	r1, [r2, #12]
    3026:	e7dd      	b.n	2fe4 <_free_r+0x84>
    3028:	189b      	adds	r3, r3, r2
    302a:	4f3a      	ldr	r7, [pc, #232]	; (3114 <_free_r+0x1b4>)
    302c:	68a2      	ldr	r2, [r4, #8]
    302e:	42ba      	cmp	r2, r7
    3030:	d040      	beq.n	30b4 <_free_r+0x154>
    3032:	68e4      	ldr	r4, [r4, #12]
    3034:	431e      	orrs	r6, r3
    3036:	60d4      	str	r4, [r2, #12]
    3038:	60a2      	str	r2, [r4, #8]
    303a:	4a35      	ldr	r2, [pc, #212]	; (3110 <_free_r+0x1b0>)
    303c:	604e      	str	r6, [r1, #4]
    303e:	50cb      	str	r3, [r1, r3]
    3040:	4293      	cmp	r3, r2
    3042:	d8d5      	bhi.n	2ff0 <_free_r+0x90>
    3044:	e7bf      	b.n	2fc6 <_free_r+0x66>
    3046:	189b      	adds	r3, r3, r2
    3048:	4642      	mov	r2, r8
    304a:	4232      	tst	r2, r6
    304c:	d106      	bne.n	305c <_free_r+0xfc>
    304e:	680a      	ldr	r2, [r1, #0]
    3050:	1a89      	subs	r1, r1, r2
    3052:	688c      	ldr	r4, [r1, #8]
    3054:	189b      	adds	r3, r3, r2
    3056:	68ca      	ldr	r2, [r1, #12]
    3058:	60e2      	str	r2, [r4, #12]
    305a:	6094      	str	r4, [r2, #8]
    305c:	2401      	movs	r4, #1
    305e:	4a2e      	ldr	r2, [pc, #184]	; (3118 <_free_r+0x1b8>)
    3060:	431c      	orrs	r4, r3
    3062:	6812      	ldr	r2, [r2, #0]
    3064:	604c      	str	r4, [r1, #4]
    3066:	6081      	str	r1, [r0, #8]
    3068:	4293      	cmp	r3, r2
    306a:	d3bb      	bcc.n	2fe4 <_free_r+0x84>
    306c:	4b2b      	ldr	r3, [pc, #172]	; (311c <_free_r+0x1bc>)
    306e:	0028      	movs	r0, r5
    3070:	6819      	ldr	r1, [r3, #0]
    3072:	f7ff ff25 	bl	2ec0 <_malloc_trim_r>
    3076:	e7b5      	b.n	2fe4 <_free_r+0x84>
    3078:	4646      	mov	r6, r8
    307a:	18a0      	adds	r0, r4, r2
    307c:	6840      	ldr	r0, [r0, #4]
    307e:	4230      	tst	r0, r6
    3080:	d13e      	bne.n	3100 <_free_r+0x1a0>
    3082:	68a0      	ldr	r0, [r4, #8]
    3084:	18d3      	adds	r3, r2, r3
    3086:	68e2      	ldr	r2, [r4, #12]
    3088:	60c2      	str	r2, [r0, #12]
    308a:	6090      	str	r0, [r2, #8]
    308c:	4642      	mov	r2, r8
    308e:	431a      	orrs	r2, r3
    3090:	604a      	str	r2, [r1, #4]
    3092:	50cb      	str	r3, [r1, r3]
    3094:	e7a6      	b.n	2fe4 <_free_r+0x84>
    3096:	2a14      	cmp	r2, #20
    3098:	d814      	bhi.n	30c4 <_free_r+0x164>
    309a:	0016      	movs	r6, r2
    309c:	325c      	adds	r2, #92	; 0x5c
    309e:	365b      	adds	r6, #91	; 0x5b
    30a0:	0054      	lsls	r4, r2, #1
    30a2:	e7ad      	b.n	3000 <_free_r+0xa0>
    30a4:	2301      	movs	r3, #1
    30a6:	10b6      	asrs	r6, r6, #2
    30a8:	40b3      	lsls	r3, r6
    30aa:	6842      	ldr	r2, [r0, #4]
    30ac:	4313      	orrs	r3, r2
    30ae:	6043      	str	r3, [r0, #4]
    30b0:	0022      	movs	r2, r4
    30b2:	e7b4      	b.n	301e <_free_r+0xbe>
    30b4:	431e      	orrs	r6, r3
    30b6:	60d1      	str	r1, [r2, #12]
    30b8:	6091      	str	r1, [r2, #8]
    30ba:	60ca      	str	r2, [r1, #12]
    30bc:	608a      	str	r2, [r1, #8]
    30be:	604e      	str	r6, [r1, #4]
    30c0:	50cb      	str	r3, [r1, r3]
    30c2:	e78f      	b.n	2fe4 <_free_r+0x84>
    30c4:	2a54      	cmp	r2, #84	; 0x54
    30c6:	d805      	bhi.n	30d4 <_free_r+0x174>
    30c8:	0b1c      	lsrs	r4, r3, #12
    30ca:	0026      	movs	r6, r4
    30cc:	346f      	adds	r4, #111	; 0x6f
    30ce:	366e      	adds	r6, #110	; 0x6e
    30d0:	0064      	lsls	r4, r4, #1
    30d2:	e795      	b.n	3000 <_free_r+0xa0>
    30d4:	24aa      	movs	r4, #170	; 0xaa
    30d6:	0064      	lsls	r4, r4, #1
    30d8:	42a2      	cmp	r2, r4
    30da:	d805      	bhi.n	30e8 <_free_r+0x188>
    30dc:	0bdc      	lsrs	r4, r3, #15
    30de:	0026      	movs	r6, r4
    30e0:	3478      	adds	r4, #120	; 0x78
    30e2:	3677      	adds	r6, #119	; 0x77
    30e4:	0064      	lsls	r4, r4, #1
    30e6:	e78b      	b.n	3000 <_free_r+0xa0>
    30e8:	4c0d      	ldr	r4, [pc, #52]	; (3120 <_free_r+0x1c0>)
    30ea:	42a2      	cmp	r2, r4
    30ec:	d805      	bhi.n	30fa <_free_r+0x19a>
    30ee:	0c9c      	lsrs	r4, r3, #18
    30f0:	0026      	movs	r6, r4
    30f2:	347d      	adds	r4, #125	; 0x7d
    30f4:	367c      	adds	r6, #124	; 0x7c
    30f6:	0064      	lsls	r4, r4, #1
    30f8:	e782      	b.n	3000 <_free_r+0xa0>
    30fa:	24fe      	movs	r4, #254	; 0xfe
    30fc:	267e      	movs	r6, #126	; 0x7e
    30fe:	e77f      	b.n	3000 <_free_r+0xa0>
    3100:	4642      	mov	r2, r8
    3102:	431a      	orrs	r2, r3
    3104:	604a      	str	r2, [r1, #4]
    3106:	50cb      	str	r3, [r1, r3]
    3108:	e76c      	b.n	2fe4 <_free_r+0x84>
    310a:	46c0      	nop			; (mov r8, r8)
    310c:	2000027c 	.word	0x2000027c
    3110:	000001ff 	.word	0x000001ff
    3114:	20000284 	.word	0x20000284
    3118:	20000684 	.word	0x20000684
    311c:	20000954 	.word	0x20000954
    3120:	00000554 	.word	0x00000554

00003124 <__register_exitproc>:
    3124:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3126:	4644      	mov	r4, r8
    3128:	465f      	mov	r7, fp
    312a:	4656      	mov	r6, sl
    312c:	464d      	mov	r5, r9
    312e:	469b      	mov	fp, r3
    3130:	4b2f      	ldr	r3, [pc, #188]	; (31f0 <__register_exitproc+0xcc>)
    3132:	b4f0      	push	{r4, r5, r6, r7}
    3134:	681c      	ldr	r4, [r3, #0]
    3136:	23a4      	movs	r3, #164	; 0xa4
    3138:	005b      	lsls	r3, r3, #1
    313a:	0005      	movs	r5, r0
    313c:	58e0      	ldr	r0, [r4, r3]
    313e:	000e      	movs	r6, r1
    3140:	4690      	mov	r8, r2
    3142:	2800      	cmp	r0, #0
    3144:	d04b      	beq.n	31de <__register_exitproc+0xba>
    3146:	6843      	ldr	r3, [r0, #4]
    3148:	2b1f      	cmp	r3, #31
    314a:	dc0d      	bgt.n	3168 <__register_exitproc+0x44>
    314c:	1c5c      	adds	r4, r3, #1
    314e:	2d00      	cmp	r5, #0
    3150:	d121      	bne.n	3196 <__register_exitproc+0x72>
    3152:	3302      	adds	r3, #2
    3154:	009b      	lsls	r3, r3, #2
    3156:	6044      	str	r4, [r0, #4]
    3158:	501e      	str	r6, [r3, r0]
    315a:	2000      	movs	r0, #0
    315c:	bc3c      	pop	{r2, r3, r4, r5}
    315e:	4690      	mov	r8, r2
    3160:	4699      	mov	r9, r3
    3162:	46a2      	mov	sl, r4
    3164:	46ab      	mov	fp, r5
    3166:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3168:	4b22      	ldr	r3, [pc, #136]	; (31f4 <__register_exitproc+0xd0>)
    316a:	2b00      	cmp	r3, #0
    316c:	d03c      	beq.n	31e8 <__register_exitproc+0xc4>
    316e:	20c8      	movs	r0, #200	; 0xc8
    3170:	0040      	lsls	r0, r0, #1
    3172:	f7ff fb6f 	bl	2854 <malloc>
    3176:	2800      	cmp	r0, #0
    3178:	d036      	beq.n	31e8 <__register_exitproc+0xc4>
    317a:	22a4      	movs	r2, #164	; 0xa4
    317c:	2300      	movs	r3, #0
    317e:	0052      	lsls	r2, r2, #1
    3180:	58a1      	ldr	r1, [r4, r2]
    3182:	6043      	str	r3, [r0, #4]
    3184:	6001      	str	r1, [r0, #0]
    3186:	50a0      	str	r0, [r4, r2]
    3188:	3240      	adds	r2, #64	; 0x40
    318a:	5083      	str	r3, [r0, r2]
    318c:	3204      	adds	r2, #4
    318e:	5083      	str	r3, [r0, r2]
    3190:	2401      	movs	r4, #1
    3192:	2d00      	cmp	r5, #0
    3194:	d0dd      	beq.n	3152 <__register_exitproc+0x2e>
    3196:	009a      	lsls	r2, r3, #2
    3198:	4691      	mov	r9, r2
    319a:	4481      	add	r9, r0
    319c:	4642      	mov	r2, r8
    319e:	2188      	movs	r1, #136	; 0x88
    31a0:	464f      	mov	r7, r9
    31a2:	507a      	str	r2, [r7, r1]
    31a4:	22c4      	movs	r2, #196	; 0xc4
    31a6:	0052      	lsls	r2, r2, #1
    31a8:	4690      	mov	r8, r2
    31aa:	4480      	add	r8, r0
    31ac:	4642      	mov	r2, r8
    31ae:	3987      	subs	r1, #135	; 0x87
    31b0:	4099      	lsls	r1, r3
    31b2:	6812      	ldr	r2, [r2, #0]
    31b4:	468a      	mov	sl, r1
    31b6:	430a      	orrs	r2, r1
    31b8:	4694      	mov	ip, r2
    31ba:	4642      	mov	r2, r8
    31bc:	4661      	mov	r1, ip
    31be:	6011      	str	r1, [r2, #0]
    31c0:	2284      	movs	r2, #132	; 0x84
    31c2:	4649      	mov	r1, r9
    31c4:	465f      	mov	r7, fp
    31c6:	0052      	lsls	r2, r2, #1
    31c8:	508f      	str	r7, [r1, r2]
    31ca:	2d02      	cmp	r5, #2
    31cc:	d1c1      	bne.n	3152 <__register_exitproc+0x2e>
    31ce:	0002      	movs	r2, r0
    31d0:	4655      	mov	r5, sl
    31d2:	328d      	adds	r2, #141	; 0x8d
    31d4:	32ff      	adds	r2, #255	; 0xff
    31d6:	6811      	ldr	r1, [r2, #0]
    31d8:	430d      	orrs	r5, r1
    31da:	6015      	str	r5, [r2, #0]
    31dc:	e7b9      	b.n	3152 <__register_exitproc+0x2e>
    31de:	0020      	movs	r0, r4
    31e0:	304d      	adds	r0, #77	; 0x4d
    31e2:	30ff      	adds	r0, #255	; 0xff
    31e4:	50e0      	str	r0, [r4, r3]
    31e6:	e7ae      	b.n	3146 <__register_exitproc+0x22>
    31e8:	2001      	movs	r0, #1
    31ea:	4240      	negs	r0, r0
    31ec:	e7b6      	b.n	315c <__register_exitproc+0x38>
    31ee:	46c0      	nop			; (mov r8, r8)
    31f0:	00003450 	.word	0x00003450
    31f4:	00002855 	.word	0x00002855
    31f8:	646e654c 	.word	0x646e654c
    31fc:	736f206f 	.word	0x736f206f
    3200:	69727020 	.word	0x69727020
    3204:	7269656d 	.word	0x7269656d
    3208:	3120736f 	.word	0x3120736f
    320c:	65722035 	.word	0x65722035
    3210:	74736967 	.word	0x74736967
    3214:	6f646172 	.word	0x6f646172
    3218:	20736572 	.word	0x20736572
    321c:	63206164 	.word	0x63206164
    3220:	656da2c3 	.word	0x656da2c3
    3224:	00006172 	.word	0x00006172
    3228:	69676552 	.word	0x69676552
    322c:	61727473 	.word	0x61727473
    3230:	3a726f64 	.word	0x3a726f64
    3234:	00000020 	.word	0x00000020
    3238:	61562020 	.word	0x61562020
    323c:	3a726f6c 	.word	0x3a726f6c
    3240:	00000020 	.word	0x00000020

00003244 <TwoWire::i2c0_hardware>:
    3244:	40048034 00000040 ffff1112 000202ff     4..@@...........
    3254:	10130000 02ffffff 00000002 00000008     ................

00003264 <vtable for TwoWire>:
	...
    326c:	0000063d 00000601 000005b9 000005fd     =...............
    327c:	000005bd 000005c9 000005e5 ffff0a0d     ................

0000328c <digital_pin_to_info_PGM>:
    328c:	f8000042 4004a040 00000001 f8000042     B...@..@....B...
    329c:	4004a044 00000002 f80000c0 4004c000     D..@...........@
    32ac:	00000001 f8000000 40049004 00000002     ...........@....
    32bc:	f8000000 40049008 00000004 f80000c0     .......@........
    32cc:	4004c01c 00000080 f80000c0 4004c010     ...@...........@
    32dc:	00000010 f80000c0 4004c008 00000004     ...........@....
    32ec:	f80000c0 4004c00c 00000008 f8000080     .......@........
    32fc:	4004b00c 00000008 f8000080 4004b010     ...@...........@
    330c:	00000010 f8000080 4004b018 00000040     ...........@@...
    331c:	f8000080 4004b01c 00000080 f8000080     .......@........
    332c:	4004b014 00000020 f80000c0 4004c004     ...@ ..........@
    333c:	00000002 f8000080 4004b000 00000001     ...........@....
    334c:	f8000040 4004a000 00000001 f8000040     @......@....@...
    335c:	4004a004 00000002 f8000040 4004a00c     ...@....@......@
    336c:	00000008 f8000040 4004a008 00000004     ....@......@....
    337c:	f80000c0 4004c014 00000020 f80000c0     .......@ .......
    338c:	4004c018 00000040 f8000080 4004b004     ...@@..........@
    339c:	00000002 f8000080 4004b008 00000004     ...........@....
    33ac:	f8000102 4004d050 00000010 f8000102     ....P..@........
    33bc:	4004d054 00000020 f8000103 4004d078     T..@ .......x..@
    33cc:	00000040                                @...

000033d0 <vtable for usb_serial_class>:
	...
    33d8:	000019cd 000019c1 000019b9 000019b1     ................
    33e8:	000019a9 000019a1 00001999 00001991     ................

000033f8 <usb_endpoint_config_table>:
    33f8:	15191500                                ....

000033fc <usb_descriptor_list>:
    33fc:	00000100 1ffffda8 00000012 00000200     ................
    340c:	1ffffdd4 00000043 00000300 1ffffe30     ....C.......0...
    341c:	00000000 04090301 1ffffdbc 00000000     ................
    342c:	04090302 1ffffe18 00000000 04090303     ................
    343c:	1ffffe34 00000000 00000000 00000000     4...............
    344c:	00000000                                ....

00003450 <_global_impure_ptr>:
    3450:	1ffffe50                                P...

00003454 <_init>:
    3454:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3456:	46c0      	nop			; (mov r8, r8)
    3458:	bcf8      	pop	{r3, r4, r5, r6, r7}
    345a:	bc08      	pop	{r3}
    345c:	469e      	mov	lr, r3
    345e:	4770      	bx	lr

00003460 <__init_array_start>:
    3460:	00002e65 	.word	0x00002e65

00003464 <__frame_dummy_init_array_entry>:
    3464:	00000439                                9...

Disassembly of section .fini:

00003468 <_fini>:
    3468:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    346a:	46c0      	nop			; (mov r8, r8)
